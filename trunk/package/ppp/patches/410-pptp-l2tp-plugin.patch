diff -uprN ppp-2.4.3.old/configure ppp-2.4.3/configure
--- ppp-2.4.3.old/configure	2008-09-20 22:27:34.000000000 +0400
+++ ppp-2.4.3/configure	2008-09-20 22:27:45.000000000 +0400
@@ -173,7 +173,7 @@ if [ -d "$ksrc" ]; then
     echo "Creating Makefiles."
     mkmkf $ksrc/Makefile.top Makefile
     mkmkf $ksrc/Makedefs$compiletype Makedefs.com
-    for dir in pppd pppstats chat pppdump pppd/plugins pppd/plugins/rp-pppoe \
+    for dir in pppd pppstats chat pppdump pppd/plugins pppd/plugins/rp-pppoe pppd/plugins/pptp pppd/plugins/pppol2tp \
 	       pppd/plugins/radius pppd/plugins/pppoatm; do
 	mkmkf $dir/Makefile.$makext $dir/Makefile
     done
diff -uprN ppp-2.4.3.old/include/linux/if_pppol2tp.h ppp-2.4.3/include/linux/if_pppol2tp.h
--- ppp-2.4.3.old/include/linux/if_pppol2tp.h	1970-01-01 03:00:00.000000000 +0300
+++ ppp-2.4.3/include/linux/if_pppol2tp.h	2008-09-20 22:27:45.000000000 +0400
@@ -0,0 +1,67 @@
+/***************************************************************************
+ * Linux PPP over L2TP (PPPoL2TP) Socket Implementation (RFC 2661)
+ *
+ * This file supplies definitions required by the PPP over L2TP driver
+ * (pppol2tp.c).  All version information wrt this file is located in pppol2tp.c
+ *
+ * License:
+ *		This program is free software; you can redistribute it and/or
+ *		modify it under the terms of the GNU General Public License
+ *		as published by the Free Software Foundation; either version
+ *		2 of the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef __LINUX_IF_PPPOL2TP_H
+#define __LINUX_IF_PPPOL2TP_H
+
+#include <asm/types.h>
+
+#ifdef __KERNEL__
+#include <linux/in.h>
+#endif
+
+/* Structure used to bind() the socket to a particular socket & tunnel */
+struct pppol2tp_addr
+{
+	pid_t	pid;			/* pid that owns the fd.
+					 * 0 => current */
+	int	fd;			/* FD of UDP socket to use */
+
+	struct sockaddr_in addr;	/* IP address and port to send to */
+
+	__u16 s_tunnel, s_session;	/* For matching incoming packets */
+	__u16 d_tunnel, d_session;	/* For sending outgoing packets */
+};
+
+/* Socket options:
+ * DEBUG	- bitmask of debug message categories
+ * SENDSEQ	- 0 => don't send packets with sequence numbers
+ *		  1 => send packets with sequence numbers
+ * RECVSEQ	- 0 => receive packet sequence numbers are optional
+ *		  1 => drop receive packets without sequence numbers
+ * LNSMODE	- 0 => act as LAC.
+ *		  1 => act as LNS.
+ * REORDERTO	- reorder timeout (in millisecs). If 0, don't try to reorder.
+ */
+enum {
+	PPPOL2TP_SO_DEBUG	= 1,
+	PPPOL2TP_SO_RECVSEQ	= 2,
+	PPPOL2TP_SO_SENDSEQ	= 3,
+	PPPOL2TP_SO_LNSMODE	= 4,
+	PPPOL2TP_SO_REORDERTO	= 5,
+};
+
+/* Debug message categories for the DEBUG socket option */
+enum {
+	PPPOL2TP_MSG_DEBUG	= (1 << 0),	/* verbose debug (if
+						 * compiled in) */
+	PPPOL2TP_MSG_CONTROL	= (1 << 1),	/* userspace - kernel
+						 * interface */
+	PPPOL2TP_MSG_SEQ	= (1 << 2),	/* sequence numbers */
+	PPPOL2TP_MSG_DATA	= (1 << 3),	/* data packets */
+};
+
+
+
+#endif
diff -uprN ppp-2.4.3.old/pppd/plugins/Makefile.linux ppp-2.4.3/pppd/plugins/Makefile.linux
--- ppp-2.4.3.old/pppd/plugins/Makefile.linux	2008-09-20 22:27:34.000000000 +0400
+++ ppp-2.4.3/pppd/plugins/Makefile.linux	2008-09-20 22:27:45.000000000 +0400
@@ -9,9 +9,9 @@
 MANDIR = $(DESTDIR)/share/man/man8
 LIBDIR = $(DESTDIR)/lib/pppd/$(VERSION)
 
-SUBDIRS := rp-pppoe pppoatm
+SUBDIRS := rp-pppoe pppoatm pptp pppol2tp radius
 # Uncomment the next line to include the radius authentication plugin
-SUBDIRS += radius
+# SUBDIRS += radius
 PLUGINS := minconn.so passprompt.so passwordfd.so winbind.so
 
 # include dependencies if present
diff -uprN ppp-2.4.3.old/pppd/plugins/pppol2tp/Makefile.linux ppp-2.4.3/pppd/plugins/pppol2tp/Makefile.linux
--- ppp-2.4.3.old/pppd/plugins/pppol2tp/Makefile.linux	1970-01-01 03:00:00.000000000 +0300
+++ ppp-2.4.3/pppd/plugins/pppol2tp/Makefile.linux	2008-09-20 22:45:29.000000000 +0400
@@ -0,0 +1,49 @@
+#-------------------------------------------------------------------------------------
+#-------------------------------------------------------------------------------------
+
+CC      = $(CROSS_COMPILE_PREFIX)gcc
+
+INSTALL	= install
+
+COPTS=-O2
+CFLAGS=$(COPTS) -I../../../include -I../..
+
+LDFLAGS	= -shared
+
+CFLAGS+=-D_linux_=1 -DMPPE  -DUSE_CRYPT -D_DISABLE_SERIAL
+
+CCP_SUPPORT=y
+
+ifdef CCP_SUPPORT
+CFLAGS += -DCCP_SUPPORT
+endif
+
+all: pppol2tp.so
+
+PPPDVERSION = $(shell awk -F '"' '/VERSION/ { print $$2; }' ../../patchlevel.h)
+LIBDIR = $(DESTDIR)/lib/pppd/$(PPPDVERSION)
+
+PLUGINSRCS= pppol2tp.c
+
+#
+# include dependancies if present and backup if as a header file
+ifeq (.depend,$(wildcard .depend))
+include .depend
+endif
+
+pppol2tp.so: pppol2tp.o
+	$(CC) -o $@ $(LDFLAGS) $^
+	cp pppol2tp.so libpppol2tp.so
+
+%.so: %.c
+	$(CC) -o $@ $(LDFLAGS) $(CFLAGS) $^
+
+clean: 
+	rm -f *.o *.so
+
+install: all
+	$(INSTALL) -d -m 755 $(LIBDIR)
+	$(INSTALL) -c -m 4550 pppol2tp.so $(LIBDIR)
+
+depend:
+	$(CPP) -M $(CFLAGS) $(PLUGINSRCS) >.depend
diff -uprN ppp-2.4.3.old/pppd/plugins/pptp/dirutil.c ppp-2.4.3/pppd/plugins/pptp/dirutil.c
--- ppp-2.4.3.old/pppd/plugins/pptp/dirutil.c	1970-01-01 03:00:00.000000000 +0300
+++ ppp-2.4.3/pppd/plugins/pptp/dirutil.c	2008-09-20 22:27:45.000000000 +0400
@@ -0,0 +1,68 @@
+/* dirutil.c ... directory utilities.
+ *               C. Scott Ananian <cananian@alumni.princeton.edu>
+ *
+ * $Id: dirutil.c,v 1.2 2003/06/17 17:25:47 reink Exp $
+ */
+
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <unistd.h>
+#include <string.h>
+#include <stdlib.h>
+#include "dirutil.h"
+
+/* Returned malloc'ed string representing basename */
+char *basenamex(char *pathname)
+{
+    char *dup = strdup(pathname);
+    char *ptr = strrchr(stripslash(dup), '/');
+    if (ptr == NULL) return dup;
+    ptr = strdup(ptr+1);
+    free(dup);
+    return ptr;
+}
+
+/* Return malloc'ed string representing directory name (no trailing slash) */
+char *dirnamex(char *pathname)
+{
+    char *dup = strdup(pathname);
+    char *ptr = strrchr(stripslash(dup), '/');
+    if (ptr == NULL) { free(dup); return strdup("."); }
+    if (ptr == dup && dup[0] == '/') ptr++;
+    *ptr = '\0';
+    return dup;
+}
+
+/* In-place modify a string to remove trailing slashes.  Returns arg.
+ * stripslash("/") returns "/";
+ */
+char *stripslash(char *pathname) {
+    int len = strlen(pathname);
+    while (len > 1 && pathname[len - 1] == '/')
+        pathname[--len] = '\0';
+    return pathname;
+}
+
+/* ensure dirname exists, creating it if necessary. */
+int make_valid_path(char *dir, mode_t mode)
+{
+    struct stat st;
+    char *tmp = NULL, *path = stripslash(strdup(dir));
+    int retval;
+    if (stat(path, &st) == 0) { /* file exists */
+        if (S_ISDIR(st.st_mode)) { retval = 1; goto end; }
+        else { retval = 0; goto end; } /* not a directory.  Oops. */
+    }
+    /* Directory doesn't exist.  Let's make it. */
+    /*   Make parent first. */
+    if (!make_valid_path(tmp = dirnamex(path), mode)) { retval = 0; goto end; }
+    /*   Now make this 'un. */
+    if (mkdir(path, mode) < 0) { retval = 0; goto end; }
+    /* Success. */
+    retval = 1;
+
+end:
+    if (tmp != NULL) free(tmp);
+    if (path != NULL) free(path);
+    return retval;
+}
diff -uprN ppp-2.4.3.old/pppd/plugins/pptp/dirutil.h ppp-2.4.3/pppd/plugins/pptp/dirutil.h
--- ppp-2.4.3.old/pppd/plugins/pptp/dirutil.h	1970-01-01 03:00:00.000000000 +0300
+++ ppp-2.4.3/pppd/plugins/pptp/dirutil.h	2008-09-20 22:27:45.000000000 +0400
@@ -0,0 +1,14 @@
+/* dirutil.h ... directory utilities.
+ *               C. Scott Ananian <cananian@alumni.princeton.edu>
+ *
+ * $Id: dirutil.h,v 1.1.1.1 2000/12/23 08:19:51 scott Exp $
+ */
+
+/* Returned malloc'ed string representing basename */
+char *basenamex(char *pathname);
+/* Return malloc'ed string representing directory name (no trailing slash) */
+char *dirnamex(char *pathname);
+/* In-place modify a string to remove trailing slashes.  Returns arg. */
+char *stripslash(char *pathname);
+/* ensure dirname exists, creating it if necessary. */
+int make_valid_path(char *dirname, mode_t mode);
diff -uprN ppp-2.4.3.old/pppd/plugins/pptp/Makefile.linux ppp-2.4.3/pppd/plugins/pptp/Makefile.linux
--- ppp-2.4.3.old/pppd/plugins/pptp/Makefile.linux	1970-01-01 03:00:00.000000000 +0300
+++ ppp-2.4.3/pppd/plugins/pptp/Makefile.linux	2008-09-20 23:04:38.000000000 +0400
@@ -0,0 +1,42 @@
+#-------------------------------------------------------------------------------------
+#-------------------------------------------------------------------------------------
+
+CC      = $(CROSS_COMPILE_PREFIX)gcc
+
+INSTALL	= install
+
+COPTS=-O2
+CFLAGS=$(COPTS) -I../../../include -I../.. -I.
+LDFLAGS	= -shared
+
+CFLAGS+=-DMPPE -DUSE_CRYPT
+
+all: pptp.so
+
+PPPDVERSION = $(shell awk -F '"' '/VERSION/ { print $$2; }' ../../patchlevel.h)
+LIBDIR = $(DESTDIR)/lib/pppd/$(PPPDVERSION)
+
+PLUGINSRCS= pptp.c
+
+#
+# include dependancies if present and backup if as a header file
+ifeq (.depend,$(wildcard .depend))
+include .depend
+endif
+
+pptp.so: pptp.o dirutil.o orckit_quirks.o pptp_callmgr.o pptp_ctrl.o pptp_quirks.o util.o vector.o
+	$(CC) -o $@ $(LDFLAGS) $^
+	cp pptp.so libpptp.so
+
+%.so: %.c
+	$(CC) -o $@ $(LDFLAGS) $(CFLAGS) $^
+
+clean: 
+	rm -f *.o *.so
+
+install: all
+	$(INSTALL) -d -m 755 $(LIBDIR)
+	$(INSTALL) -c -m 4550 pptp.so $(LIBDIR)
+
+depend:
+	$(CPP) -M $(CFLAGS) $(PLUGINSRCS) >.depend
diff -uprN ppp-2.4.3.old/pppd/plugins/pptp/orckit_quirks.c ppp-2.4.3/pppd/plugins/pptp/orckit_quirks.c
--- ppp-2.4.3.old/pppd/plugins/pptp/orckit_quirks.c	1970-01-01 03:00:00.000000000 +0300
+++ ppp-2.4.3/pppd/plugins/pptp/orckit_quirks.c	2008-09-20 22:27:45.000000000 +0400
@@ -0,0 +1,86 @@
+/* orckit_quirks.c ...... fix quirks in orckit adsl modems
+ *                        mulix <mulix@actcom.co.il>
+ *
+ * $Id: orckit_quirks.c,v 1.3 2002/03/01 01:23:36 quozl Exp $
+ */
+
+#include <string.h>
+#include <sys/types.h>
+#include <netinet/in.h>
+#include "pptp_msg.h"
+#include "pptp_options.h"
+#include "pptp_ctrl.h"
+#include "util.h"
+
+
+
+/* return 0 on success, non zero otherwise */
+int
+orckit_atur3_build_hook(struct pptp_out_call_rqst* packet)
+{
+    unsigned int name_length = 10;
+
+    struct pptp_out_call_rqst fixed_packet = {
+	PPTP_HEADER_CTRL(PPTP_OUT_CALL_RQST),
+	0, /* hton16(call->callid) */
+	0, /* hton16(call->sernum) */
+	hton32(PPTP_BPS_MIN), hton32(PPTP_BPS_MAX),
+	hton32(PPTP_BEARER_DIGITAL), hton32(PPTP_FRAME_ANY),
+	hton16(PPTP_WINDOW), 0, hton16(name_length), 0,
+	{'R','E','L','A','Y','_','P','P','P','1',0}, {0}
+    };
+
+    if (!packet)
+	return -1;
+
+    memcpy(packet, &fixed_packet, sizeof(*packet));
+
+    return 0;
+}
+
+/* return 0 on success, non zero otherwise */
+int
+orckit_atur3_set_link_hook(struct pptp_set_link_info* packet,
+			   int peer_call_id)
+{
+    struct pptp_set_link_info fixed_packet = {
+	PPTP_HEADER_CTRL(PPTP_SET_LINK_INFO),
+	hton16(peer_call_id),
+	0,
+	0xffffffff,
+	0xffffffff};
+
+    if (!packet)
+	return -1;
+
+    memcpy(packet, &fixed_packet, sizeof(*packet));
+    return 0;
+}
+
+/* return 0 on success, non 0 otherwise */
+int
+orckit_atur3_start_ctrl_conn_hook(struct pptp_start_ctrl_conn* packet)
+{
+    struct pptp_start_ctrl_conn fixed_packet = {
+	{0}, /* we'll set the header later */
+	hton16(PPTP_VERSION), 0, 0,
+	hton32(PPTP_FRAME_ASYNC), hton32(PPTP_BEARER_ANALOG),
+	hton16(0) /* max channels */,
+	hton16(0x6021),
+	{'R','E','L','A','Y','_','P','P','P','1',0}, /* hostname */
+	{'M','S',' ','W','i','n',' ','N','T',0} /* vendor */
+    };
+
+    if (!packet)
+	return -1;
+
+    /* grab the header from the original packet, since we dont
+       know if this is a request or a reply */
+    memcpy(&fixed_packet.header, &packet->header, sizeof(struct pptp_header));
+
+    /* and now overwrite the full packet, effectively preserving the header */
+    memcpy(packet, &fixed_packet, sizeof(*packet));
+    return 0;
+}
+
+
diff -uprN ppp-2.4.3.old/pppd/plugins/pptp/orckit_quirks.h ppp-2.4.3/pppd/plugins/pptp/orckit_quirks.h
--- ppp-2.4.3.old/pppd/plugins/pptp/orckit_quirks.h	1970-01-01 03:00:00.000000000 +0300
+++ ppp-2.4.3/pppd/plugins/pptp/orckit_quirks.h	2008-09-20 22:27:45.000000000 +0400
@@ -0,0 +1,27 @@
+/* orckit_quirks.h ...... fix quirks in orckit adsl modems
+ *                        mulix <mulix@actcom.co.il>
+ *
+ * $Id: orckit_quirks.h,v 1.2 2001/11/23 03:42:51 quozl Exp $
+ */
+
+#ifndef INC_ORCKIT_QUIRKS_H_
+#define INC_ORCKIT_QUIRKS_H_
+
+#include "pptp_options.h"
+#include "pptp_ctrl.h"
+#include "pptp_msg.h"
+
+/* return 0 on success, non zero otherwise */
+int
+orckit_atur3_build_hook(struct pptp_out_call_rqst* packt);
+
+/* return 0 on success, non zero otherwise */
+int
+orckit_atur3_set_link_hook(struct pptp_set_link_info* packet,
+			   int peer_call_id);
+
+/* return 0 on success, non zero otherwise */
+int
+orckit_atur3_start_ctrl_conn_hook(struct pptp_start_ctrl_conn* packet);
+
+#endif /* INC_ORCKIT_QUIRKS_H_ */
diff -uprN ppp-2.4.3.old/pppd/plugins/pptp/pptp_callmgr.h ppp-2.4.3/pppd/plugins/pptp/pptp_callmgr.h
--- ppp-2.4.3.old/pppd/plugins/pptp/pptp_callmgr.h	1970-01-01 03:00:00.000000000 +0300
+++ ppp-2.4.3/pppd/plugins/pptp/pptp_callmgr.h	2008-09-20 22:27:45.000000000 +0400
@@ -0,0 +1,13 @@
+/* pptp_callmgr.h ... Call manager for PPTP connections.
+ *                    Handles TCP port 1723 protocol.
+ *                    C. Scott Ananian <cananian@alumni.princeton.edu>
+ *
+ * $Id: pptp_callmgr.h,v 1.3 2003/02/17 00:22:17 quozl Exp $
+ */
+
+#define PPTP_SOCKET_PREFIX "/var/run/pptp/"
+
+int callmgr_main(int argc, char**argv, char**envp);
+void callmgr_name_unixsock(struct sockaddr_un *where,
+			   struct in_addr inetaddr,
+			   struct in_addr localbind);
diff -uprN ppp-2.4.3.old/pppd/plugins/pptp/pptp_ctrl.c ppp-2.4.3/pppd/plugins/pptp/pptp_ctrl.c
--- ppp-2.4.3.old/pppd/plugins/pptp/pptp_ctrl.c	1970-01-01 03:00:00.000000000 +0300
+++ ppp-2.4.3/pppd/plugins/pptp/pptp_ctrl.c	2008-09-20 22:27:45.000000000 +0400
@@ -0,0 +1,1078 @@
+/* pptp_ctrl.c ... handle PPTP control connection.
+ *                 C. Scott Ananian <cananian@alumni.princeton.edu>
+ *
+ * $Id: pptp_ctrl.c,v 1.31 2005/03/31 07:42:39 quozl Exp $
+ */
+
+#include <errno.h>
+#include <sys/time.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <assert.h>
+#include <signal.h>
+#include <string.h>
+#include <ctype.h>
+#include <fcntl.h>
+#include "pptp_msg.h"
+#include "pptp_ctrl.h"
+#include "pptp_options.h"
+#include "vector.h"
+#include "util.h"
+#include "pptp_quirks.h"
+
+/* BECAUSE OF SIGNAL LIMITATIONS, EACH PROCESS CAN ONLY MANAGE ONE
+ * CONNECTION.  SO THIS 'PPTP_CONN' STRUCTURE IS A BIT MISLEADING.
+ * WE'LL KEEP CONNECTION-SPECIFIC INFORMATION IN THERE ANYWAY (AS
+ * OPPOSED TO USING GLOBAL VARIABLES), BUT BEWARE THAT THE ENTIRE
+ * UNIX SIGNAL-HANDLING SEMANTICS WOULD HAVE TO CHANGE (OR THE
+ * TIME-OUT CODE DRASTICALLY REWRITTEN) BEFORE YOU COULD DO A
+ * PPTP_CONN_OPEN MORE THAN ONCE PER PROCESS AND GET AWAY WITH IT.
+ */
+
+/* This structure contains connection-specific information that the
+ * signal handler needs to see.  Thus, it needs to be in a global
+ * variable.  If you end up using pthreads or something (why not
+ * just processes?), this would have to be placed in a thread-specific
+ * data area, using pthread_get|set_specific, etc., so I've
+ * conveniently encapsulated it for you.
+ * [linux threads will have to support thread-specific signals
+ *  before this would work at all, which, as of this writing
+ *  (linux-threads v0.6, linux kernel 2.1.72), it does not.]
+ */
+
+/* Globals */
+
+/* control the number of times echo packets will be logged */
+static int nlogecho = 10;
+
+static struct thread_specific {
+    struct sigaction old_sigaction; /* evil signals */
+    PPTP_CONN * conn;
+} global;
+
+#define INITIAL_BUFSIZE 512 /* initial i/o buffer size. */
+
+struct PPTP_CONN {
+    int inet_sock;
+    /* Connection States */
+    enum {
+        CONN_IDLE, CONN_WAIT_CTL_REPLY, CONN_WAIT_STOP_REPLY, CONN_ESTABLISHED
+    } conn_state; /* on startup: CONN_IDLE */
+    /* Keep-alive states */
+    enum {
+        KA_NONE, KA_OUTSTANDING
+    } ka_state;  /* on startup: KA_NONE */
+    /* Keep-alive ID; monotonically increasing (watch wrap-around!) */
+    u_int32_t ka_id; /* on startup: 1 */
+    /* Other properties. */
+    u_int16_t version;
+    u_int16_t firmware_rev;
+    u_int8_t  hostname[64], vendor[64];
+    /* XXX these are only PNS properties, currently XXX */
+    /* Call assignment information. */
+    u_int16_t call_serial_number;
+    VECTOR *call;
+    void * closure;
+    pptp_conn_cb callback;
+    /******* IO buffers ******/
+    char * read_buffer, *write_buffer;
+    size_t read_alloc,   write_alloc;
+    size_t read_size,    write_size;
+};
+
+struct PPTP_CALL {
+    /* Call properties */
+    enum {
+        PPTP_CALL_PAC, PPTP_CALL_PNS
+    } call_type;
+    union {
+        enum pptp_pac_state {
+            PAC_IDLE, PAC_WAIT_REPLY, PAC_ESTABLISHED, PAC_WAIT_CS_ANS
+        } pac;
+        enum pptp_pns_state {
+            PNS_IDLE, PNS_WAIT_REPLY, PNS_ESTABLISHED, PNS_WAIT_DISCONNECT
+        } pns;
+    } state;
+    u_int16_t call_id, peer_call_id;
+    u_int16_t sernum;
+    u_int32_t speed;
+    /* For user data: */
+    pptp_call_cb callback;
+    void * closure;
+};
+
+
+/* PPTP error codes: ----------------------------------------------*/
+
+/* (General Error Codes) */
+static const struct {
+    const char *name, *desc;
+} pptp_general_errors[] = {
+#define PPTP_GENERAL_ERROR_NONE                 0
+    { "(None)", "No general error" },
+#define PPTP_GENERAL_ERROR_NOT_CONNECTED        1
+    { "(Not-Connected)", "No control connection exists yet for this "
+        "PAC-PNS pair" },
+#define PPTP_GENERAL_ERROR_BAD_FORMAT           2
+    { "(Bad-Format)", "Length is wrong or Magic Cookie value is incorrect" },
+#define PPTP_GENERAL_ERROR_BAD_VALUE            3
+    { "(Bad-Value)", "One of the field values was out of range or "
+            "reserved field was non-zero" },
+#define PPTP_GENERAL_ERROR_NO_RESOURCE          4
+    { "(No-Resource)", "Insufficient resources to handle this command now" },
+#define PPTP_GENERAL_ERROR_BAD_CALLID           5
+    { "(Bad-Call ID)", "The Call ID is invalid in this context" },
+#define PPTP_GENERAL_ERROR_PAC_ERROR            6
+    { "(PAC-Error)", "A generic vendor-specific error occured in the PAC" }
+};
+
+#define  MAX_GENERAL_ERROR ( sizeof(pptp_general_errors) / \
+        sizeof(pptp_general_errors[0]) - 1)
+
+/* Outgoing Call Reply Result Codes */
+static const char *pptp_out_call_reply_result[] = {
+/* 0 */	"Unknown Result Code",
+/* 1 */	"Connected",
+/* 2 */	"General Error",
+/* 3 */	"No Carrier Detected",
+/* 4 */	"Busy Signal",
+/* 5 */	"No Dial Tone",
+/* 6 */	"Time Out",
+/* 7 */	"Not Accepted, Call is administratively prohibited" };
+
+#define MAX_OUT_CALL_REPLY_RESULT 7
+
+/* Call Disconnect Notify  Result Codes */
+static const char *pptp_call_disc_ntfy[] = {
+/* 0 */	"Unknown Result Code",
+/* 1 */	"Lost Carrier",
+/* 2 */	"General Error",
+/* 3 */	"Administrative Shutdown",
+/* 4 */	"(your) Request" };
+
+#define MAX_CALL_DISC_NTFY 4
+
+/* Call Disconnect Notify  Result Codes */
+static const char *pptp_start_ctrl_conn_rply[] = {
+/* 0 */	"Unknown Result Code",
+/* 1 */	"Successful Channel Establishment",
+/* 2 */	"General Error",
+/* 3 */	"Command Channel Already Exists",
+/* 4 */	"Requester is not Authorized" };
+
+#define MAX_START_CTRL_CONN_REPLY 4
+
+/* timing options */
+int idle_wait = PPTP_TIMEOUT;
+int max_echo_wait = PPTP_TIMEOUT;
+
+/* Local prototypes */
+static void pptp_reset_timer(void);
+static void pptp_handle_timer();
+/* Write/read as much as we can without blocking. */
+int pptp_write_some(PPTP_CONN * conn);
+int pptp_read_some(PPTP_CONN * conn);
+/* Make valid packets from read_buffer */
+int pptp_make_packet(PPTP_CONN * conn, void **buf, size_t *size);
+/* Add packet to write_buffer */
+int pptp_send_ctrl_packet(PPTP_CONN * conn, void * buffer, size_t size);
+/* Dispatch packets (general) */
+int pptp_dispatch_packet(PPTP_CONN * conn, void * buffer, size_t size);
+/* Dispatch packets (control messages) */
+int ctrlp_disp(PPTP_CONN * conn, void * buffer, size_t size);
+/* Set link info, for pptp servers that need it.
+   this is a noop, unless the user specified a quirk and
+   there's a set_link hook defined in the quirks table
+   for that quirk */
+void pptp_set_link(PPTP_CONN * conn, int peer_call_id);
+
+/*** log error information in control packets *********************************/
+static void ctrlp_error( int result, int error, int cause,
+        const char *result_text[], int max_result)
+{
+    if( cause >= 0)
+        log("Result code is %d '%s'. Error code is %d, Cause code is %d",
+                result, result_text[result <= max_result ?  result : 0], error,
+                cause );
+    else
+        log("Reply result code is %d '%s'. Error code is %d",
+                result, result_text[result <= max_result ?  result : 0], error);
+    if ((error > 0) && (error <= MAX_GENERAL_ERROR)){
+        if( result != PPTP_RESULT_GENERAL_ERROR )
+            log("Result code is something else then \"general error\", "
+                    "so the following error is probably bogus.");
+        log("Error is '%s', Error message: '%s'",
+                pptp_general_errors[error].name,
+                pptp_general_errors[error].desc);
+    }
+}
+
+static const char *ctrl_msg_types[] = {
+         "invalid control message type",
+/*         (Control Connection Management) */
+         "Start-Control-Connection-Request",            /* 1 */
+         "Start-Control-Connection-Reply",              /* 2 */
+         "Stop-Control-Connection-Request",             /* 3 */
+         "Stop-Control-Connection-Reply",               /* 4 */
+         "Echo-Request",                                /* 5 */
+         "Echo-Reply",                                  /* 6 */
+/*         (Call Management) */
+         "Outgoing-Call-Request",                       /* 7 */
+         "Outgoing-Call-Reply",                         /* 8 */
+         "Incoming-Call-Request",                       /* 9 */
+         "Incoming-Call-Reply",                        /* 10 */
+         "Incoming-Call-Connected",                    /* 11 */
+         "Call-Clear-Request",                         /* 12 */
+         "Call-Disconnect-Notify",                     /* 13 */
+/*         (Error Reporting) */
+         "WAN-Error-Notify",                           /* 14 */
+/*         (PPP Session Control) */
+         "Set-Link-Info"                              /* 15 */
+};
+#define MAX_CTRLMSG_TYPE 15
+
+/*** report a sent packet ****************************************************/
+static void ctrlp_rep( void * buffer, int size, int isbuff)
+{
+    struct pptp_header *packet = buffer;
+    unsigned int type;
+    if(size < sizeof(struct pptp_header)) return;
+    type = ntoh16(packet->ctrl_type);
+    /* FIXME: do not report sending echo requests as long as they are
+     * sent in a signal handler. This may dead lock as the syslog call
+     * is not reentrant */
+    if( type ==  PPTP_ECHO_RQST ) return;
+    /* don't keep reporting sending of echo's */
+    if( (type == PPTP_ECHO_RQST || type == PPTP_ECHO_RPLY) && nlogecho <= 0 ) return;
+    log("%s control packet type is %d '%s'\n",isbuff ? "Buffered" : "Sent",
+            type, ctrl_msg_types[type <= MAX_CTRLMSG_TYPE ? type : 0]);
+
+}
+
+
+
+/* Open new pptp_connection.  Returns NULL on failure. */
+PPTP_CONN * pptp_conn_open(int inet_sock, int isclient, pptp_conn_cb callback)
+{
+    PPTP_CONN *conn;
+    /* Allocate structure */
+    if ((conn = malloc(sizeof(*conn))) == NULL) return NULL;
+    if ((conn->call = vector_create()) == NULL) { free(conn); return NULL; }
+    /* Initialize */
+    conn->inet_sock = inet_sock;
+    conn->conn_state = CONN_IDLE;
+    conn->ka_state  = KA_NONE;
+    conn->ka_id     = 1;
+    conn->call_serial_number = 0;
+    conn->callback  = callback;
+    /* Create I/O buffers */
+    conn->read_size = conn->write_size = 0;
+    conn->read_alloc = conn->write_alloc = INITIAL_BUFSIZE;
+    conn->read_buffer =
+        malloc(sizeof(*(conn->read_buffer)) * conn->read_alloc);
+    conn->write_buffer =
+        malloc(sizeof(*(conn->write_buffer)) * conn->write_alloc);
+    if (conn->read_buffer == NULL || conn->write_buffer == NULL) {
+        if (conn->read_buffer  != NULL) free(conn->read_buffer);
+        if (conn->write_buffer != NULL) free(conn->write_buffer);
+        vector_destroy(conn->call); free(conn); return NULL;
+    }
+    /* Make this socket non-blocking. */
+    fcntl(conn->inet_sock, F_SETFL, O_NONBLOCK);
+    /* Request connection from server, if this is a client */
+    if (isclient) {
+        struct pptp_start_ctrl_conn packet = {
+            PPTP_HEADER_CTRL(PPTP_START_CTRL_CONN_RQST),
+            hton16(PPTP_VERSION), 0, 0,
+            hton32(PPTP_FRAME_CAP), hton32(PPTP_BEARER_CAP),
+            hton16(PPTP_MAX_CHANNELS), hton16(PPTP_FIRMWARE_VERSION),
+            PPTP_HOSTNAME, PPTP_VENDOR
+        };
+        /* fix this packet, if necessary */
+        int idx, rc;
+        idx = get_quirk_index();
+        if (idx != -1 && pptp_fixups[idx].start_ctrl_conn) {
+            if ((rc = pptp_fixups[idx].start_ctrl_conn(&packet)))
+                warn("calling the start_ctrl_conn hook failed (%d)", rc);
+        }
+        if (pptp_send_ctrl_packet(conn, &packet, sizeof(packet)))
+            conn->conn_state = CONN_WAIT_CTL_REPLY;
+        else
+            return NULL; /* could not send initial start request. */
+    }
+    /* Set up interval/keep-alive timer */
+    /*   First, register handler for SIGALRM */
+    sigpipe_create();
+    sigpipe_assign(SIGALRM);
+    global.conn = conn;
+    /* Reset event timer */
+    pptp_reset_timer();
+    /* all done. */
+    return conn;
+}
+
+int pptp_conn_established(PPTP_CONN *conn) {
+  return (conn->conn_state == CONN_ESTABLISHED);
+}
+
+/* This currently *only* works for client call requests.
+ * We need to do something else to allocate calls for incoming requests.
+ */
+PPTP_CALL * pptp_call_open(PPTP_CONN * conn, int call_id,pptp_call_cb callback,
+        char *phonenr,int window)
+{
+    PPTP_CALL * call;
+    int idx, rc;
+    /* Send off the call request */
+    struct pptp_out_call_rqst packet = {
+        PPTP_HEADER_CTRL(PPTP_OUT_CALL_RQST),
+        0,0, /*call_id, sernum */
+        hton32(PPTP_BPS_MIN), hton32(PPTP_BPS_MAX),
+        hton32(PPTP_BEARER_CAP), hton32(PPTP_FRAME_CAP),
+        hton16(window), 0, 0, 0, {0}, {0}
+    };
+    assert(conn && conn->call);
+    assert(conn->conn_state == CONN_ESTABLISHED);
+    /* Assign call id */
+    if (!call_id && !vector_scan(conn->call, 0, PPTP_MAX_CHANNELS - 1, &call_id))
+        /* no more calls available! */
+        return NULL;
+    /* allocate structure. */
+    if ((call = malloc(sizeof(*call))) == NULL) return NULL;
+    /* Initialize call structure */
+    call->call_type = PPTP_CALL_PNS;
+    call->state.pns = PNS_IDLE;
+    call->call_id   = (u_int16_t) call_id;
+    call->sernum    = conn->call_serial_number++;
+    call->callback  = callback;
+    call->closure   = NULL;
+    packet.call_id = htons(call->call_id);
+    packet.call_sernum = htons(call->sernum);
+    /* if we have a quirk, build a new packet to fit it */
+    idx = get_quirk_index();
+    if (idx != -1 && pptp_fixups[idx].out_call_rqst_hook) {
+        if ((rc = pptp_fixups[idx].out_call_rqst_hook(&packet)))
+            warn("calling the out_call_rqst hook failed (%d)", rc);
+    }
+    /* fill in the phone number if it was specified */
+    if (phonenr) {
+        strncpy(packet.phone_num, phonenr, sizeof(packet.phone_num));
+        packet.phone_len = strlen(phonenr);
+        if( packet.phone_len > sizeof(packet.phone_num))
+            packet.phone_len = sizeof(packet.phone_num);
+        packet.phone_len = hton16 (packet.phone_len);
+    }
+    if (pptp_send_ctrl_packet(conn, &packet, sizeof(packet))) {
+        pptp_reset_timer();
+        call->state.pns = PNS_WAIT_REPLY;
+        /* and add it to the call vector */
+        vector_insert(conn->call, call_id, call);
+        return call;
+    } else { /* oops, unsuccessful. Deallocate. */
+        free(call);
+        return NULL;
+    }
+}
+
+/*** pptp_call_close **********************************************************/
+void pptp_call_close(PPTP_CONN * conn, PPTP_CALL * call)
+{
+    struct pptp_call_clear_rqst rqst = {
+        PPTP_HEADER_CTRL(PPTP_CALL_CLEAR_RQST), 0, 0
+    };
+    assert(conn && conn->call); assert(call);
+    assert(vector_contains(conn->call, call->call_id));
+    /* haven't thought about PAC yet */
+    assert(call->call_type == PPTP_CALL_PNS);
+    assert(call->state.pns != PNS_IDLE);
+    rqst.call_id = hton16(call->call_id);
+    /* don't check state against WAIT_DISCONNECT... allow multiple disconnect
+     * requests to be made.
+     */
+    pptp_send_ctrl_packet(conn, &rqst, sizeof(rqst));
+    pptp_reset_timer();
+    call->state.pns = PNS_WAIT_DISCONNECT;
+    /* call structure will be freed when we have confirmation of disconnect. */
+}
+
+/*** hard close ***************************************************************/
+void pptp_call_destroy(PPTP_CONN *conn, PPTP_CALL *call)
+{
+    assert(conn && conn->call); assert(call);
+    assert(vector_contains(conn->call, call->call_id));
+    /* notify */
+    if (call->callback != NULL) call->callback(conn, call, CALL_CLOSE_DONE);
+    /* deallocate */
+    vector_remove(conn->call, call->call_id);
+    free(call);
+}
+
+/*** this is a soft close *****************************************************/
+void pptp_conn_close(PPTP_CONN * conn, u_int8_t close_reason)
+{
+    struct pptp_stop_ctrl_conn rqst = {
+        PPTP_HEADER_CTRL(PPTP_STOP_CTRL_CONN_RQST),
+        hton8(close_reason), 0, 0
+    };
+    int i;
+    assert(conn && conn->call);
+    /* avoid repeated close attempts */
+    if (conn->conn_state == CONN_IDLE || conn->conn_state == CONN_WAIT_STOP_REPLY)
+        return;
+    /* close open calls, if any */
+    for (i = 0; i < vector_size(conn->call); i++)
+        pptp_call_close(conn, vector_get_Nth(conn->call, i));
+    /* now close connection */
+    log("Closing PPTP connection");
+    pptp_send_ctrl_packet(conn, &rqst, sizeof(rqst));
+    pptp_reset_timer(); /* wait 60 seconds for reply */
+    conn->conn_state = CONN_WAIT_STOP_REPLY;
+    return;
+}
+
+/*** this is a hard close *****************************************************/
+void pptp_conn_destroy(PPTP_CONN * conn)
+{
+    int i;
+    assert(conn != NULL); assert(conn->call != NULL);
+    /* destroy all open calls */
+    for (i = 0; i < vector_size(conn->call); i++)
+        pptp_call_destroy(conn, vector_get_Nth(conn->call, i));
+    /* notify */
+    if (conn->callback != NULL) conn->callback(conn, CONN_CLOSE_DONE);
+    sigpipe_close();
+    close(conn->inet_sock);
+    /* deallocate */
+    vector_destroy(conn->call);
+    free(conn);
+}
+
+/*** Deal with messages, in a non-blocking manner
+ * Add file descriptors used by pptp to fd_set.
+ */
+void pptp_fd_set(PPTP_CONN * conn, fd_set * read_set, fd_set * write_set,
+                 int * max_fd)
+{
+	int sig_fd;
+    assert(conn && conn->call);
+    /* Add fd to write_set if there are outstanding writes. */
+    if (conn->write_size > 0)
+        FD_SET(conn->inet_sock, write_set);
+    /* Always add fd to read_set. (always want something to read) */
+    FD_SET(conn->inet_sock, read_set);
+    if (*max_fd < conn->inet_sock) *max_fd = conn->inet_sock;
+    /* Add signal pipe file descriptor to set */
+    sig_fd = sigpipe_fd();
+    FD_SET(sig_fd, read_set);
+    if (*max_fd < sig_fd) *max_fd = sig_fd;
+}
+
+/*** handle any pptp file descriptors set in fd_set, and clear them ***********/
+int pptp_dispatch(PPTP_CONN * conn, fd_set * read_set, fd_set * write_set)
+{
+    int r = 0;
+    assert(conn && conn->call);
+    /* Check for signals */
+    if (FD_ISSET(sigpipe_fd(), read_set)) {
+        if (sigpipe_read() == SIGALRM) pptp_handle_timer();
+	FD_CLR(sigpipe_fd(), read_set);
+    }
+    /* Check write_set could be set. */
+    if (FD_ISSET(conn->inet_sock, write_set)) {
+        FD_CLR(conn->inet_sock, write_set);
+        if (conn->write_size > 0)
+            r = pptp_write_some(conn);/* write as much as we can without blocking */
+    }
+    /* Check read_set */
+    if (r >= 0 && FD_ISSET(conn->inet_sock, read_set)) {
+        void *buffer; size_t size;
+        FD_CLR(conn->inet_sock, read_set);
+        r = pptp_read_some(conn); /* read as much as we can without blocking */
+	if (r < 0)
+	    return r;
+        /* make packets of the buffer, while we can. */
+        while (r >= 0 && pptp_make_packet(conn, &buffer, &size)) {
+            r = pptp_dispatch_packet(conn, buffer, size);
+            free(buffer);
+        }
+    }
+    /* That's all, folks.  Simple, eh? */
+    return r;
+}
+
+/*** Non-blocking write *******************************************************/
+int pptp_write_some(PPTP_CONN * conn) {
+    ssize_t retval;
+    assert(conn && conn->call);
+    retval = write(conn->inet_sock, conn->write_buffer, conn->write_size);
+    if (retval < 0) { /* error. */
+        if (errno == EAGAIN || errno == EINTR) {
+            return 0;
+        } else { /* a real error */
+            log("write error: %s", strerror(errno));
+	    return -1;
+        }
+    }
+    assert(retval <= conn->write_size);
+    conn->write_size -= retval;
+    memmove(conn->write_buffer, conn->write_buffer + retval, conn->write_size);
+    ctrlp_rep(conn->write_buffer, retval, 0);
+    return 0;
+}
+
+/*** Non-blocking read ********************************************************/
+int pptp_read_some(PPTP_CONN * conn)
+{
+    ssize_t retval;
+    assert(conn && conn->call);
+    if (conn->read_size == conn->read_alloc) { /* need to alloc more memory */
+        char *new_buffer = realloc(conn->read_buffer,
+                sizeof(*(conn->read_buffer)) * conn->read_alloc * 2);
+        if (new_buffer == NULL) {
+            log("Out of memory"); return -1;
+        }
+        conn->read_alloc *= 2;
+        conn->read_buffer = new_buffer;
+    }
+    retval = read(conn->inet_sock, conn->read_buffer + conn->read_size,
+            conn->read_alloc  - conn->read_size);
+    if (retval == 0) {
+        log("read returned zero, peer has closed");
+        return -1;
+    }
+    if (retval < 0) {
+        if (errno == EINTR || errno == EAGAIN)
+	    return 0;
+        else { /* a real error */
+            log("read error: %s", strerror(errno));
+            return -1;
+        }
+    }
+    conn->read_size += retval;
+    assert(conn->read_size <= conn->read_alloc);
+    return 0;
+}
+
+/*** Packet formation *********************************************************/
+int pptp_make_packet(PPTP_CONN * conn, void **buf, size_t *size)
+{
+    struct pptp_header *header;
+    size_t bad_bytes = 0;
+    assert(conn && conn->call); assert(buf != NULL); assert(size != NULL);
+    /* Give up unless there are at least sizeof(pptp_header) bytes */
+    while ((conn->read_size-bad_bytes) >= sizeof(struct pptp_header)) {
+        /* Throw out bytes until we have a valid header. */
+        header = (struct pptp_header *) (conn->read_buffer + bad_bytes);
+        if (ntoh32(header->magic) != PPTP_MAGIC) goto throwitout;
+        if (ntoh16(header->reserved0) != 0)
+            log("reserved0 field is not zero! (0x%x) Cisco feature? \n",
+                    ntoh16(header->reserved0));
+        if (ntoh16(header->length) < sizeof(struct pptp_header)) goto throwitout;
+        if (ntoh16(header->length) > PPTP_CTRL_SIZE_MAX) goto throwitout;
+        /* well.  I guess it's good. Let's see if we've got it all. */
+        if (ntoh16(header->length) > (conn->read_size-bad_bytes))
+            /* nope.  Let's wait until we've got it, then. */
+            goto flushbadbytes;
+        /* One last check: */
+        if ((ntoh16(header->pptp_type) == PPTP_MESSAGE_CONTROL) &&
+                (ntoh16(header->length) !=
+                         PPTP_CTRL_SIZE(ntoh16(header->ctrl_type))))
+            goto throwitout;
+        /* well, I guess we've got it. */
+        *size = ntoh16(header->length);
+        *buf = malloc(*size);
+        if (*buf == NULL) { log("Out of memory."); return 0; /* ack! */ }
+        memcpy(*buf, conn->read_buffer + bad_bytes, *size);
+        /* Delete this packet from the read_buffer. */
+        conn->read_size -= (bad_bytes + *size);
+        memmove(conn->read_buffer, conn->read_buffer + bad_bytes + *size,
+                conn->read_size);
+        if (bad_bytes > 0)
+            log("%lu bad bytes thrown away.", (unsigned long) bad_bytes);
+        return 1;
+throwitout:
+        bad_bytes++;
+    }
+flushbadbytes:
+    /* no more packets.  Let's get rid of those bad bytes */
+    conn->read_size -= bad_bytes;
+    memmove(conn->read_buffer, conn->read_buffer + bad_bytes, conn->read_size);
+    if (bad_bytes > 0)
+        log("%lu bad bytes thrown away.", (unsigned long) bad_bytes);
+    return 0;
+}
+
+/*** pptp_send_ctrl_packet ****************************************************/
+int pptp_send_ctrl_packet(PPTP_CONN * conn, void * buffer, size_t size)
+{
+    assert(conn && conn->call); assert(buffer);
+    if( conn->write_size > 0) pptp_write_some( conn);
+    if( conn->write_size == 0) {
+        ssize_t retval;
+        retval = write(conn->inet_sock, buffer, size);
+        if (retval < 0) { /* error. */
+            if (errno == EAGAIN || errno == EINTR) {
+                /* ignore */;
+                retval = 0;
+            } else { /* a real error */
+                log("write error: %s", strerror(errno));
+                pptp_conn_destroy(conn); /* shut down fast. */
+                return 0;
+            }
+        }
+        ctrlp_rep( buffer, retval, 0);
+        size -= retval;
+        if( size <= 0) return 1;
+    }
+    /* Shove anything not written into the write buffer */
+    if (conn->write_size + size > conn->write_alloc) { /* need more memory */
+        char *new_buffer = realloc(conn->write_buffer,
+                sizeof(*(conn->write_buffer)) * conn->write_alloc * 2);
+        if (new_buffer == NULL) {
+            log("Out of memory"); return 0;
+        }
+        conn->write_alloc *= 2;
+        conn->write_buffer = new_buffer;
+    }
+    memcpy(conn->write_buffer + conn->write_size, buffer, size);
+    conn->write_size += size;
+    ctrlp_rep( buffer,size,1);
+    return 1;
+}
+
+/*** Packet Dispatch **********************************************************/
+int pptp_dispatch_packet(PPTP_CONN * conn, void * buffer, size_t size)
+{
+    int r = 0;
+    struct pptp_header *header = (struct pptp_header *)buffer;
+    assert(conn && conn->call); assert(buffer);
+    assert(ntoh32(header->magic) == PPTP_MAGIC);
+    assert(ntoh16(header->length) == size);
+    switch (ntoh16(header->pptp_type)) {
+        case PPTP_MESSAGE_CONTROL:
+            r = ctrlp_disp(conn, buffer, size);
+            break;
+        case PPTP_MESSAGE_MANAGE:
+            /* MANAGEMENT messages aren't even part of the spec right now. */
+            log("PPTP management message received, but not understood.");
+            break;
+        default:
+            log("Unknown PPTP control message type received: %u",
+                    (unsigned int) ntoh16(header->pptp_type));
+            break;
+    }
+    return r;
+}
+
+/*** log echo request/replies *************************************************/
+static void logecho( int type)
+{
+    /* hack to stop flooding the log files (the most interesting part is right
+     * after the connection built-up) */
+    if( nlogecho > 0) {
+        log( "Echo Re%s received.", type == PPTP_ECHO_RQST ? "quest" :"ply");
+        if( --nlogecho == 0)
+            log("no more Echo Reply/Request packets will be reported.");
+    }
+}
+
+/*** pptp_dispatch_ctrl_packet ************************************************/
+int ctrlp_disp(PPTP_CONN * conn, void * buffer, size_t size)
+{
+    struct pptp_header *header = (struct pptp_header *)buffer;
+    u_int8_t close_reason = PPTP_STOP_NONE;
+    assert(conn && conn->call); assert(buffer);
+    assert(ntoh32(header->magic) == PPTP_MAGIC);
+    assert(ntoh16(header->length) == size);
+    assert(ntoh16(header->pptp_type) == PPTP_MESSAGE_CONTROL);
+    if (size < PPTP_CTRL_SIZE(ntoh16(header->ctrl_type))) {
+        log("Invalid packet received [type: %d; length: %d].",
+                (int) ntoh16(header->ctrl_type), (int) size);
+        return 0;
+    }
+    switch (ntoh16(header->ctrl_type)) {
+        /* ----------- STANDARD Start-Session MESSAGES ------------ */
+        case PPTP_START_CTRL_CONN_RQST:
+        {
+            struct pptp_start_ctrl_conn *packet =
+                (struct pptp_start_ctrl_conn *) buffer;
+            struct pptp_start_ctrl_conn reply = {
+                PPTP_HEADER_CTRL(PPTP_START_CTRL_CONN_RPLY),
+                hton16(PPTP_VERSION), 0, 0,
+                hton32(PPTP_FRAME_CAP), hton32(PPTP_BEARER_CAP),
+                hton16(PPTP_MAX_CHANNELS), hton16(PPTP_FIRMWARE_VERSION),
+                PPTP_HOSTNAME, PPTP_VENDOR };
+            int idx, rc;
+            log("Received Start Control Connection Request");
+            /* fix this packet, if necessary */
+            idx = get_quirk_index();
+            if (idx != -1 && pptp_fixups[idx].start_ctrl_conn) {
+                if ((rc = pptp_fixups[idx].start_ctrl_conn(&reply)))
+                    warn("calling the start_ctrl_conn hook failed (%d)", rc);
+            }
+            if (conn->conn_state == CONN_IDLE) {
+                if (ntoh16(packet->version) < PPTP_VERSION) {
+                    /* Can't support this (earlier) PPTP_VERSION */
+                    reply.version = packet->version;
+                    /* protocol version not supported */
+                    reply.result_code = hton8(5);
+                    pptp_send_ctrl_packet(conn, &reply, sizeof(reply));
+                    pptp_reset_timer(); /* give sender a chance for a retry */
+                } else { /* same or greater version */
+                    if (pptp_send_ctrl_packet(conn, &reply, sizeof(reply))) {
+                        conn->conn_state = CONN_ESTABLISHED;
+                        log("server connection ESTABLISHED.");
+                        pptp_reset_timer();
+                    }
+                }
+            }
+            break;
+        }
+        case PPTP_START_CTRL_CONN_RPLY:
+        {
+            struct pptp_start_ctrl_conn *packet =
+                (struct pptp_start_ctrl_conn *) buffer;
+            log("Received Start Control Connection Reply");
+            if (conn->conn_state == CONN_WAIT_CTL_REPLY) {
+                /* XXX handle collision XXX [see rfc] */
+                if (ntoh16(packet->version) != PPTP_VERSION) {
+                    if (conn->callback != NULL)
+                        conn->callback(conn, CONN_OPEN_FAIL);
+                    close_reason = PPTP_STOP_PROTOCOL;
+                    goto pptp_conn_close;
+                }
+                if (ntoh8(packet->result_code) != 1 &&
+                    /* J'ai change le if () afin que la connection ne se ferme
+                     * pas pour un "rien" :p adel@cybercable.fr -
+                     *
+                     * Don't close the connection if the result code is zero
+                     * (feature found in certain ADSL modems)
+                     */
+                        ntoh8(packet->result_code) != 0) {
+                    log("Negative reply received to our Start Control "
+                            "Connection Request");
+                    ctrlp_error(packet->result_code, packet->error_code,
+                            -1, pptp_start_ctrl_conn_rply,
+                            MAX_START_CTRL_CONN_REPLY);
+                    if (conn->callback != NULL)
+                        conn->callback(conn, CONN_OPEN_FAIL);
+                    close_reason = PPTP_STOP_PROTOCOL;
+                    goto pptp_conn_close;
+                }
+                conn->conn_state = CONN_ESTABLISHED;
+                /* log session properties */
+                conn->version      = ntoh16(packet->version);
+                conn->firmware_rev = ntoh16(packet->firmware_rev);
+                memcpy(conn->hostname, packet->hostname, sizeof(conn->hostname));
+                memcpy(conn->vendor, packet->vendor, sizeof(conn->vendor));
+                pptp_reset_timer(); /* 60 seconds until keep-alive */
+                log("Client connection established.");
+                if (conn->callback != NULL)
+                    conn->callback(conn, CONN_OPEN_DONE);
+            } /* else goto pptp_conn_close; */
+            break;
+        }
+            /* ----------- STANDARD Stop-Session MESSAGES ------------ */
+        case PPTP_STOP_CTRL_CONN_RQST:
+        {
+            /* conn_state should be CONN_ESTABLISHED, but it could be
+             * something else */
+            struct pptp_stop_ctrl_conn reply = {
+                PPTP_HEADER_CTRL(PPTP_STOP_CTRL_CONN_RPLY),
+                hton8(1), hton8(PPTP_GENERAL_ERROR_NONE), 0
+            };
+            log("Received Stop Control Connection Request.");
+            if (conn->conn_state == CONN_IDLE) break;
+            if (pptp_send_ctrl_packet(conn, &reply, sizeof(reply))) {
+                if (conn->callback != NULL)
+                    conn->callback(conn, CONN_CLOSE_RQST);
+                conn->conn_state = CONN_IDLE;
+		return -1;
+            }
+            break;
+        }
+        case PPTP_STOP_CTRL_CONN_RPLY:
+        {
+            log("Received Stop Control Connection Reply.");
+            /* conn_state should be CONN_WAIT_STOP_REPLY, but it
+             * could be something else */
+            if (conn->conn_state == CONN_IDLE) break;
+            conn->conn_state = CONN_IDLE;
+	    return -1;
+        }
+            /* ----------- STANDARD Echo/Keepalive MESSAGES ------------ */
+        case PPTP_ECHO_RPLY:
+        {
+            struct pptp_echo_rply *packet =
+                (struct pptp_echo_rply *) buffer;
+            logecho( PPTP_ECHO_RPLY);
+            if ((conn->ka_state == KA_OUTSTANDING) &&
+                    (ntoh32(packet->identifier) == conn->ka_id)) {
+                conn->ka_id++;
+                conn->ka_state = KA_NONE;
+                pptp_reset_timer();
+            }
+            break;
+        }
+        case PPTP_ECHO_RQST:
+        {
+            struct pptp_echo_rqst *packet =
+                (struct pptp_echo_rqst *) buffer;
+            struct pptp_echo_rply reply = {
+                PPTP_HEADER_CTRL(PPTP_ECHO_RPLY),
+                packet->identifier, /* skip hton32(ntoh32(id)) */
+                hton8(1), hton8(PPTP_GENERAL_ERROR_NONE), 0
+            };
+            logecho( PPTP_ECHO_RQST);
+            pptp_send_ctrl_packet(conn, &reply, sizeof(reply));
+            pptp_reset_timer();
+            break;
+        }
+            /* ----------- OUTGOING CALL MESSAGES ------------ */
+        case PPTP_OUT_CALL_RQST:
+        {
+            struct pptp_out_call_rqst *packet =
+                (struct pptp_out_call_rqst *)buffer;
+            struct pptp_out_call_rply reply = {
+                PPTP_HEADER_CTRL(PPTP_OUT_CALL_RPLY),
+                0 /* callid */, packet->call_id, 1, PPTP_GENERAL_ERROR_NONE, 0,
+                hton32(PPTP_CONNECT_SPEED),
+                hton16(PPTP_WINDOW), hton16(PPTP_DELAY), 0
+            };
+            log("Received Outgoing Call Request.");
+            /* XXX PAC: eventually this should make an outgoing call. XXX */
+            reply.result_code = hton8(7); /* outgoing calls verboten */
+            pptp_send_ctrl_packet(conn, &reply, sizeof(reply));
+            break;
+        }
+        case PPTP_OUT_CALL_RPLY:
+        {
+            struct pptp_out_call_rply *packet =
+                (struct pptp_out_call_rply *)buffer;
+            PPTP_CALL * call;
+            u_int16_t callid = ntoh16(packet->call_id_peer);
+            log("Received Outgoing Call Reply.");
+            if (!vector_search(conn->call, (int) callid, &call)) {
+                log("PPTP_OUT_CALL_RPLY received for non-existant call: "
+                        "peer call ID (us)  %d call ID (them) %d.",
+                        callid, ntoh16(packet->call_id));
+                break;
+            }
+            if (call->call_type != PPTP_CALL_PNS) {
+                log("Ack!  How did this call_type get here?"); /* XXX? */
+                break;
+            }
+            if (call->state.pns != PNS_WAIT_REPLY) {
+                warn("Unexpected(?) Outgoing Call Reply will be ignored.");
+                break;
+            }
+            /* check for errors */
+            if (packet->result_code != 1) {
+                /* An error.  Log it verbosely. */
+                log("Our outgoing call request [callid %d] has not been "
+                        "accepted.", (int) callid);
+                ctrlp_error(packet->result_code, packet->error_code,
+                        packet->cause_code, pptp_out_call_reply_result,
+                        MAX_OUT_CALL_REPLY_RESULT);
+                call->state.pns = PNS_IDLE;
+                if (call->callback != NULL)
+                    call->callback(conn, call, CALL_OPEN_FAIL);
+                pptp_call_destroy(conn, call);
+            } else {
+                /* connection established */
+                call->state.pns = PNS_ESTABLISHED;
+                call->peer_call_id = ntoh16(packet->call_id);
+                call->speed        = ntoh32(packet->speed);
+                pptp_reset_timer();
+                /* call pptp_set_link. unless the user specified a quirk
+                   and this quirk has a set_link hook, this is a noop */
+                pptp_set_link(conn, call->peer_call_id);
+                if (call->callback != NULL)
+                    call->callback(conn, call, CALL_OPEN_DONE);
+                log("Outgoing call established (call ID %u, peer's "
+                        "call ID %u).\n", call->call_id, call->peer_call_id);
+            }
+            break;
+        }
+            /* ----------- INCOMING CALL MESSAGES ------------ */
+            /* XXX write me XXX */
+            /* ----------- CALL CONTROL MESSAGES ------------ */
+        case PPTP_CALL_CLEAR_RQST:
+        {
+            struct pptp_call_clear_rqst *packet =
+                (struct pptp_call_clear_rqst *)buffer;
+            struct pptp_call_clear_ntfy reply = {
+                PPTP_HEADER_CTRL(PPTP_CALL_CLEAR_NTFY), packet->call_id,
+                1, PPTP_GENERAL_ERROR_NONE, 0, 0, {0}
+            };
+            log("Received Call Clear Request.");
+            if (vector_contains(conn->call, ntoh16(packet->call_id))) {
+                PPTP_CALL * call;
+                vector_search(conn->call, ntoh16(packet->call_id), &call);
+                if (call->callback != NULL)
+                    call->callback(conn, call, CALL_CLOSE_RQST);
+                pptp_send_ctrl_packet(conn, &reply, sizeof(reply));
+                pptp_call_destroy(conn, call);
+                log("Call closed (RQST) (call id %d)", (int) call->call_id);
+            }
+            break;
+        }
+        case PPTP_CALL_CLEAR_NTFY:
+        {
+            struct pptp_call_clear_ntfy *packet =
+                (struct pptp_call_clear_ntfy *)buffer;
+            log("Call disconnect notification received (call id %d)",
+                    ntoh16(packet->call_id));
+            if (vector_contains(conn->call, ntoh16(packet->call_id))) {
+                PPTP_CALL * call;
+                ctrlp_error(packet->result_code, packet->error_code,
+                        packet->cause_code, pptp_call_disc_ntfy,
+                        MAX_CALL_DISC_NTFY);
+                vector_search(conn->call, ntoh16(packet->call_id), &call);
+                pptp_call_destroy(conn, call);
+            }
+            /* XXX we could log call stats here XXX */
+            /* XXX not all servers send this XXX */
+            break;
+        }
+        case PPTP_SET_LINK_INFO:
+        {
+            /* I HAVE NO CLUE WHAT TO DO IF send_accm IS NOT 0! */
+            /* this is really dealt with in the HDLC deencapsulation, anyway. */
+            struct pptp_set_link_info *packet =
+                (struct pptp_set_link_info *)buffer;
+            /* log it. */
+            log("PPTP_SET_LINK_INFO received from peer_callid %u",
+                    (unsigned int) ntoh16(packet->call_id_peer));
+            log("  send_accm is %08lX, recv_accm is %08lX",
+                    (unsigned long) ntoh32(packet->send_accm),
+                    (unsigned long) ntoh32(packet->recv_accm));
+            if (!(ntoh32(packet->send_accm) == 0 &&
+                    ntoh32(packet->recv_accm) == 0))
+                warn("Non-zero Async Control Character Maps are not supported!");
+            break;
+        }
+        default:
+            log("Unrecognized Packet %d received.",
+                    (int) ntoh16(((struct pptp_header *)buffer)->ctrl_type));
+            /* goto pptp_conn_close; */
+            break;
+    }
+    return 0;
+pptp_conn_close:
+    warn("pptp_conn_close(%d)", (int) close_reason);
+    pptp_conn_close(conn, close_reason);
+    return 0;
+}
+
+/*** pptp_set_link **************************************************************/
+void pptp_set_link(PPTP_CONN* conn, int peer_call_id)
+{
+    int idx, rc;
+    /* if we need to send a set_link packet because of buggy
+       hardware or pptp server, do it now */
+    if ((idx = get_quirk_index()) != -1 && pptp_fixups[idx].set_link_hook) {
+        struct pptp_set_link_info packet;
+        if ((rc = pptp_fixups[idx].set_link_hook(&packet, peer_call_id)))
+            warn("calling the set_link hook failed (%d)", rc);
+        if (pptp_send_ctrl_packet(conn, &packet, sizeof(packet))) {
+            pptp_reset_timer();
+        }
+    }
+}
+
+/*** Get info from call structure *********************************************/
+/* NOTE: The peer_call_id is undefined until we get a server response. */
+void pptp_call_get_ids(PPTP_CONN * conn, PPTP_CALL * call,
+		       u_int16_t * call_id, u_int16_t * peer_call_id)
+{
+    assert(conn != NULL); assert(call != NULL);
+    *call_id = call->call_id;
+    *peer_call_id = call->peer_call_id;
+}
+
+/*** pptp_call_closure_put ****************************************************/
+void   pptp_call_closure_put(PPTP_CONN * conn, PPTP_CALL * call, void *cl)
+{
+    assert(conn != NULL); assert(call != NULL);
+    call->closure = cl;
+}
+
+/*** pptp_call_closure_get ****************************************************/
+void * pptp_call_closure_get(PPTP_CONN * conn, PPTP_CALL * call)
+{
+    assert(conn != NULL); assert(call != NULL);
+    return call->closure;
+}
+
+/*** pptp_conn_closure_put ****************************************************/
+void   pptp_conn_closure_put(PPTP_CONN * conn, void *cl)
+{
+    assert(conn != NULL);
+    conn->closure = cl;
+}
+
+/*** pptp_conn_closure_get ****************************************************/
+void * pptp_conn_closure_get(PPTP_CONN * conn)
+{
+    assert(conn != NULL);
+    return conn->closure;
+}
+
+/*** Reset keep-alive timer ***************************************************/
+static void pptp_reset_timer(void)
+{
+    const struct itimerval tv = { {  0, 0 },   /* stop on time-out */
+        { idle_wait, 0 } };
+    if (idle_wait) setitimer(ITIMER_REAL, &tv, NULL);
+}
+
+
+/*** Handle keep-alive timer **************************************************/
+static void pptp_handle_timer()
+{
+    int i;
+    /* "Keep Alives and Timers, 1": check connection state */
+    if (global.conn->conn_state != CONN_ESTABLISHED) {
+        if (global.conn->conn_state == CONN_WAIT_STOP_REPLY)
+            /* hard close. */
+            pptp_conn_destroy(global.conn);
+        else /* soft close */
+            pptp_conn_close(global.conn, PPTP_STOP_NONE);
+    }
+    /* "Keep Alives and Timers, 2": check echo status */
+    if (global.conn->ka_state == KA_OUTSTANDING) {
+        /* no response to keep-alive */
+        log ("closing control connection due to missing echo reply");
+	pptp_conn_close(global.conn, PPTP_STOP_NONE);
+    } else { /* ka_state == NONE */ /* send keep-alive */
+        struct pptp_echo_rqst rqst = {
+            PPTP_HEADER_CTRL(PPTP_ECHO_RQST), hton32(global.conn->ka_id) };
+        pptp_send_ctrl_packet(global.conn, &rqst, sizeof(rqst));
+        global.conn->ka_state = KA_OUTSTANDING;
+    }
+    /* check incoming/outgoing call states for !IDLE && !ESTABLISHED */
+    for (i = 0; i < vector_size(global.conn->call); i++) {
+        PPTP_CALL * call = vector_get_Nth(global.conn->call, i);
+        if (call->call_type == PPTP_CALL_PNS) {
+            if (call->state.pns == PNS_WAIT_REPLY) {
+                /* send close request */
+                pptp_call_close(global.conn, call);
+                assert(call->state.pns == PNS_WAIT_DISCONNECT);
+            } else if (call->state.pns == PNS_WAIT_DISCONNECT) {
+                /* hard-close the call */
+                pptp_call_destroy(global.conn, call);
+            }
+        } else if (call->call_type == PPTP_CALL_PAC) {
+            if (call->state.pac == PAC_WAIT_REPLY) {
+                /* XXX FIXME -- drop the PAC connection XXX */
+            } else if (call->state.pac == PAC_WAIT_CS_ANS) {
+                /* XXX FIXME -- drop the PAC connection XXX */
+            }
+        }
+    }
+    pptp_reset_timer();
+}
diff -uprN ppp-2.4.3.old/pppd/plugins/pptp/pptp_ctrl.h ppp-2.4.3/pppd/plugins/pptp/pptp_ctrl.h
--- ppp-2.4.3.old/pppd/plugins/pptp/pptp_ctrl.h	1970-01-01 03:00:00.000000000 +0300
+++ ppp-2.4.3/pppd/plugins/pptp/pptp_ctrl.h	2008-09-20 22:27:45.000000000 +0400
@@ -0,0 +1,57 @@
+/* pptp_ctrl.h ... handle PPTP control connection.
+ *                 C. Scott Ananian <cananian@alumni.princeton.edu>
+ *
+ * $Id: pptp_ctrl.h,v 1.5 2004/11/09 01:42:32 quozl Exp $
+ */
+
+#ifndef INC_PPTP_CTRL_H
+#define INC_PPTP_CTRL_H
+#include <sys/types.h>
+
+typedef struct PPTP_CONN PPTP_CONN;
+typedef struct PPTP_CALL PPTP_CALL;
+
+enum call_state { CALL_OPEN_RQST,  CALL_OPEN_DONE, CALL_OPEN_FAIL,
+		  CALL_CLOSE_RQST, CALL_CLOSE_DONE };
+enum conn_state { CONN_OPEN_RQST,  CONN_OPEN_DONE, CONN_OPEN_FAIL,
+		  CONN_CLOSE_RQST, CONN_CLOSE_DONE };
+
+typedef void (*pptp_call_cb)(PPTP_CONN*, PPTP_CALL*, enum call_state);
+typedef void (*pptp_conn_cb)(PPTP_CONN*, enum conn_state);
+
+/* if 'isclient' is true, then will send 'conn open' packet to other host.
+ * not necessary if this is being opened by a server process after
+ * receiving a conn_open packet from client.
+ */
+PPTP_CONN * pptp_conn_open(int inet_sock, int isclient,
+			   pptp_conn_cb callback);
+PPTP_CALL * pptp_call_open(PPTP_CONN * conn, int call_id,
+			   pptp_call_cb callback, char *phonenr,int window);
+int pptp_conn_established(PPTP_CONN * conn);
+/* soft close.  Will callback on completion. */
+void pptp_call_close(PPTP_CONN * conn, PPTP_CALL * call);
+/* hard close. */
+void pptp_call_destroy(PPTP_CONN *conn, PPTP_CALL *call);
+/* soft close.  Will callback on completion. */
+void pptp_conn_close(PPTP_CONN * conn, u_int8_t close_reason);
+/* hard close */
+void pptp_conn_destroy(PPTP_CONN * conn);
+
+/* Add file descriptors used by pptp to fd_set. */
+void pptp_fd_set(PPTP_CONN * conn, fd_set * read_set, fd_set * write_set, int *max_fd);
+/* handle any pptp file descriptors set in fd_set, and clear them */
+int pptp_dispatch(PPTP_CONN * conn, fd_set * read_set, fd_set * write_set);
+
+/* Get info about connection, call */
+void pptp_call_get_ids(PPTP_CONN * conn, PPTP_CALL * call,
+		       u_int16_t * call_id, u_int16_t * peer_call_id);
+/* Arbitrary user data about this call/connection.
+ * It is the caller's responsibility to free this data before calling
+ * pptp_call|conn_close()
+ */
+void * pptp_conn_closure_get(PPTP_CONN * conn);
+void   pptp_conn_closure_put(PPTP_CONN * conn, void *cl);
+void * pptp_call_closure_get(PPTP_CONN * conn, PPTP_CALL * call);
+void   pptp_call_closure_put(PPTP_CONN * conn, PPTP_CALL * call, void *cl);
+
+#endif /* INC_PPTP_CTRL_H */
diff -uprN ppp-2.4.3.old/pppd/plugins/pptp/pptp_msg.h ppp-2.4.3/pppd/plugins/pptp/pptp_msg.h
--- ppp-2.4.3.old/pppd/plugins/pptp/pptp_msg.h	1970-01-01 03:00:00.000000000 +0300
+++ ppp-2.4.3/pppd/plugins/pptp/pptp_msg.h	2008-09-20 22:27:45.000000000 +0400
@@ -0,0 +1,303 @@
+/*  pptp.h:  packet structures and magic constants for the PPTP protocol 
+ *           C. Scott Ananian <cananian@alumni.princeton.edu>            
+ *
+ * $Id: pptp_msg.h,v 1.3 2003/02/15 10:37:21 quozl Exp $
+ */
+
+#ifndef INC_PPTP_H
+#define INC_PPTP_H
+
+/* Grab definitions of int16, int32, etc. */
+#include <sys/types.h>
+/* define "portable" htons, etc. */
+#define hton8(x)  (x)
+#define ntoh8(x)  (x)
+#define hton16(x) htons(x)
+#define ntoh16(x) ntohs(x)
+#define hton32(x) htonl(x)
+#define ntoh32(x) ntohl(x)
+
+/* PPTP magic numbers: ----------------------------------------- */
+
+#define PPTP_MAGIC 0x1A2B3C4D /* Magic cookie for PPTP datagrams */
+#define PPTP_PORT  1723       /* PPTP TCP port number            */
+#define PPTP_PROTO 47         /* PPTP IP protocol number         */
+
+/* Control Connection Message Types: --------------------------- */
+
+#define PPTP_MESSAGE_CONTROL		1
+#define PPTP_MESSAGE_MANAGE		2
+
+/* Control Message Types: -------------------------------------- */
+
+/* (Control Connection Management) */
+#define PPTP_START_CTRL_CONN_RQST	1
+#define PPTP_START_CTRL_CONN_RPLY	2
+#define PPTP_STOP_CTRL_CONN_RQST	3
+#define PPTP_STOP_CTRL_CONN_RPLY	4
+#define PPTP_ECHO_RQST			5
+#define PPTP_ECHO_RPLY			6
+
+/* (Call Management) */
+#define PPTP_OUT_CALL_RQST		7
+#define PPTP_OUT_CALL_RPLY		8
+#define PPTP_IN_CALL_RQST		9
+#define PPTP_IN_CALL_RPLY		10
+#define PPTP_IN_CALL_CONNECT		11
+#define PPTP_CALL_CLEAR_RQST		12
+#define PPTP_CALL_CLEAR_NTFY		13
+
+/* (Error Reporting) */
+#define PPTP_WAN_ERR_NTFY		14
+
+/* (PPP Session Control) */
+#define PPTP_SET_LINK_INFO		15
+
+/* PPTP version information: --------------------------------------*/
+#define PPTP_VERSION_STRING	"1.00"
+#define PPTP_VERSION		0x100
+#define PPTP_FIRMWARE_STRING	"0.01"
+#define PPTP_FIRMWARE_VERSION	0x001
+
+/* PPTP capabilities: ---------------------------------------------*/
+
+/* (Framing capabilities for msg sender) */
+#define PPTP_FRAME_ASYNC	1
+#define PPTP_FRAME_SYNC		2
+#define PPTP_FRAME_ANY          3
+
+/* (Bearer capabilities for msg sender) */
+#define PPTP_BEARER_ANALOG	1
+#define PPTP_BEARER_DIGITAL 	2
+#define PPTP_BEARER_ANY		3
+
+#define PPTP_RESULT_GENERAL_ERROR 2
+
+/* (Reasons to close a connection) */
+#define PPTP_STOP_NONE		  1 /* no good reason                        */
+#define PPTP_STOP_PROTOCOL	  2 /* can't support peer's protocol version */
+#define PPTP_STOP_LOCAL_SHUTDOWN  3 /* requester is being shut down          */
+
+/* PPTP datagram structures (all data in network byte order): ----------*/
+
+struct pptp_header {
+  u_int16_t length;	  /* message length in octets, including header */
+  u_int16_t pptp_type;	  /* PPTP message type. 1 for control message.  */
+  u_int32_t magic;	  /* this should be PPTP_MAGIC.                 */
+  u_int16_t ctrl_type;	  /* Control message type (0-15)                */
+  u_int16_t reserved0;	  /* reserved.  MUST BE ZERO.                   */
+};
+
+struct pptp_start_ctrl_conn { /* for control message types 1 and 2 */
+  struct pptp_header header;
+
+  u_int16_t version;      /* PPTP protocol version.  = PPTP_VERSION     */
+  u_int8_t  result_code;  /* these two fields should be zero on rqst msg*/
+  u_int8_t  error_code;   /* 0 unless result_code==2 (General Error)    */
+  u_int32_t framing_cap;  /* Framing capabilities                       */
+  u_int32_t bearer_cap;   /* Bearer Capabilities                        */
+  u_int16_t max_channels; /* Maximum Channels (=0 for PNS, PAC ignores) */
+  u_int16_t firmware_rev; /* Firmware or Software Revision              */
+  u_int8_t  hostname[64]; /* Host Name (64 octets, zero terminated)     */
+  u_int8_t  vendor[64];   /* Vendor string (64 octets, zero term.)      */
+  /* MS says that end of hostname/vendor fields should be filled with   */
+  /* octets of value 0, but Win95 PPTP driver doesn't do this.          */
+};
+
+struct pptp_stop_ctrl_conn { /* for control message types 3 and 4 */
+  struct pptp_header header;
+
+  u_int8_t reason_result; /* reason for rqst, result for rply          */
+  u_int8_t error_code;	  /* MUST be 0, unless rply result==2 (general err)*/
+  u_int16_t reserved1;    /* MUST be 0                                */
+};
+
+struct pptp_echo_rqst { /* for control message type 5 */
+  struct pptp_header header;
+  u_int32_t identifier;   /* arbitrary value set by sender which is used */
+                          /* to match up reply and request               */
+};
+
+struct pptp_echo_rply { /* for control message type 6 */
+  struct pptp_header header;
+  u_int32_t identifier;	  /* should correspond to id of rqst             */
+  u_int8_t result_code;
+  u_int8_t error_code;    /* =0, unless result_code==2 (general error)   */
+  u_int16_t reserved1;    /* MUST BE ZERO                                */
+};
+
+struct pptp_out_call_rqst { /* for control message type 7 */
+  struct pptp_header header;
+  u_int16_t call_id;	  /* Call ID (unique id used to multiplex data)  */
+  u_int16_t call_sernum;  /* Call Serial Number (used for logging)       */
+  u_int32_t bps_min;      /* Minimum BPS (lowest acceptable line speed)  */
+  u_int32_t bps_max;	  /* Maximum BPS (highest acceptable line speed) */
+  u_int32_t bearer;	  /* Bearer type                                 */
+  u_int32_t framing;      /* Framing type                                */
+  u_int16_t recv_size;	  /* Recv. Window Size (no. of buffered packets) */
+  u_int16_t delay;	  /* Packet Processing Delay (in 1/10 sec)       */
+  u_int16_t phone_len;	  /* Phone Number Length (num. of valid digits)  */
+  u_int16_t reserved1;    /* MUST BE ZERO				 */
+  u_int8_t  phone_num[64]; /* Phone Number (64 octets, null term.)       */
+  u_int8_t subaddress[64]; /* Subaddress (64 octets, null term.)         */
+};
+
+struct pptp_out_call_rply { /* for control message type 8 */
+  struct pptp_header header;
+  u_int16_t call_id;      /* Call ID (used to multiplex data over tunnel)*/
+  u_int16_t call_id_peer; /* Peer's Call ID (call_id of pptp_out_call_rqst)*/
+  u_int8_t  result_code;  /* Result Code (1 is no errors)                */
+  u_int8_t  error_code;   /* Error Code (=0 unless result_code==2)       */
+  u_int16_t cause_code;   /* Cause Code (addt'l failure information)     */
+  u_int32_t speed;        /* Connect Speed (in BPS)                      */
+  u_int16_t recv_size;    /* Recv. Window Size (no. of buffered packets) */
+  u_int16_t delay;	  /* Packet Processing Delay (in 1/10 sec)       */
+  u_int32_t channel;      /* Physical Channel ID (for logging)           */
+};
+
+struct pptp_in_call_rqst { /* for control message type 9 */
+  struct pptp_header header;
+  u_int16_t call_id;	  /* Call ID (unique id used to multiplex data)  */
+  u_int16_t call_sernum;  /* Call Serial Number (used for logging)       */
+  u_int32_t bearer;	  /* Bearer type                                 */
+  u_int32_t channel;      /* Physical Channel ID (for logging)           */
+  u_int16_t dialed_len;   /* Dialed Number Length (# of valid digits)    */
+  u_int16_t dialing_len;  /* Dialing Number Length (# of valid digits)   */
+  u_int8_t dialed_num[64]; /* Dialed Number (64 octets, zero term.)      */
+  u_int8_t dialing_num[64]; /* Dialing Number (64 octets, zero term.)    */
+  u_int8_t subaddress[64];  /* Subaddress (64 octets, zero term.)        */
+};
+
+struct pptp_in_call_rply { /* for control message type 10 */
+  struct pptp_header header;
+  u_int16_t call_id;      /* Call ID (used to multiplex data over tunnel)*/
+  u_int16_t call_id_peer; /* Peer's Call ID (call_id of pptp_out_call_rqst)*/
+  u_int8_t  result_code;  /* Result Code (1 is no errors)                */
+  u_int8_t  error_code;   /* Error Code (=0 unless result_code==2)       */
+  u_int16_t recv_size;    /* Recv. Window Size (no. of buffered packets) */
+  u_int16_t delay;	  /* Packet Processing Delay (in 1/10 sec)       */
+  u_int16_t reserved1;    /* MUST BE ZERO                                */
+};
+
+struct pptp_in_call_connect { /* for control message type 11 */
+  struct pptp_header header;
+  u_int16_t call_id_peer; /* Peer's Call ID (call_id of pptp_out_call_rqst)*/
+  u_int16_t reserved1;    /* MUST BE ZERO                                */
+  u_int32_t speed;        /* Connect Speed (in BPS)                      */
+  u_int16_t recv_size;    /* Recv. Window Size (no. of buffered packets) */
+  u_int16_t delay;	  /* Packet Processing Delay (in 1/10 sec)       */
+  u_int32_t framing;      /* Framing type                                */
+};
+
+struct pptp_call_clear_rqst { /* for control message type 12 */
+  struct pptp_header header;
+  u_int16_t call_id;      /* Call ID (used to multiplex data over tunnel)*/
+  u_int16_t reserved1;    /* MUST BE ZERO                                */
+};
+
+struct pptp_call_clear_ntfy { /* for control message type 13 */
+  struct pptp_header header;
+  u_int16_t call_id;      /* Call ID (used to multiplex data over tunnel)*/
+  u_int8_t  result_code;  /* Result Code                                 */
+  u_int8_t  error_code;   /* Error Code (=0 unless result_code==2)       */
+  u_int16_t cause_code;   /* Cause Code (for ISDN, is Q.931 cause code)  */
+  u_int16_t reserved1;    /* MUST BE ZERO                                */
+  u_int8_t call_stats[128]; /* Call Statistics: 128 octets, ascii, 0-term */
+};
+
+struct pptp_wan_err_ntfy {    /* for control message type 14 */
+  struct pptp_header header;
+  u_int16_t call_id_peer; /* Peer's Call ID (call_id of pptp_out_call_rqst)*/
+  u_int16_t reserved1;    /* MUST BE ZERO                                */
+  u_int32_t crc_errors;   /* CRC errors 				 */
+  u_int32_t frame_errors; /* Framing errors 				 */
+  u_int32_t hard_errors;  /* Hardware overruns 				 */
+  u_int32_t buff_errors;  /* Buffer overruns				 */
+  u_int32_t time_errors;  /* Time-out errors				 */
+  u_int32_t align_errors; /* Alignment errors				 */
+};
+
+struct pptp_set_link_info {   /* for control message type 15 */
+  struct pptp_header header;
+  u_int16_t call_id_peer; /* Peer's Call ID (call_id of pptp_out_call_rqst) */
+  u_int16_t reserved1;    /* MUST BE ZERO                                   */
+  u_int32_t send_accm;    /* Send ACCM (for PPP packets; default 0xFFFFFFFF)*/
+  u_int32_t recv_accm;    /* Receive ACCM (for PPP pack.;default 0xFFFFFFFF)*/
+};
+
+/* helpful #defines: -------------------------------------------- */
+#define pptp_isvalid_ctrl(header, type, length) \
+ (!( ( ntoh16(((struct pptp_header *)header)->length)    < (length)  ) ||   \
+     ( ntoh16(((struct pptp_header *)header)->pptp_type) !=(type)    ) ||   \
+     ( ntoh32(((struct pptp_header *)header)->magic)     !=PPTP_MAGIC) ||   \
+     ( ntoh16(((struct pptp_header *)header)->ctrl_type) > PPTP_SET_LINK_INFO) || \
+     ( ntoh16(((struct pptp_header *)header)->reserved0) !=0         ) ))
+
+#define PPTP_HEADER_CTRL(type)  \
+{ hton16(PPTP_CTRL_SIZE(type)), \
+  hton16(PPTP_MESSAGE_CONTROL), \
+  hton32(PPTP_MAGIC),           \
+  hton16(type), 0 }             
+
+#define PPTP_CTRL_SIZE(type) ( \
+(type==PPTP_START_CTRL_CONN_RQST)?sizeof(struct pptp_start_ctrl_conn):	\
+(type==PPTP_START_CTRL_CONN_RPLY)?sizeof(struct pptp_start_ctrl_conn):	\
+(type==PPTP_STOP_CTRL_CONN_RQST )?sizeof(struct pptp_stop_ctrl_conn):	\
+(type==PPTP_STOP_CTRL_CONN_RPLY )?sizeof(struct pptp_stop_ctrl_conn):	\
+(type==PPTP_ECHO_RQST           )?sizeof(struct pptp_echo_rqst):	\
+(type==PPTP_ECHO_RPLY           )?sizeof(struct pptp_echo_rply):	\
+(type==PPTP_OUT_CALL_RQST       )?sizeof(struct pptp_out_call_rqst):	\
+(type==PPTP_OUT_CALL_RPLY       )?sizeof(struct pptp_out_call_rply):	\
+(type==PPTP_IN_CALL_RQST        )?sizeof(struct pptp_in_call_rqst):	\
+(type==PPTP_IN_CALL_RPLY        )?sizeof(struct pptp_in_call_rply):	\
+(type==PPTP_IN_CALL_CONNECT     )?sizeof(struct pptp_in_call_connect):	\
+(type==PPTP_CALL_CLEAR_RQST     )?sizeof(struct pptp_call_clear_rqst):	\
+(type==PPTP_CALL_CLEAR_NTFY     )?sizeof(struct pptp_call_clear_ntfy):	\
+(type==PPTP_WAN_ERR_NTFY        )?sizeof(struct pptp_wan_err_ntfy):	\
+(type==PPTP_SET_LINK_INFO       )?sizeof(struct pptp_set_link_info):	\
+0)
+#define max(a,b) (((a)>(b))?(a):(b))
+#define PPTP_CTRL_SIZE_MAX (			\
+max(sizeof(struct pptp_start_ctrl_conn),	\
+max(sizeof(struct pptp_echo_rqst),		\
+max(sizeof(struct pptp_echo_rply),		\
+max(sizeof(struct pptp_out_call_rqst),		\
+max(sizeof(struct pptp_out_call_rply),		\
+max(sizeof(struct pptp_in_call_rqst),		\
+max(sizeof(struct pptp_in_call_rply),		\
+max(sizeof(struct pptp_in_call_connect),	\
+max(sizeof(struct pptp_call_clear_rqst),	\
+max(sizeof(struct pptp_call_clear_ntfy),	\
+max(sizeof(struct pptp_wan_err_ntfy),		\
+max(sizeof(struct pptp_set_link_info), 0)))))))))))))
+
+
+/* gre header structure: -------------------------------------------- */
+
+#define PPTP_GRE_PROTO  0x880B
+#define PPTP_GRE_VER    0x1
+
+#define PPTP_GRE_FLAG_C	0x80
+#define PPTP_GRE_FLAG_R	0x40
+#define PPTP_GRE_FLAG_K	0x20
+#define PPTP_GRE_FLAG_S	0x10
+#define PPTP_GRE_FLAG_A	0x80
+
+#define PPTP_GRE_IS_C(f) ((f)&PPTP_GRE_FLAG_C)
+#define PPTP_GRE_IS_R(f) ((f)&PPTP_GRE_FLAG_R)
+#define PPTP_GRE_IS_K(f) ((f)&PPTP_GRE_FLAG_K)
+#define PPTP_GRE_IS_S(f) ((f)&PPTP_GRE_FLAG_S)
+#define PPTP_GRE_IS_A(f) ((f)&PPTP_GRE_FLAG_A)
+
+struct pptp_gre_header {
+  u_int8_t flags;		/* bitfield */
+  u_int8_t ver;			/* should be PPTP_GRE_VER (enhanced GRE) */
+  u_int16_t protocol;		/* should be PPTP_GRE_PROTO (ppp-encaps) */
+  u_int16_t payload_len;	/* size of ppp payload, not inc. gre header */
+  u_int16_t call_id;		/* peer's call_id for this session */
+  u_int32_t seq;		/* sequence number.  Present if S==1 */
+  u_int32_t ack;		/* seq number of highest packet recieved by */
+  				/*  sender in this session */
+};
+
+#endif /* INC_PPTP_H */
diff -uprN ppp-2.4.3.old/pppd/plugins/pptp/pptp_options.h ppp-2.4.3/pppd/plugins/pptp/pptp_options.h
--- ppp-2.4.3.old/pppd/plugins/pptp/pptp_options.h	1970-01-01 03:00:00.000000000 +0300
+++ ppp-2.4.3/pppd/plugins/pptp/pptp_options.h	2008-09-20 22:27:45.000000000 +0400
@@ -0,0 +1,41 @@
+/* pptp_options.h ...... various constants used in the PPTP protocol.
+ *                       #define STANDARD to emulate NT 4.0 exactly.
+ *                       C. Scott Ananian <cananian@alumni.princeton.edu>
+ *
+ * $Id: pptp_options.h,v 1.3 2004/11/09 01:42:32 quozl Exp $
+ */
+
+#ifndef INC_PPTP_OPTIONS_H
+#define INC_PPTP_OPTIONS_H
+
+#undef  PPTP_FIRMWARE_STRING
+#undef  PPTP_FIRMWARE_VERSION
+#define PPTP_BUF_MAX 65536
+#define PPTP_TIMEOUT 60 /* seconds */
+extern int idle_wait;
+extern int max_echo_wait;
+#define PPTP_CONNECT_SPEED 1000000000
+#define PPTP_WINDOW 3
+#define PPTP_DELAY  0
+#define PPTP_BPS_MIN 2400
+#define PPTP_BPS_MAX 1000000000
+
+#ifndef STANDARD
+#define PPTP_MAX_CHANNELS 65535
+#define PPTP_FIRMWARE_STRING "0.01"
+#define PPTP_FIRMWARE_VERSION 0x001
+#define PPTP_HOSTNAME {'l','o','c','a','l',0}
+#define PPTP_VENDOR   {'c','a','n','a','n','i','a','n',0}
+#define PPTP_FRAME_CAP  PPTP_FRAME_ANY
+#define PPTP_BEARER_CAP PPTP_BEARER_ANY
+#else
+#define PPTP_MAX_CHANNELS 5
+#define PPTP_FIRMWARE_STRING "0.01"
+#define PPTP_FIRMWARE_VERSION 0
+#define PPTP_HOSTNAME {'l','o','c','a','l',0}
+#define PPTP_VENDOR   {'N','T',0}
+#define PPTP_FRAME_CAP  2
+#define PPTP_BEARER_CAP 1
+#endif
+
+#endif /* INC_PPTP_OPTIONS_H */
diff -uprN ppp-2.4.3.old/pppd/plugins/pptp/pptp_quirks.c ppp-2.4.3/pppd/plugins/pptp/pptp_quirks.c
--- ppp-2.4.3.old/pppd/plugins/pptp/pptp_quirks.c	1970-01-01 03:00:00.000000000 +0300
+++ ppp-2.4.3/pppd/plugins/pptp/pptp_quirks.c	2008-09-20 22:27:45.000000000 +0400
@@ -0,0 +1,54 @@
+/* pptp_quirks.c ...... various options to fix quirks found in buggy adsl modems
+ *                      mulix <mulix@actcom.co.il>
+ *
+ * $Id: pptp_quirks.c,v 1.2 2001/11/23 03:42:51 quozl Exp $
+ */
+
+#include <string.h>
+#include "orckit_quirks.h"
+#include "pptp_quirks.h"
+
+static int quirk_index = -1;
+
+struct pptp_fixup pptp_fixups[] = {
+    {BEZEQ_ISRAEL, ORCKIT, ORCKIT_ATUR3,
+     orckit_atur3_build_hook,
+     orckit_atur3_start_ctrl_conn_hook,
+     orckit_atur3_set_link_hook}
+};
+
+static int fixups_sz = sizeof(pptp_fixups)/sizeof(pptp_fixups[0]);
+
+/* return 0 on success, non 0 otherwise */
+int set_quirk_index(int index)
+{
+    if (index >= 0 && index < fixups_sz) {
+	quirk_index = index;
+	return 0;
+    }
+
+    return -1;
+}
+
+int get_quirk_index()
+{
+    return quirk_index;
+}
+
+/* return the index for this isp in the quirks table, -1 if not found */
+int find_quirk(const char* isp_name)
+{
+    int i = 0;
+    if (isp_name) {
+	while (i < fixups_sz && pptp_fixups[i].isp) {
+	    if (!strcmp(pptp_fixups[i].isp, isp_name)) {
+		return i;
+	    }
+	    ++i;
+	}
+    }
+
+    return -1;
+}
+
+
diff -uprN ppp-2.4.3.old/pppd/plugins/pptp/pptp_quirks.h ppp-2.4.3/pppd/plugins/pptp/pptp_quirks.h
--- ppp-2.4.3.old/pppd/plugins/pptp/pptp_quirks.h	1970-01-01 03:00:00.000000000 +0300
+++ ppp-2.4.3/pppd/plugins/pptp/pptp_quirks.h	2008-09-20 22:27:45.000000000 +0400
@@ -0,0 +1,59 @@
+/* pptp_quirks.h ...... various options to fix quirks found in buggy adsl modems
+ *                      mulix <mulix@actcom.co.il>
+ *
+ * $Id: pptp_quirks.h,v 1.1 2001/11/20 06:30:10 quozl Exp $
+ */
+
+#ifndef INC_PPTP_QUIRKS_H
+#define INC_PPTP_QUIRKS_H
+
+/* isp defs - correspond to slots in the fixups table */
+#define BEZEQ_ISRAEL "BEZEQ_ISRAEL"
+
+/* vendor defs */
+
+#define ORCKIT 1
+#define ALCATEL 2
+
+/* device defs */
+
+#define ORCKIT_ATUR2 1
+#define ORCKIT_ATUR3 2
+
+#include "pptp_msg.h"
+#include "pptp_ctrl.h"
+
+struct pptp_fixup {
+    const char* isp;    /* which isp? e.g. Bezeq in Israel */
+    int vendor; /* which vendor? e.g. Orckit */
+    int device; /* which device? e.g. Orckit Atur3 */
+
+    /* use this hook to build your own out call request packet */
+    int (*out_call_rqst_hook)(struct pptp_out_call_rqst* packet);
+
+    /* use this hook to build your own start control connection packet */
+    /* note that this hook is called from two different places, depending
+       on whether this is a request or reply */
+    int (*start_ctrl_conn)(struct pptp_start_ctrl_conn* packet);
+
+    /* use this hook if you need to send a 'set_link' packet once
+       the connection is established */
+    int (*set_link_hook)(struct pptp_set_link_info* packet,
+			 int peer_call_id);
+};
+
+extern struct pptp_fixup pptp_fixups[];
+
+/* find the index for this isp in the quirks table */
+/* return the index on success, -1 if not found */
+int find_quirk(const char* isp_name);
+
+/* set the global quirk index. return 0 on success, non 0 otherwise */
+int set_quirk_index(int index);
+
+/* get the global quirk index. return the index on success,
+   -1 if no quirk is defined */
+int get_quirk_index();
+
+
+#endif /* INC_PPTP_QUIRKS_H */
diff -uprN ppp-2.4.3.old/pppd/plugins/pptp/util.c ppp-2.4.3/pppd/plugins/pptp/util.c
--- ppp-2.4.3.old/pppd/plugins/pptp/util.c	1970-01-01 03:00:00.000000000 +0300
+++ ppp-2.4.3/pppd/plugins/pptp/util.c	2008-09-20 22:27:45.000000000 +0400
@@ -0,0 +1,154 @@
+/* util.c ....... error message utilities.
+ *                C. Scott Ananian <cananian@alumni.princeton.edu>
+ *
+ * $Id: util.c,v 1.11 2005/08/22 00:49:48 quozl Exp $
+ */
+
+#include <stdio.h>
+#include <stdarg.h>
+#include <syslog.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include "util.h"
+
+#ifndef PROGRAM_NAME
+#define PROGRAM_NAME "pptp"
+#endif
+
+/* implementation of log_string, defined as extern in util.h */
+char *log_string = "anon";
+
+static void open_log(void) __attribute__ ((constructor));
+static void close_log(void) __attribute__ ((destructor));
+
+#define MAKE_STRING(label) 				\
+va_list ap;						\
+char buf[256], string[256];				\
+va_start(ap, format);					\
+vsnprintf(buf, sizeof(buf), format, ap);		\
+snprintf(string, sizeof(string), "%s %s[%s:%s:%d]: %s",	\
+	 log_string, label, func, file, line, buf);	\
+va_end(ap)
+
+/*** open log *****************************************************************/
+static void open_log(void) {
+    openlog(PROGRAM_NAME, LOG_PID, LOG_DAEMON);
+}
+
+/*** close log ****************************************************************/
+static void close_log(void)
+{
+    closelog();
+}
+
+/*** print a message to syslog ************************************************/
+void _log(const char *func, const char *file, int line, const char *format, ...)
+{
+    MAKE_STRING("log");
+    syslog(LOG_NOTICE, "%s", string);
+}
+
+/*** print a warning to syslog ************************************************/
+void _warn(const char *func, const char *file, int line, const char *format, ...)
+{
+    MAKE_STRING("warn");
+    fprintf(stderr, "%s\n", string);
+    syslog(LOG_WARNING, "%s", string);
+}
+
+/*** print a fatal warning to syslog and exit *********************************/
+void _fatal(const char *func, const char *file, int line, const char *format, ...)
+{
+    MAKE_STRING("fatal");
+    fprintf(stderr, "%s\n", string);
+    syslog(LOG_CRIT, "%s", string);
+    exit(1);
+}
+
+/*** connect a file to a file descriptor **************************************/
+int file2fd(const char *path, const char *mode, int fd)
+{
+    int ok = 0;
+    FILE *file = NULL;
+    file = fopen(path, mode);
+    if (file != NULL && dup2(fileno(file), fd) != -1)
+        ok = 1;
+    if (file) fclose(file);
+    return ok;
+}
+
+/* signal to pipe delivery implementation */
+#include <unistd.h>
+#include <fcntl.h>
+#include <signal.h>
+#include <string.h>
+
+/* pipe private to process */
+static int sigpipe[2];
+
+/* create a signal pipe, returns 0 for success, -1 with errno for failure */
+int sigpipe_create()
+{
+  int rc;
+  
+  rc = pipe(sigpipe);
+  if (rc < 0) return rc;
+  
+  fcntl(sigpipe[0], F_SETFD, FD_CLOEXEC);
+  fcntl(sigpipe[1], F_SETFD, FD_CLOEXEC);
+  
+#ifdef O_NONBLOCK
+#define FLAG_TO_SET O_NONBLOCK
+#else
+#ifdef SYSV
+#define FLAG_TO_SET O_NDELAY
+#else /* BSD */
+#define FLAG_TO_SET FNDELAY
+#endif
+#endif
+  
+  rc = fcntl(sigpipe[1], F_GETFL);
+  if (rc != -1)
+    rc = fcntl(sigpipe[1], F_SETFL, rc | FLAG_TO_SET);
+  if (rc < 0) return rc;
+  return 0;
+#undef FLAG_TO_SET
+}
+
+/* generic handler for signals, writes signal number to pipe */
+void sigpipe_handler(int signum)
+{
+  write(sigpipe[1], &signum, sizeof(signum));
+  signal(signum, sigpipe_handler);
+}
+
+/* assign a signal number to the pipe */
+void sigpipe_assign(int signum)
+{
+  struct sigaction sa;
+
+  memset(&sa, 0, sizeof(sa));
+  sa.sa_handler = sigpipe_handler;
+  sigaction(signum, &sa, NULL);
+}
+
+/* return the signal pipe read file descriptor for select(2) */
+int sigpipe_fd()
+{
+  return sigpipe[0];
+}
+
+/* read and return the pending signal from the pipe */
+int sigpipe_read()
+{
+  int signum;
+  read(sigpipe[0], &signum, sizeof(signum));
+  return signum;
+}
+
+void sigpipe_close()
+{
+  close(sigpipe[0]);
+  close(sigpipe[1]);
+}
+
diff -uprN ppp-2.4.3.old/pppd/plugins/pptp/util.h ppp-2.4.3/pppd/plugins/pptp/util.h
--- ppp-2.4.3.old/pppd/plugins/pptp/util.h	1970-01-01 03:00:00.000000000 +0300
+++ ppp-2.4.3/pppd/plugins/pptp/util.h	2008-09-20 22:27:45.000000000 +0400
@@ -0,0 +1,54 @@
+/* util.h ....... error message utilities.
+ *                C. Scott Ananian <cananian@alumni.princeton.edu>
+ *
+ * $Id: util.h,v 1.6 2005/03/10 01:18:20 quozl Exp $
+ */
+
+#ifndef INC_UTIL_H
+#define INC_UTIL_H
+
+/* log_string is an identifier for this pptp process, passed from
+   command line using --log-string=X, and included with every log message.
+   Useful for people with multiple pptp sessions open at a time */
+extern char * log_string;
+
+/* log_level sets the logging verbosity. Values range from 0 (errors only)
+   to 1 (errors and warnings) to 2 (high verbosity, for debugging) */
+extern int    log_level;
+
+void _log(const char *func, const char *file, int line, const char *format, ...)
+     __attribute__ ((format (printf, 4, 5)));
+void _warn(const char *func, const char *file, int line, const char *format, ...)
+     __attribute__ ((format (printf, 4, 5)));
+void _fatal(const char *func, const char *file, int line, const char *format, ...)
+     __attribute__ ((format (printf, 4, 5))) __attribute__ ((noreturn));
+
+#define log(format, args...) \
+	_log(__FUNCTION__,__FILE__,__LINE__, format , ## args)
+#define warn(format, args...) \
+	_warn(__FUNCTION__,__FILE__,__LINE__, format , ## args)
+#define fatal(format, args...) \
+	_fatal(__FUNCTION__,__FILE__,__LINE__, format , ## args)
+
+int file2fd(const char *path, const char *mode, int fd);
+
+/* signal to pipe delivery implementation */
+
+/* create a signal pipe, returns 0 for success, -1 with errno for failure */
+int sigpipe_create();
+
+/* generic handler for signals, writes signal number to pipe */
+void sigpipe_handler(int signum);
+
+/* assign a signal number to the pipe */
+void sigpipe_assign(int signum);
+
+/* return the signal pipe read file descriptor for select(2) */
+int sigpipe_fd();
+
+/* read and return the pending signal from the pipe */
+int sigpipe_read();
+
+void sigpipe_close();
+
+#endif /* INC_UTIL_H */
diff -uprN ppp-2.4.3.old/pppd/plugins/pptp/vector.c ppp-2.4.3/pppd/plugins/pptp/vector.c
--- ppp-2.4.3.old/pppd/plugins/pptp/vector.c	1970-01-01 03:00:00.000000000 +0300
+++ ppp-2.4.3/pppd/plugins/pptp/vector.c	2008-09-20 22:27:45.000000000 +0400
@@ -0,0 +1,209 @@
+/* vector.c ..... store a vector of PPTP_CALL information and search it
+ *                efficiently.
+ *                C. Scott Ananian <cananian@alumni.princeton.edu>
+ *
+ * $Id: vector.c,v 1.3 2003/06/17 10:12:55 reink Exp $
+ */
+
+#include <stdlib.h>
+#include <string.h>
+#include <assert.h>
+#include "pptp_ctrl.h"
+#include "vector.h"
+/* #define VECTOR_DEBUG */
+#ifndef TRUE
+#define TRUE 1
+#endif
+#ifndef FALSE
+#define FALSE 0
+#endif
+
+struct vector_item {
+    int key;
+    PPTP_CALL *call;
+};
+
+struct vector_struct {
+    struct vector_item *item;
+    int size;
+    int alloc;
+#ifdef VECTOR_DEBUG
+    int key_max;
+#endif
+};
+
+static struct vector_item *binary_search(VECTOR *v, int key);
+
+/*** vector_create ************************************************************/
+VECTOR *vector_create()
+{
+    const int INITIAL_SIZE = 4;
+
+    VECTOR *v = malloc(sizeof(*v));
+    if (v == NULL) return v;
+
+    v->size = 0;
+    v->alloc = INITIAL_SIZE;
+    v->item = malloc(sizeof(*(v->item)) * (v->alloc));
+#ifdef VECTOR_DEBUG
+    v->key_max = -1;
+#endif
+    if (v->item == NULL) { free(v); return NULL; }
+    else return v;
+}
+
+/*** vector_destroy ***********************************************************/
+void vector_destroy(VECTOR *v)
+{
+    free(v->item);
+#ifdef VECTOR_DEBUG
+    v->item = NULL;
+#endif
+    free(v);
+}
+
+/*** vector_size **************************************************************/
+int vector_size(VECTOR *v)
+{
+    assert(v != NULL);
+    return v->size;
+}
+
+/*** vector_insert*************************************************************
+ * nice thing about file descriptors is that we are assured by POSIX 
+ * that they are monotonically increasing.
+ */
+int vector_insert(VECTOR *v, int key, PPTP_CALL * call)
+{
+    int i;
+    assert(v != NULL && call != NULL);
+    assert(!vector_contains(v, key));
+#ifdef VECTOR_DEBUG
+    assert(v->key_max < key);
+#endif
+    if (!(v->size < v->alloc)) {
+        void *tmp = realloc(v->item, sizeof(*(v->item)) * 2 * v->alloc);
+        if (tmp != NULL) {
+            v->alloc *= 2;
+            v->item = tmp;
+        } else return FALSE; /* failed to alloc memory. */
+    }
+    assert(v->size < v->alloc);
+    /* for safety, we make this work in the general case;
+     * but this is optimized for adding call to the end of the vector.
+     */
+    for(i = v->size - 1; i >= 0; i--)
+        if (v->item[i].key < key)
+            break;
+    /* insert after item i */
+    memmove(&v->item[i + 2], &v->item[i + 1],
+            (v->size - i - 1) * sizeof(*(v->item)));
+    v->item[i + 1].key  = key;
+    v->item[i + 1].call = call;
+    v->size++;
+#ifdef VECTOR_DEBUG
+    if (v->key_max < key) /* ie, always. */
+        v->key_max = key;
+#endif
+    return TRUE;
+}
+
+/*** vector_remove ************************************************************/
+int  vector_remove(VECTOR *v, int key)
+{
+    struct vector_item *tmp;
+    assert(v != NULL);
+    if ((tmp =binary_search(v,key)) == NULL) return FALSE;
+    assert(tmp >= v->item && tmp < v->item + v->size);
+    memmove(tmp, tmp + 1, (v->size - (v->item - tmp) - 1) * sizeof(*(v->item)));
+    v->size--;
+    return TRUE;
+}
+
+/*** vector_search ************************************************************/
+int  vector_search(VECTOR *v, int key, PPTP_CALL **call)
+{
+    struct vector_item *tmp;
+    assert(v != NULL);
+    tmp = binary_search(v, key);
+    if (tmp ==NULL) return FALSE;
+    *call = tmp->call;
+    return TRUE;
+}
+
+/*** vector_contains **********************************************************/
+int  vector_contains(VECTOR *v, int key)
+{
+    assert(v != NULL);
+    return (binary_search(v, key) != NULL);
+}
+
+/*** vector_item **************************************************************/
+static struct vector_item *binary_search(VECTOR *v, int key)
+{
+    int l,r,x;
+    l = 0;
+    r = v->size - 1;
+    while (r >= l) {
+        x = (l + r)/2;
+        if (key <  v->item[x].key) r = x - 1; else l = x + 1;
+        if (key == v->item[x].key) return &(v->item[x]);
+    }
+    return NULL;
+}
+
+/*** vector_scan ***************************************************************
+ * Hmm.  Let's be fancy and use a binary search for the first
+ * unused key, taking advantage of the list is stored sorted; ie
+ * we can look at pointers and keys at two different locations, 
+ * and if (ptr1 - ptr2) = (key1 - key2) then all the slots
+ * between ptr1 and ptr2 are filled.  Note that ptr1-ptr2 should
+ * never be greater than key1-key2 (no duplicate keys!)... we
+ * check for this.
+ */
+int vector_scan(VECTOR *v, int lo, int hi, int *key)
+{
+    int l,r,x;
+    assert(v != NULL);
+    assert(key != NULL);
+    if ((v->size<1) || (lo < v->item[0].key)) { *key = lo; return TRUE; }
+    /* our array bounds */
+    l = 0;  r = v->size - 1;
+    while (r > l) {
+        /* check for a free spot right after l */
+        if (v->item[l].key + 1 < v->item[l + 1].key) { /* found it! */
+            *key = v->item[l].key + 1;
+            return TRUE;
+        }
+        /* no dice. Let's see if the free spot is before or after the midpoint */
+        x = (l + r)/2;
+        /* Okay, we have right (r), left (l) and the probe (x). */
+        assert(x - l <= v->item[x].key - v->item[l].key);
+        assert(r - x <= v->item[r].key - v->item[x].key);
+        if (x - l < v->item[x].key - v->item[l].key)
+            /* room between l and x */
+            r = x;
+        else /* no room between l and x */
+            if (r - x < v->item[r].key - v->item[x].key)
+                /* room between x and r */
+                l = x;
+            else /* no room between x and r, either */
+                break; /* game over, man. */
+    }
+    /* no room found in already allocated space.  Check to see if
+     * there's free space above allocated entries. */
+    if (v->item[v->size - 1].key < hi) {
+        *key = v->item[v->size - 1].key + 1;
+        return TRUE;
+    }
+    /* outta luck */
+    return FALSE;
+}
+
+/*** vector_get_Nth ***********************************************************/
+PPTP_CALL * vector_get_Nth(VECTOR *v, int n)
+{
+    assert(v != NULL);
+    assert(0 <= n && n < vector_size(v));
+    return v->item[n].call;
+}
diff -uprN ppp-2.4.3.old/pppd/plugins/pptp/vector.h ppp-2.4.3/pppd/plugins/pptp/vector.h
--- ppp-2.4.3.old/pppd/plugins/pptp/vector.h	1970-01-01 03:00:00.000000000 +0300
+++ ppp-2.4.3/pppd/plugins/pptp/vector.h	2008-09-20 22:27:45.000000000 +0400
@@ -0,0 +1,31 @@
+/* vector.h ..... store a vector of PPTP_CALL information and search it
+ *                efficiently.
+ *                C. Scott Ananian <cananian@alumni.princeton.edu>
+ *
+ * $Id: vector.h,v 1.1.1.1 2000/12/23 08:19:51 scott Exp $
+ */
+
+#ifndef INC_VECTOR_H
+#define INC_VECTOR_H
+
+#include "pptp_ctrl.h" /* for definition of PPTP_CALL */
+
+typedef struct vector_struct VECTOR;
+
+VECTOR *vector_create();
+void vector_destroy(VECTOR *v);
+
+int vector_size(VECTOR *v);
+
+/* vector_insert and vector_search return TRUE on success, FALSE on failure. */
+int  vector_insert(VECTOR *v, int key, PPTP_CALL * call);
+int  vector_remove(VECTOR *v, int key);
+int  vector_search(VECTOR *v, int key, PPTP_CALL ** call);
+/* vector_contains returns FALSE if not found, TRUE if found. */
+int  vector_contains(VECTOR *v, int key);
+/* find first unused key. Returns TRUE on success, FALSE if no. */
+int  vector_scan(VECTOR *v, int lo, int hi, int *key);
+/* get a specific PPTP_CALL ... useful only when iterating. */
+PPTP_CALL * vector_get_Nth(VECTOR *v, int n);
+
+#endif /* INC_VECTOR_H */
diff -ruN ppp-2.4.3.orig/pppd/plugins/pptp/pptp.c ppp-2.4.3/pppd/plugins/pptp/pptp.c
--- ppp-2.4.3.orig/pppd/plugins/pptp/pptp.c	1970-01-01 03:00:00.000000000 +0300
+++ ppp-2.4.3/pppd/plugins/pptp/pptp.c	2009-05-19 20:13:18.000000000 +0400
@@ -0,0 +1,328 @@
+/***************************************************************************
+ *   Copyright (C) 2006 by Kozlov D.   *
+ *   xeb@mail.ru   *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <sys/un.h>
+#include <netdb.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <syslog.h>
+#include <unistd.h>
+#include <signal.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <sys/wait.h>
+#include <sys/ioctl.h>
+
+#include "pppd.h"
+#include "fsm.h"
+#include "lcp.h"
+#include "ipcp.h"
+#include "ccp.h"
+#include "pathnames.h"
+#include "patchlevel.h"
+
+#include "pptp_callmgr.h"
+#include <net/if.h>
+#include <net/ethernet.h>
+#include <linux/if_pppox.h>
+
+#include <stdio.h>
+#include <stdlib.h>
+
+extern char** environ;
+
+char pppd_version[] = VERSION;
+extern int new_style_driver;
+
+
+char *pptp_server = NULL;
+char *pptp_client = NULL;
+char *pptp_phone = NULL;
+int pptp_sock=-1;
+struct in_addr localbind = { INADDR_NONE };
+
+static int callmgr_sock;
+static int pptp_fd;
+int call_ID;
+
+//static struct in_addr get_ip_address(char *name);
+static int open_callmgr(int call_id,struct in_addr inetaddr, char *phonenr,int window);
+static void launch_callmgr(int call_is,struct in_addr inetaddr, char *phonenr,int window);
+static int get_call_id(int sock, pid_t gre, pid_t pppd, u_int16_t *peer_call_id);
+
+//static int pptp_devname_hook(char *cmd, char **argv, int doit);
+static option_t Options[] =
+{
+    { "pptp_server", o_string, &pptp_server,
+      "PPTP Server" },
+    { "pptp_client", o_string, &pptp_client,
+      "PPTP Client" },
+    { "pptp_sock",o_int, &pptp_sock,
+      "PPTP socket" },
+    { "pptp_phone", o_string, &pptp_phone,
+      "PPTP Phone number" },
+    { NULL }
+};
+
+static int pptp_connect(void);
+//static void pptp_send_config(int mtu,u_int32_t asyncmap,int pcomp,int accomp);
+//static void pptp_recv_config(int mru,u_int32_t asyncmap,int pcomp,int accomp);
+static void pptp_disconnect(void);
+
+struct channel pptp_channel = {
+    options: Options,
+    //process_extra_options: &PPPOEDeviceOptions,
+    check_options: NULL,
+    connect: &pptp_connect,
+    disconnect: &pptp_disconnect,
+    establish_ppp: &generic_establish_ppp,
+    disestablish_ppp: &generic_disestablish_ppp,
+    //send_config: &pptp_send_config,
+    //recv_config: &pptp_recv_config,
+    close: NULL,
+    cleanup: NULL
+};
+
+static int pptp_start_server(void)
+{
+	pptp_fd=pptp_sock;
+	sprintf(ppp_devnam,"pptp (%s)",pptp_client);
+
+	return pptp_fd;
+}
+static int pptp_start_client(void)
+{
+	int len;
+	struct sockaddr_pppox src_addr,dst_addr;
+	struct hostent *hostinfo;
+
+	hostinfo=gethostbyname(pptp_server);
+  if (!hostinfo)
+	{
+		fatal("PPTP: Unknown host %s\n", pptp_server);
+		return -1;
+	}
+	dst_addr.sa_addr.pptp.sin_addr=*(struct in_addr*)hostinfo->h_addr;
+	{
+		int sock;
+		struct sockaddr_in addr;
+		len=sizeof(addr);
+		addr.sin_addr=dst_addr.sa_addr.pptp.sin_addr;
+		addr.sin_family=AF_INET;
+		addr.sin_port=htons(1700);
+		sock=socket(AF_INET,SOCK_DGRAM,0);
+		if (connect(sock,(struct sockaddr*)&addr,sizeof(addr)))
+		{
+			fatal("PPTP: connect failed (%s)\n",strerror(errno));
+			return -1;
+		}
+		getsockname(sock,(struct sockaddr*)&addr,&len);
+		src_addr.sa_addr.pptp.sin_addr=addr.sin_addr;
+		close(sock);
+	}
+	//info("PPTP: connect server=%s\n",inet_ntoa(conn.sin_addr));
+	//conn.loc_addr.s_addr=INADDR_NONE;
+	//conn.timeout=1;
+	//conn.window=pptp_window;
+
+	src_addr.sa_family=AF_PPPOX;
+	src_addr.sa_protocol=PX_PROTO_PPTP;
+	src_addr.sa_addr.pptp.call_id=0;
+
+	dst_addr.sa_family=AF_PPPOX;
+	dst_addr.sa_protocol=PX_PROTO_PPTP;
+	dst_addr.sa_addr.pptp.call_id=0;
+
+	pptp_fd=socket(AF_PPPOX,SOCK_STREAM,PX_PROTO_PPTP);
+	if (pptp_fd<0)
+	{
+		fatal("PPTP: failed to create PPTP socket (%s)\n",strerror(errno));
+		return -1;
+	}
+	if (bind(pptp_fd,(struct sockaddr*)&src_addr,sizeof(src_addr)))
+	{
+		fatal("PPTP: failed to bind PPTP socket (%s)\n",strerror(errno));
+		return -1;
+	}
+	len=sizeof(src_addr);
+	getsockname(pptp_fd,(struct sockaddr*)&src_addr,&len);
+	call_ID=src_addr.sa_addr.pptp.call_id;
+
+  do {
+        /*
+         * Open connection to call manager (Launch call manager if necessary.)
+         */
+        callmgr_sock = open_callmgr(src_addr.sa_addr.pptp.call_id,dst_addr.sa_addr.pptp.sin_addr, pptp_phone,50);
+        /* Exchange PIDs, get call ID */
+    } while (get_call_id(callmgr_sock, getpid(), getpid(), &dst_addr.sa_addr.pptp.call_id) < 0);
+
+	if (connect(pptp_fd,(struct sockaddr*)&dst_addr,sizeof(dst_addr)))
+	{
+		fatal("PPTP: failed to connect PPTP socket (%s)\n",strerror(errno));
+		return -1;
+	}
+
+	sprintf(ppp_devnam,"pptp (%s)",pptp_server);
+
+	return pptp_fd;
+}
+static int pptp_connect(void)
+{
+	if ((!pptp_server && !pptp_client) || (pptp_server && pptp_client))
+	{
+		fatal("PPTP: unknown mode (you must specify pptp_server or pptp_client option)");
+		return -1;
+	}
+
+	if (pptp_server) return pptp_start_client();
+	return pptp_start_server();
+}
+
+static void pptp_disconnect(void)
+{
+	close(pptp_fd);
+}
+
+static int open_callmgr(int call_id,struct in_addr inetaddr, char *phonenr,int window)
+{
+    /* Try to open unix domain socket to call manager. */
+    struct sockaddr_un where;
+    const int NUM_TRIES = 3;
+    int i, fd;
+    pid_t pid;
+    int status;
+    /* Open socket */
+    if ((fd = socket(AF_UNIX, SOCK_STREAM, 0)) < 0)
+    {
+        fatal("Could not create unix domain socket: %s", strerror(errno));
+    }
+    /* Make address */
+    callmgr_name_unixsock(&where, inetaddr, localbind);
+    for (i = 0; i < NUM_TRIES; i++)
+    {
+        if (connect(fd, (struct sockaddr *) &where, sizeof(where)) < 0)
+        {
+            /* couldn't connect.  We'll have to launch this guy. */
+
+            unlink (where.sun_path);
+
+            /* fork and launch call manager process */
+            switch (pid = fork())
+            {
+                case -1: /* failure */
+                    fatal("fork() to launch call manager failed.");
+                case 0: /* child */
+                {
+                    close (fd);
+                    //close(pptp_fd);
+                    /* close the pty and gre in the call manager */
+                   // close(pty_fd);
+                    //close(gre_fd);
+                    launch_callmgr(call_id,inetaddr, phonenr,window);
+                }
+                default: /* parent */
+                    waitpid(pid, &status, 0);
+                    if (status!= 0)
+                       fatal("Call manager exited with error %d", status);
+                    break;
+            }
+            sleep(1);
+        }
+        else return fd;
+    }
+    close(fd);
+    fatal("Could not launch call manager after %d tries.", i);
+    return -1;   /* make gcc happy */
+}
+
+/*** call the call manager main ***********************************************/
+static void launch_callmgr(int call_id,struct in_addr inetaddr, char *phonenr,int window)
+{
+			char win[10];
+			char call[10];
+      char *my_argv[9] = { "pptp", inet_ntoa(inetaddr), "--call_id",call,"--phone",phonenr,"--window",win,NULL };
+      char buf[128];
+      sprintf(win,"%u",window);
+      sprintf(call,"%u",call_id);
+      snprintf(buf, sizeof(buf), "pptp: call manager for %s", my_argv[1]);
+      //inststr(argc, argv, envp, buf);
+      exit(callmgr_main(8, my_argv, environ));
+}
+
+/*** exchange data with the call manager  *************************************/
+/* XXX need better error checking XXX */
+static int get_call_id(int sock, pid_t gre, pid_t pppd,
+		u_int16_t *peer_call_id)
+{
+    u_int16_t m_call_id, m_peer_call_id;
+    /* write pid's to socket */
+    /* don't bother with network byte order, because pid's are meaningless
+     * outside the local host.
+     */
+    int rc;
+    rc = write(sock, &gre, sizeof(gre));
+    if (rc != sizeof(gre))
+        return -1;
+    rc = write(sock, &pppd, sizeof(pppd));
+    if (rc != sizeof(pppd))
+        return -1;
+    rc = read(sock,  &m_call_id, sizeof(m_call_id));
+    if (rc != sizeof(m_call_id))
+        return -1;
+    rc = read(sock,  &m_peer_call_id, sizeof(m_peer_call_id));
+    if (rc != sizeof(m_peer_call_id))
+        return -1;
+    /*
+     * XXX FIXME ... DO ERROR CHECKING & TIME-OUTS XXX
+     * (Rhialto: I am assuming for now that timeouts are not relevant
+     * here, because the read and write calls would return -1 (fail) when
+     * the peer goes away during the process. We know it is (or was)
+     * running because the connect() call succeeded.)
+     * (James: on the other hand, if the route to the peer goes away, we
+     * wouldn't get told by read() or write() for quite some time.)
+     */
+    *peer_call_id = m_peer_call_id;
+    return 0;
+}
+
+void plugin_init(void)
+{
+    /*if (!ppp_available() && !new_style_driver)
+    {
+				fatal("Linux kernel does not support PPP -- are you running 2.4.x?");
+    }*/
+
+    add_options(Options);
+
+    info("PPTP plugin version %s compiled against pppd %s",
+    	 "0.8.3", VERSION);
+
+    the_channel = &pptp_channel;
+    modem = 0;
+}
+
diff -ruN ppp-2.4.3.orig/pppd/plugins/pptp/pptp_callmgr.c ppp-2.4.3/pppd/plugins/pptp/pptp_callmgr.c
--- ppp-2.4.3.orig/pppd/plugins/pptp/pptp_callmgr.c	1970-01-01 03:00:00.000000000 +0300
+++ ppp-2.4.3/pppd/plugins/pptp/pptp_callmgr.c	2009-05-19 19:49:02.000000000 +0400
@@ -0,0 +1,403 @@
+/* pptp_callmgr.c ... Call manager for PPTP connections.
+ *                    Handles TCP port 1723 protocol.
+ *                    C. Scott Ananian <cananian@alumni.princeton.edu>
+ *
+ * $Id: pptp_callmgr.c,v 1.20 2005/03/31 07:42:39 quozl Exp $
+ */
+#include <signal.h>
+#include <sys/time.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <sys/un.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <string.h>
+#include <assert.h>
+#include <setjmp.h>
+#include <stdio.h>
+#include <errno.h>
+#include "pptp_callmgr.h"
+#include "pptp_ctrl.h"
+#include "pptp_msg.h"
+#include "dirutil.h"
+#include "vector.h"
+#include "util.h"
+
+extern struct in_addr localbind; /* from pptp.c */
+extern int call_ID;
+
+int open_inetsock(struct in_addr inetaddr);
+int open_unixsock(struct in_addr inetaddr);
+void close_inetsock(int fd, struct in_addr inetaddr);
+void close_unixsock(int fd, struct in_addr inetaddr);
+
+sigjmp_buf callmgr_env;
+
+void callmgr_sighandler(int sig) {
+    /* TODO: according to signal(2), siglongjmp() is unsafe used here */
+    siglongjmp (callmgr_env, 1);
+}
+
+void callmgr_do_nothing(int sig) {
+    /* do nothing signal handler */
+}
+
+struct local_callinfo {
+    int unix_sock;
+    pid_t pid[2];
+};
+
+struct local_conninfo {
+    VECTOR * call_list;
+    fd_set * call_set;
+};
+
+/* Call callback */
+void call_callback(PPTP_CONN *conn, PPTP_CALL *call, enum call_state state)
+{
+    struct local_callinfo *lci;
+    struct local_conninfo *conninfo;
+    u_int16_t call_id[2];
+    switch(state) {
+        case CALL_OPEN_DONE:
+            /* okey dokey.  This means that the call_id and peer_call_id are
+             * now valid, so lets send them on to our friends who requested
+             * this call.  */
+            lci = pptp_call_closure_get(conn, call); assert(lci != NULL);
+            pptp_call_get_ids(conn, call, &call_id[0], &call_id[1]);
+            write(lci->unix_sock, &call_id, sizeof(call_id));
+            /* Our duty to the fatherland is now complete. */
+            break;
+        case CALL_OPEN_FAIL:
+        case CALL_CLOSE_RQST:
+        case CALL_CLOSE_DONE:
+            /* don't need to do anything here, except make sure tables
+             * are sync'ed */
+            log("Closing connection (call state)");
+            conninfo = pptp_conn_closure_get(conn);
+            lci = pptp_call_closure_get(conn, call);
+            assert(lci != NULL && conninfo != NULL);
+            if (vector_contains(conninfo->call_list, lci->unix_sock)) {
+                vector_remove(conninfo->call_list, lci->unix_sock);
+                close(lci->unix_sock);
+                FD_CLR(lci->unix_sock, conninfo->call_set);
+                if(lci->pid[0] > 1) kill(lci->pid[0], SIGTERM);
+                if(lci->pid[1] > 1) kill(lci->pid[1], SIGTERM);
+            }
+            break;
+        default:
+            log("Unhandled call callback state [%d].", (int) state);
+            break;
+    }
+}
+
+/******************************************************************************
+ * NOTE ABOUT 'VOLATILE':
+ * several variables here get a volatile qualifier to silence warnings
+ * from older (before 3.0) gccs. if the longjmp stuff is removed,
+ * the volatile qualifiers should be removed as well.
+ *****************************************************************************/
+
+/*** Call Manager *************************************************************/
+int callmgr_main(int argc, char **argv, char **envp)
+{
+    struct in_addr inetaddr;
+    int inet_sock, unix_sock;
+    fd_set call_set;
+    PPTP_CONN * conn;
+    VECTOR * call_list;
+    int max_fd = 0;
+    volatile int first = 1;
+    int retval;
+    int i;
+    char * volatile phonenr=NULL;
+    int volatile window=10;
+    //int volatile call_id=0;
+    /* Step 0: Check arguments */
+    if (argc < 2)
+        fatal("Usage: %s ip.add.ress.here [--phone <phone number>]", argv[0]);
+    //phonenr = argc == 3 ? argv[2] : NULL;
+    for(i=2; i<argc; i++)
+    {
+    	//log("%s",argv[i]);
+    	if (strcmp(argv[i],"--phone")==0 && i+1<argc) phonenr=argv[++i];
+    	else if (strcmp(argv[i],"--window")==0 && i+1<argc) window=atoi(argv[++i]);
+    	else if (strcmp(argv[i],"--call_id")==0 && i+1<argc) call_ID=atoi(argv[++i]);
+    }
+    if (inet_aton(argv[1], &inetaddr) == 0)
+        fatal("Invalid IP address: %s", argv[1]);
+     log("IP: %s\n",inet_ntoa(inetaddr));
+    /* Step 1: Open sockets. */
+    if ((inet_sock = open_inetsock(inetaddr)) < 0)
+        fatal("Could not open control connection to %s", argv[1]);
+    log("control connection");
+    if ((unix_sock = open_unixsock(inetaddr)) < 0)
+        fatal("Could not open unix socket for %s", argv[1]);
+    /* Step 1b: FORK and return status to calling process. */
+    log("unix_sock");
+
+    switch (fork()) {
+        case 0: /* child. stick around. */
+            break;
+        case -1: /* failure.  Fatal. */
+            fatal("Could not fork.");
+        default: /* Parent. Return status to caller. */
+            exit(0);
+    }
+    /* re-open stderr as /dev/null to release it */
+    file2fd("/dev/null", "wb", STDERR_FILENO);
+    /* Step 1c: Clean up unix socket on TERM */
+    if (sigsetjmp(callmgr_env, 1) != 0)
+        goto cleanup;
+    signal(SIGINT, callmgr_sighandler);
+    signal(SIGTERM, callmgr_sighandler);
+    signal(SIGPIPE, callmgr_do_nothing);
+    signal(SIGUSR1, callmgr_do_nothing); /* signal state change
+                                            wake up accept */
+    /* Step 2: Open control connection and register callback */
+    if ((conn = pptp_conn_open(inet_sock, 1, NULL/* callback */)) == NULL) {
+        close(unix_sock); close(inet_sock); fatal("Could not open connection.");
+    }
+    FD_ZERO(&call_set);
+    call_list = vector_create();
+    {
+        struct local_conninfo *conninfo = malloc(sizeof(*conninfo));
+        if (conninfo == NULL) {
+            close(unix_sock); close(inet_sock); fatal("No memory.");
+        }
+        conninfo->call_list = call_list;
+        conninfo->call_set  = &call_set;
+        pptp_conn_closure_put(conn, conninfo);
+    }
+    if (sigsetjmp(callmgr_env, 1) != 0) goto shutdown;
+    /* Step 3: Get FD_SETs */
+    max_fd = unix_sock;
+    do {
+        int rc;
+        fd_set read_set = call_set, write_set;
+        FD_ZERO (&write_set);
+        if (pptp_conn_established(conn)) {
+	  FD_SET (unix_sock, &read_set);
+	  if (unix_sock > max_fd) max_fd = unix_sock;
+	}
+        pptp_fd_set(conn, &read_set, &write_set, &max_fd);
+        for (; max_fd > 0 ; max_fd--) {
+            if (FD_ISSET (max_fd, &read_set) ||
+                    FD_ISSET (max_fd, &write_set))
+                break;
+        }
+        /* Step 4: Wait on INET or UNIX event */
+        if ((rc = select(max_fd + 1, &read_set, &write_set, NULL, NULL)) <0) {
+	  if (errno == EBADF) break;
+	  /* a signal or somesuch. */
+	  continue;
+	}
+        /* Step 5a: Handle INET events */
+        rc = pptp_dispatch(conn, &read_set, &write_set);
+	if (rc < 0)
+	    break;
+        /* Step 5b: Handle new connection to UNIX socket */
+        if (FD_ISSET(unix_sock, &read_set)) {
+            /* New call! */
+            struct sockaddr_un from;
+            int len = sizeof(from);
+            PPTP_CALL * call;
+            struct local_callinfo *lci;
+            int s;
+            /* Accept the socket */
+            FD_CLR (unix_sock, &read_set);
+            if ((s = accept(unix_sock, (struct sockaddr *) &from, &len)) < 0) {
+                warn("Socket not accepted: %s", strerror(errno));
+                goto skip_accept;
+            }
+            /* Allocate memory for local call information structure. */
+            if ((lci = malloc(sizeof(*lci))) == NULL) {
+                warn("Out of memory."); close(s); goto skip_accept;
+            }
+            lci->unix_sock = s;
+            /* Give the initiator time to write the PIDs while we open
+             * the call */
+            call = pptp_call_open(conn, call_ID,call_callback, phonenr,window);
+            /* Read and store the associated pids */
+            read(s, &lci->pid[0], sizeof(lci->pid[0]));
+            read(s, &lci->pid[1], sizeof(lci->pid[1]));
+            /* associate the local information with the call */
+            pptp_call_closure_put(conn, call, (void *) lci);
+            /* The rest is done on callback. */
+            /* Keep alive; wait for close */
+            retval = vector_insert(call_list, s, call); assert(retval);
+            if (s > max_fd) max_fd = s;
+            FD_SET(s, &call_set);
+            first = 0;
+        }
+skip_accept: /* Step 5c: Handle socket close */
+        for (i = 0; i < max_fd + 1; i++)
+            if (FD_ISSET(i, &read_set)) {
+                /* close it */
+                PPTP_CALL * call;
+                retval = vector_search(call_list, i, &call);
+                if (retval) {
+                    struct local_callinfo *lci =
+                        pptp_call_closure_get(conn, call);
+                    log("Closing connection (unhandled)");
+                    if(lci->pid[0] > 1) kill(lci->pid[0], SIGTERM);
+                    if(lci->pid[1] > 1) kill(lci->pid[1], SIGTERM);
+                    free(lci);
+                    /* soft shutdown.  Callback will do hard shutdown later */
+                    pptp_call_close(conn, call);
+                    vector_remove(call_list, i);
+                }
+                FD_CLR(i, &call_set);
+                close(i);
+            }
+    } while (vector_size(call_list) > 0 || first);
+shutdown:
+    {
+        int rc;
+        fd_set read_set, write_set;
+        struct timeval tv;
+	signal(SIGINT, callmgr_do_nothing);
+	signal(SIGTERM, callmgr_do_nothing);
+        /* warn("Shutdown"); */
+        /* kill all open calls */
+        for (i = 0; i < vector_size(call_list); i++) {
+            PPTP_CALL *call = vector_get_Nth(call_list, i);
+            struct local_callinfo *lci = pptp_call_closure_get(conn, call);
+            log("Closing connection (shutdown)");
+            pptp_call_close(conn, call);
+            if(lci->pid[0] > 1) kill(lci->pid[0], SIGTERM);
+            if(lci->pid[1] > 1) kill(lci->pid[1], SIGTERM);
+        }
+        /* attempt to dispatch these messages */
+        FD_ZERO(&read_set);
+        FD_ZERO(&write_set);
+        pptp_fd_set(conn, &read_set, &write_set, &max_fd);
+	tv.tv_sec = 0;
+	tv.tv_usec = 0;
+	select(max_fd + 1, &read_set, &write_set, NULL, &tv);
+        rc = pptp_dispatch(conn, &read_set, &write_set);
+	if (rc > 0) {
+	  /* wait for a respond, a timeout because there might not be one */
+	  FD_ZERO(&read_set);
+	  FD_ZERO(&write_set);
+	  pptp_fd_set(conn, &read_set, &write_set, &max_fd);
+	  tv.tv_sec = 2;
+	  tv.tv_usec = 0;
+	  select(max_fd + 1, &read_set, &write_set, NULL, &tv);
+	  rc = pptp_dispatch(conn, &read_set, &write_set);
+	  if (rc > 0) {
+	    if (i > 0) sleep(2);
+	    /* no more open calls.  Close the connection. */
+	    pptp_conn_close(conn, PPTP_STOP_LOCAL_SHUTDOWN);
+	    /* wait for a respond, a timeout because there might not be one */
+	    FD_ZERO(&read_set);
+	    FD_ZERO(&write_set);
+	    pptp_fd_set(conn, &read_set, &write_set, &max_fd);
+	    tv.tv_sec = 2;
+	    tv.tv_usec = 0;
+	    select(max_fd + 1, &read_set, &write_set, NULL, &tv);
+	    pptp_dispatch(conn, &read_set, &write_set);
+	    if (rc > 0) sleep(2);
+	  }
+	}
+        /* with extreme prejudice */
+        pptp_conn_destroy(conn);
+        vector_destroy(call_list);
+    }
+cleanup:
+    signal(SIGINT, callmgr_do_nothing);
+    signal(SIGTERM, callmgr_do_nothing);
+    close_inetsock(inet_sock, inetaddr);
+    close_unixsock(unix_sock, inetaddr);
+    return 0;
+}
+
+/*** open_inetsock ************************************************************/
+int open_inetsock(struct in_addr inetaddr)
+{
+    struct sockaddr_in dest, src;
+    int s;
+    dest.sin_family = AF_INET;
+    dest.sin_port   = htons(PPTP_PORT);
+    dest.sin_addr   = inetaddr;
+    if ((s = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
+        warn("socket: %s", strerror(errno));
+        return s;
+    }
+    if (localbind.s_addr != INADDR_NONE) {
+        bzero(&src, sizeof(src));
+        src.sin_family = AF_INET;
+        src.sin_addr   = localbind;
+        if (bind(s, (struct sockaddr *) &src, sizeof(src)) != 0) {
+            warn("bind: %s", strerror(errno));
+            close(s); return -1;
+        }
+    }
+    if (connect(s, (struct sockaddr *) &dest, sizeof(dest)) < 0) {
+        warn("connect: %s", strerror(errno));
+        close(s); return -1;
+    }
+    return s;
+}
+
+/*** open_unixsock ************************************************************/
+int open_unixsock(struct in_addr inetaddr)
+{
+    struct sockaddr_un where;
+    struct stat st;
+    char *dir;
+    int s;
+    if ((s = socket(AF_UNIX, SOCK_STREAM, 0)) < 0) {
+        warn("socket: %s", strerror(errno));
+        return s;
+    }
+    callmgr_name_unixsock( &where, inetaddr, localbind);
+    if (stat(where.sun_path, &st) >= 0)
+    {
+        warn("Call manager for %s is already running.", inet_ntoa(inetaddr));
+        close(s); return -1;
+    }
+   /* Make sure path is valid. */
+    dir = dirnamex(where.sun_path);
+    if (!make_valid_path(dir, 0770))
+        fatal("Could not make path to %s: %s", where.sun_path, strerror(errno));
+    free(dir);
+    if (bind(s, (struct sockaddr *) &where, sizeof(where)) < 0) {
+        warn("bind: %s", strerror(errno));
+        close(s); return -1;
+    }
+    chmod(where.sun_path, 0777);
+    listen(s, 127);
+    return s;
+}
+
+/*** close_inetsock ***********************************************************/
+void close_inetsock(int fd, struct in_addr inetaddr)
+{
+    close(fd);
+}
+
+/*** close_unixsock ***********************************************************/
+void close_unixsock(int fd, struct in_addr inetaddr)
+{
+    struct sockaddr_un where;
+    close(fd);
+    callmgr_name_unixsock(&where, inetaddr, localbind);
+    unlink(where.sun_path);
+}
+
+/*** make a unix socket address ***********************************************/
+void callmgr_name_unixsock(struct sockaddr_un *where,
+			   struct in_addr inetaddr,
+			   struct in_addr localbind)
+{
+    char localaddr[16], remoteaddr[16];
+    where->sun_family = AF_UNIX;
+    strncpy(localaddr,  inet_ntoa(localbind), 16);
+    strncpy(remoteaddr, inet_ntoa(inetaddr),  16);
+    snprintf(where->sun_path, sizeof(where->sun_path),
+            PPTP_SOCKET_PREFIX "%s:%i", remoteaddr,call_ID);
+}
diff -uprN ppp-2.4.3.old/pppd/plugins/pppol2tp/pppol2tp.c ppp-2.4.3/pppd/plugins/pppol2tp/pppol2tp.c
--- ppp-2.4.3.old/pppd/plugins/pppol2tp/pppol2tp.c	1970-01-01 03:00:00.000000000 +0300
+++ ppp-2.4.3/pppd/plugins/pppol2tp/pppol2tp.c	2008-09-20 22:45:11.000000000 +0400
@@ -0,0 +1,507 @@
+/* pppol2tp.c - pppd plugin to implement PPPoL2TP protocol
+ *   for Linux using kernel pppol2tp support.
+ *
+ * Requires kernel pppol2tp driver which is distributed with
+ * OpenL2TP at http://www.sourceforge.net/projects/openl2tp/
+ *
+ * By Martijn van Oosterhout <kleptog@svana.org>
+ * Modified for OpenL2TP by jchapman@katalix.com
+ *
+ * Heavily based upon pppoatm.c: original notice follows
+ *
+ * Copyright 2000 Mitchell Blank Jr.
+ * Based in part on work from Jens Axboe and Paul Mackerras.
+ * Updated to ppp-2.4.1 by Bernhard Kaindl
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License
+ *  as published by the Free Software Foundation; either version
+ *  2 of the License, or (at your option) any later version.
+ */
+#include <unistd.h>
+#include <string.h>
+#include <stdlib.h>
+#include <errno.h>
+#include "pppd.h"
+#include "pathnames.h"
+#include "fsm.h"
+#include "lcp.h"
+#include "ccp.h"
+#include "ipcp.h"
+#include <sys/stat.h>
+#include <net/if.h>
+#include <sys/ioctl.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <signal.h>
+#include <linux/version.h>
+#include <linux/sockios.h>
+#ifndef aligned_u64
+/* should be defined in sys/types.h */
+#define aligned_u64 unsigned long long __attribute__((aligned(8)))
+#endif
+#include <linux/types.h>
+#include <linux/if_ether.h>
+#include <linux/ppp_defs.h>
+#include <linux/if_ppp.h>
+#include <linux/if_pppox.h>
+#include <linux/if_pppol2tp.h>
+
+/* should be added to system's socket.h... */
+#ifndef SOL_PPPOL2TP
+#define SOL_PPPOL2TP	273
+#endif
+
+const char pppd_version[] = VERSION;
+
+static int setdevname_pppol2tp(char **argv);
+
+static int pppol2tp_fd = -1;
+static char *pppol2tp_fd_str;
+static bool pppol2tp_lns_mode = 0;
+static bool pppol2tp_recv_seq = 0;
+static bool pppol2tp_send_seq = 0;
+static int pppol2tp_debug_mask = 0;
+static int pppol2tp_reorder_timeout = 0;
+static char pppol2tp_ifname[32] = { 0, };
+int pppol2tp_tunnel_id = 0;
+int pppol2tp_session_id = 0;
+
+static int device_got_set = 0;
+struct channel pppol2tp_channel;
+
+static void (*old_snoop_recv_hook)(unsigned char *p, int len) = NULL;
+static void (*old_snoop_send_hook)(unsigned char *p, int len) = NULL;
+static void (*old_ip_up_hook)(void) = NULL;
+static void (*old_ip_down_hook)(void) = NULL;
+
+/* Hook provided to allow other plugins to handle ACCM changes */
+void (*pppol2tp_send_accm_hook)(int tunnel_id, int session_id, uint32_t send_accm, uint32_t recv_accm) = NULL;
+
+/* Hook provided to allow other plugins to handle IP up/down */
+void (*pppol2tp_ip_updown_hook)(int tunnel_id, int session_id, int up) = NULL;
+
+static option_t pppol2tp_options[] = {
+	{ "pppol2tp", o_special, &setdevname_pppol2tp,
+	  "FD for PPPoL2TP socket", OPT_DEVNAM | OPT_A2STRVAL,
+          &pppol2tp_fd_str },
+	{ "pppol2tp_lns_mode", o_bool, &pppol2tp_lns_mode,
+	  "PPPoL2TP LNS behavior. Default off.", 
+	  OPT_PRIO | OPRIO_CFGFILE },
+	{ "pppol2tp_send_seq", o_bool, &pppol2tp_send_seq,
+	  "PPPoL2TP enable sequence numbers in transmitted data packets. Default off.", 
+	  OPT_PRIO | OPRIO_CFGFILE },
+	{ "pppol2tp_recv_seq", o_bool, &pppol2tp_recv_seq,
+	  "PPPoL2TP enforce sequence numbers in received data packets. Default off.", 
+	  OPT_PRIO | OPRIO_CFGFILE },
+	{ "pppol2tp_reorderto", o_int, &pppol2tp_reorder_timeout,
+	  "PPPoL2TP data packet reorder timeout. Default 0 (no reordering).", 
+	  OPT_PRIO },
+	{ "pppol2tp_debug_mask", o_int, &pppol2tp_debug_mask,
+	  "PPPoL2TP debug mask. Default: no debug.", 
+	  OPT_PRIO },
+	{ "pppol2tp_ifname", o_string, &pppol2tp_ifname,
+	  "Set interface name of PPP interface",
+	  OPT_PRIO | OPT_PRIV | OPT_STATIC, NULL, 16 },
+	{ "pppol2tp_tunnel_id", o_int, &pppol2tp_tunnel_id,
+	  "PPPoL2TP tunnel_id.", 
+	  OPT_PRIO },
+	{ "pppol2tp_session_id", o_int, &pppol2tp_session_id,
+	  "PPPoL2TP session_id.", 
+	  OPT_PRIO },
+	{ NULL }
+};
+
+static int setdevname_pppol2tp(char **argv)
+{
+	union {
+		char buffer[128];
+		struct sockaddr pppol2tp;
+	} s;
+	struct sockaddr_pppol2tp sax;
+	int len = sizeof(s);
+	char **a;
+	int tmp;
+	int tmp_len = sizeof(tmp);
+
+	if (device_got_set)
+		return 0;
+		
+	if (!int_option(*argv, &pppol2tp_fd))
+		return 0;
+	                
+	if(getsockname(pppol2tp_fd, (struct sockaddr *)&s, &len) < 0) {
+		fatal("Given FD for PPPoL2TP socket invalid (%s)", strerror(errno));
+	}
+	if(s.pppol2tp.sa_family != AF_PPPOX) {
+		fatal("Socket of not a PPPoX socket");
+	}
+	memset(&sax, 0, sizeof(sax));
+	memcpy(&sax, &s.pppol2tp, sizeof(sax));
+	sprintf(ppp_devnam, "l2tp (%s)", inet_ntoa(sax.pppol2tp.addr.sin_addr));
+	/* Do a test getsockopt() to ensure that the kernel has the necessary 
+	 * feature available. 
+	 */
+	if (getsockopt(pppol2tp_fd, SOL_PPPOL2TP, PPPOL2TP_SO_DEBUG, &tmp, &tmp_len) < 0) {
+		fatal("PPPoL2TP kernel driver not installed");
+	}
+
+	/* Setup option defaults. Compression options are disabled! */
+	
+#ifndef _DISABLE_SERIAL_
+	modem = 0;
+#endif
+
+	lcp_allowoptions[0].neg_accompression = 1;
+	lcp_wantoptions[0].neg_accompression = 0;
+
+	lcp_allowoptions[0].neg_pcompression = 1;
+	lcp_wantoptions[0].neg_pcompression = 0;
+
+#ifdef CCP_SUPPORT
+	ccp_allowoptions[0].deflate = 0;
+	ccp_wantoptions[0].deflate = 0;
+#endif
+
+	ipcp_allowoptions[0].neg_vj = 0;
+	ipcp_wantoptions[0].neg_vj = 0;
+
+#ifdef CCP_SUPPORT
+	ccp_allowoptions[0].bsd_compress = 0;
+	ccp_wantoptions[0].bsd_compress = 0;
+#endif
+
+	the_channel = &pppol2tp_channel;
+	device_got_set = 1;
+
+	return 1;
+}
+
+static int connect_pppol2tp(void)
+{
+	if(pppol2tp_fd == -1) {
+		fatal("No PPPoL2TP FD specified");
+	}
+
+	return pppol2tp_fd;
+}
+
+static void disconnect_pppol2tp(void)
+{
+	if (pppol2tp_fd >= 0) {
+		close(pppol2tp_fd);
+		pppol2tp_fd = -1;
+	}
+}
+
+static void send_config_pppol2tp(int mtu,
+			      u_int32_t asyncmap,
+			      int pcomp,
+			      int accomp)
+{
+	struct ifreq ifr;
+	int on = 1;
+	int fd;
+	char reorderto[16];
+	char tid[8];
+	char sid[8];
+
+	if (pppol2tp_ifname[0]) {
+		struct ifreq ifr;
+		int fd;
+
+		fd = socket(AF_INET, SOCK_DGRAM, 0);
+		if (fd >= 0) {
+			memset (&ifr, '\0', sizeof (ifr));
+			strlcpy(ifr.ifr_name, ifname, sizeof(ifr.ifr_name));
+			strlcpy(ifr.ifr_newname, pppol2tp_ifname, sizeof(ifr.ifr_name));
+			ioctl(fd, SIOCSIFNAME, (caddr_t) &ifr);
+			strlcpy(ifname, pppol2tp_ifname, 32);
+			if (pppol2tp_debug_mask & PPPOL2TP_MSG_CONTROL) {
+				dbglog("ppp%d: interface name %s", ifunit, ifname);
+			}
+		}
+		close(fd);
+	}
+
+	if ((lcp_allowoptions[0].mru > 0) && (mtu > lcp_allowoptions[0].mru)) {
+		warn("Overriding mtu %d to %d", mtu, lcp_allowoptions[0].mru);
+		mtu = lcp_allowoptions[0].mru;
+	}
+	netif_set_mtu(ifunit, mtu);
+
+	reorderto[0] = '\0';
+	if (pppol2tp_reorder_timeout > 0)
+		sprintf(&reorderto[0], "%d ", pppol2tp_reorder_timeout);
+	tid[0] = '\0';
+	if (pppol2tp_tunnel_id > 0)
+		sprintf(&tid[0], "%hu ", pppol2tp_tunnel_id);
+	sid[0] = '\0';
+	if (pppol2tp_session_id > 0)
+		sprintf(&sid[0], "%hu ", pppol2tp_session_id);
+		
+	dbglog("PPPoL2TP options: %s%s%s%s%s%s%s%s%sdebugmask %d", 
+	       pppol2tp_recv_seq ? "recvseq " : "",
+	       pppol2tp_send_seq ? "sendseq " : "",
+	       pppol2tp_lns_mode ? "lnsmode " : "",
+	       pppol2tp_reorder_timeout ? "reorderto " : "", reorderto,
+	       pppol2tp_tunnel_id ? "tid " : "", tid,
+	       pppol2tp_session_id ? "sid " : "", sid,
+	       pppol2tp_debug_mask);
+
+	if (pppol2tp_recv_seq)
+		if (setsockopt(pppol2tp_fd, SOL_PPPOL2TP, PPPOL2TP_SO_RECVSEQ, &on, sizeof(on)) < 0)
+			fatal("setsockopt(PPPOL2TP_RECVSEQ): %m");
+	if (pppol2tp_send_seq)
+		if (setsockopt(pppol2tp_fd, SOL_PPPOL2TP, PPPOL2TP_SO_SENDSEQ, &on, sizeof(on)) < 0)
+			fatal("setsockopt(PPPOL2TP_SENDSEQ): %m");
+	if (pppol2tp_lns_mode)
+		if (setsockopt(pppol2tp_fd, SOL_PPPOL2TP, PPPOL2TP_SO_LNSMODE, &on, sizeof(on)) < 0)
+			fatal("setsockopt(PPPOL2TP_LNSMODE): %m");
+	if (pppol2tp_reorder_timeout)
+		if (setsockopt(pppol2tp_fd, SOL_PPPOL2TP, PPPOL2TP_SO_REORDERTO, &pppol2tp_reorder_timeout, sizeof(pppol2tp_reorder_timeout)) < 0)
+			fatal("setsockopt(PPPOL2TP_REORDERTO): %m");
+	if (pppol2tp_debug_mask)
+		if (setsockopt(pppol2tp_fd, SOL_PPPOL2TP, PPPOL2TP_SO_DEBUG, &pppol2tp_debug_mask, sizeof(pppol2tp_debug_mask)) < 0)
+			fatal("setsockopt(PPPOL2TP_DEBUG): %m");
+}
+
+static void recv_config_pppol2tp(int mru,
+			      u_int32_t asyncmap,
+			      int pcomp,
+			      int accomp)
+{
+	if ((lcp_allowoptions[0].mru > 0) && (mru > lcp_allowoptions[0].mru)) {
+		warn("Overriding mru %d to mtu value %d", mru, lcp_allowoptions[0].mru);
+		mru = lcp_allowoptions[0].mru;
+	}
+	if ((ifunit >= 0) && ioctl(pppol2tp_fd, PPPIOCSMRU, (caddr_t) &mru) < 0)
+		error("Couldn't set PPP MRU: %m");
+}
+
+/*****************************************************************************
+ * Snoop LCP message exchanges to capture negotiated ACCM values.
+ * When asyncmap values have been seen from both sides, give the values to
+ * L2TP.
+ * This code is derived from Roaring Penguin L2TP.
+ *****************************************************************************/
+
+static void pppol2tp_lcp_snoop(unsigned char *buf, int len, int incoming)
+{
+	static bool got_send_accm = 0;
+	static bool got_recv_accm = 0;
+	static uint32_t recv_accm = 0xffffffff;
+	static uint32_t send_accm = 0xffffffff;
+	static bool snooping = 1;
+
+	uint16_t protocol;
+	uint16_t lcp_pkt_len;
+	int opt, opt_len;
+	int reject;
+	unsigned char const *opt_data;
+	uint32_t accm;
+
+	/* Skip HDLC header */
+	buf += 2;
+	len -= 2;
+
+	/* Unreasonably short frame?? */
+	if (len <= 0) return;	
+
+	/* Get protocol */
+	if (buf[0] & 0x01) {
+		/* Compressed protcol field */
+		protocol = buf[0];
+	} else {
+		protocol = ((unsigned int) buf[0]) * 256 + buf[1];
+	}
+
+	/* If it's a network protocol, stop snooping */
+	if (protocol <= 0x3fff) {
+		if (pppol2tp_debug_mask & PPPOL2TP_MSG_DEBUG) {
+			dbglog("Turning off snooping: Network protocol %04x found.", protocol);
+		}
+		snooping = 0;
+		return;
+	}
+
+	/* If it's not LCP, do not snoop */
+	if (protocol != 0xc021) {
+		return;
+	}
+
+	/* Skip protocol; go to packet data */
+	buf += 2;
+	len -= 2;
+
+	/* Unreasonably short frame?? */
+	if (len <= 0) return;
+
+	/* Look for Configure-Ack or Configure-Reject code */
+	if (buf[0] != CONFACK && buf[0] != CONFREJ) return;
+
+	reject = (buf[0] == CONFREJ);
+
+	lcp_pkt_len = ((unsigned int) buf[2]) * 256 + buf[3];
+
+	/* Something fishy with length field? */
+	if (lcp_pkt_len > len) return;
+
+	/* Skip to options */
+	len = lcp_pkt_len - 4;
+	buf += 4;
+
+	while (len > 0) {
+		/* Pull off an option */
+		opt = buf[0];
+		opt_len = buf[1];
+		opt_data = &buf[2];
+		if (opt_len > len || opt_len < 2) break;
+		len -= opt_len;
+		buf += opt_len;
+		if (pppol2tp_debug_mask & PPPOL2TP_MSG_DEBUG) {
+			dbglog("Found option type %02x; len %d", opt, opt_len);
+		}
+
+		/* We are specifically interested in ACCM */
+		if (opt == CI_ASYNCMAP && opt_len == 0x06) {
+			if (reject) {
+				/* ACCM negotiation REJECTED; use default */
+				accm = 0xffffffff;
+				if (pppol2tp_debug_mask & PPPOL2TP_MSG_DATA) {
+					dbglog("Rejected ACCM negotiation; defaulting (%s)", incoming ? "incoming" : "outgoing");
+				}
+				recv_accm = accm;
+				send_accm = accm;
+				got_recv_accm = 1;
+				got_send_accm = 1;
+			} else {
+				memcpy(&accm, opt_data, sizeof(accm));
+				if (pppol2tp_debug_mask & PPPOL2TP_MSG_DATA) {
+					dbglog("Found ACCM of %08x (%s)", accm, incoming ? "incoming" : "outgoing");
+				}
+				if (incoming) {
+					recv_accm = accm;
+					got_recv_accm = 1;
+				} else {
+					send_accm = accm;
+					got_send_accm = 1;
+				}
+			}
+
+			if (got_recv_accm && got_send_accm) {
+				if (pppol2tp_debug_mask & PPPOL2TP_MSG_CONTROL) {
+					dbglog("Telling L2TP: Send ACCM = %08x; Receive ACCM = %08x", send_accm, recv_accm);
+				}
+				if (pppol2tp_send_accm_hook != NULL) {
+					(*pppol2tp_send_accm_hook)(pppol2tp_tunnel_id, pppol2tp_session_id, send_accm, recv_accm);
+				}
+				got_recv_accm = 0;
+				got_send_accm = 0;
+			}
+		}
+	}
+}
+
+static void pppol2tp_lcp_snoop_recv(unsigned char *p, int len)
+{
+	if (old_snoop_recv_hook != NULL)
+		(*old_snoop_recv_hook)(p, len);
+	pppol2tp_lcp_snoop(p, len, 1);
+}
+
+static void pppol2tp_lcp_snoop_send(unsigned char *p, int len)
+{
+	if (old_snoop_send_hook != NULL)
+		(*old_snoop_send_hook)(p, len);
+	pppol2tp_lcp_snoop(p, len, 0);
+}
+
+/*****************************************************************************
+ * Interface up/down events
+ *****************************************************************************/
+
+static void pppol2tp_ip_up_hook(void)
+{
+	if (old_ip_up_hook != NULL)
+		(*old_ip_up_hook)();
+
+	if (pppol2tp_ip_updown_hook != NULL) {
+		(*pppol2tp_ip_updown_hook)(pppol2tp_tunnel_id, pppol2tp_session_id, 1);
+	}
+}
+
+static void pppol2tp_ip_down_hook(void)
+{
+	if (old_ip_down_hook != NULL)
+		(*old_ip_down_hook)();
+
+	if (pppol2tp_ip_updown_hook != NULL) {
+		(*pppol2tp_ip_updown_hook)(pppol2tp_tunnel_id, pppol2tp_session_id, 0);
+	}
+}
+
+/*****************************************************************************
+ * Application init
+ *****************************************************************************/
+
+static void pppol2tp_check_options(void)
+{
+	/* Enable LCP snooping for ACCM options only for LNS */
+	if (pppol2tp_lns_mode) {
+		if ((pppol2tp_tunnel_id == 0) || (pppol2tp_session_id == 0)) {
+			fatal("tunnel_id/session_id values not specified");
+		}
+		if (pppol2tp_debug_mask & PPPOL2TP_MSG_CONTROL) {
+			dbglog("Enabling LCP snooping");
+		}
+		old_snoop_recv_hook = snoop_recv_hook;
+		old_snoop_send_hook = snoop_send_hook;
+
+		snoop_recv_hook = pppol2tp_lcp_snoop_recv;
+		snoop_send_hook = pppol2tp_lcp_snoop_send;
+	}
+
+	/* Hook up ip up/down hooks to send indicator to openl2tpd that the link is up */
+	old_ip_up_hook = ip_up_hook;
+	ip_up_hook = pppol2tp_ip_up_hook;
+	old_ip_down_hook = ip_down_hook;
+	ip_down_hook = pppol2tp_ip_down_hook;
+}
+
+/* Called just before pppd exits.
+ */
+static void pppol2tp_cleanup(void)
+{
+	if (pppol2tp_debug_mask & PPPOL2TP_MSG_DEBUG) {
+		dbglog("pppol2tp: exiting.");
+	}
+	disconnect_pppol2tp();
+}
+
+void plugin_init(void)
+{
+#if defined(__linux__)
+	extern int new_style_driver;	/* From sys-linux.c */
+	if (!ppp_available() && !new_style_driver)
+		fatal("Kernel doesn't support ppp_generic - "
+		    "needed for PPPoL2TP");
+#else
+	fatal("No PPPoL2TP support on this OS");
+#endif
+	add_options(pppol2tp_options);
+}
+
+struct channel pppol2tp_channel = {
+    options: pppol2tp_options,
+    process_extra_options: NULL,
+    check_options: &pppol2tp_check_options,
+    connect: &connect_pppol2tp,
+    disconnect: &disconnect_pppol2tp,
+    establish_ppp: &generic_establish_ppp,
+    disestablish_ppp: &generic_disestablish_ppp,
+    send_config: &send_config_pppol2tp,
+    recv_config: &recv_config_pppol2tp,
+    close: NULL,
+    cleanup: NULL
+};
diff -uprN ppp-2.4.3.old/include/linux/if_pppox.h ppp-2.4.3/include/linux/if_pppox.h
--- ppp-2.4.3.old/include/linux/if_pppox.h	2008-09-20 22:27:34.000000000 +0400
+++ ppp-2.4.3/include/linux/if_pppox.h	2008-09-20 22:27:45.000000000 +0400
@@ -1,6 +1,6 @@
 /***************************************************************************
  * Linux PPP over X - Generic PPP transport layer sockets
- * Linux PPP over Ethernet (PPPoE) Socket Implementation (RFC 2516) 
+ * Linux PPP over Ethernet (PPPoE) Socket Implementation (RFC 2516)
  *
  * This file supplies definitions required by the PPP over Ethernet driver
  * (pppox.c).  All version information wrt this file is located in pppox.c
@@ -18,16 +18,29 @@
 
 
 #include <asm/types.h>
+#ifdef __KERNEL__
 #include <asm/byteorder.h>
+#else
+#include <endian.h>
+#include <byteswap.h>
+#if __BYTE_ORDER == __LITTLE_ENDIAN
+#define __LITTLE_ENDIAN_BITFIELD
+#elif __BYTE_ORDER == __BIG_ENDIAN
+#define __BIG_ENDIAN_BITFIELD
+#else
+#error "Adjust your <endian.h> defines."
+#endif
+#endif
+//#include <linux/in.h>
 
-#ifdef  __KERNEL__
+#ifdef	__KERNEL__
 #include <linux/if_ether.h>
 #include <linux/if.h>
 #include <linux/netdevice.h>
-#include <linux/sched.h>
 #include <asm/semaphore.h>
 #include <linux/ppp_channel.h>
 #endif /* __KERNEL__ */
+#include "if_pppol2tp.h"
 
 /* For user-space programs to pick up these definitions
  * which they wouldn't get otherwise without defining __KERNEL__
@@ -37,30 +50,48 @@
 #define PF_PPPOX	AF_PPPOX
 #endif /* !(AF_PPPOX) */
 
-/************************************************************************ 
- * PPPoE addressing definition 
- */ 
-typedef __u16 sid_t; 
-struct pppoe_addr{ 
-       sid_t           sid;                    /* Session identifier */ 
-       unsigned char   remote[ETH_ALEN];       /* Remote address */ 
-       char            dev[IFNAMSIZ];          /* Local device to use */ 
-}; 
- 
-/************************************************************************ 
- * Protocols supported by AF_PPPOX 
- */ 
-#define PX_PROTO_OE    0 /* Currently just PPPoE */
-#define PX_MAX_PROTO   1	
- 
-struct sockaddr_pppox { 
-       sa_family_t     sa_family;            /* address family, AF_PPPOX */ 
-       unsigned int    sa_protocol;          /* protocol identifier */ 
-       union{ 
-               struct pppoe_addr       pppoe; 
-       }sa_addr; 
-}__attribute__ ((packed)); 
+/************************************************************************
+ * PPPoE addressing definition
+ */
+typedef __u16 sid_t;
+struct pppoe_addr{
+       sid_t           sid;                    /* Session identifier */
+       unsigned char   remote[ETH_ALEN];       /* Remote address */
+       char            dev[IFNAMSIZ];          /* Local device to use */
+};
 
+struct pptp_addr{
+       __u16           call_id;
+       struct in_addr  sin_addr;
+       __u32           magic_num;
+};
+/************************************************************************
+ * Protocols supported by AF_PPPOX
+ */
+#define PX_PROTO_OE    0 /* Currently just PPPoE */
+#define PX_PROTO_OL2TP 1 /* Now L2TP also */
+#define PX_PROTO_PPTP  2 /* Now PPTP also */
+#define PX_MAX_PROTO   3
+
+struct sockaddr_pppox {
+       sa_family_t     sa_family;            /* address family, AF_PPPOX */
+       unsigned int    sa_protocol;          /* protocol identifier */
+       union{
+               struct pppoe_addr       pppoe;
+	       struct pptp_addr        pptp;
+       }sa_addr;
+}__attribute__ ((packed));
+
+/* The use of the above union isn't viable because the size of this
+ * struct must stay fixed over time -- applications use sizeof(struct
+ * sockaddr_pppox) to fill it. We use a protocol specific sockaddr
+ * type instead.
+ */
+struct sockaddr_pppol2tp {
+	sa_family_t     sa_family;      /* address family, AF_PPPOX */
+	unsigned int    sa_protocol;    /* protocol identifier */
+	struct pppol2tp_addr pppol2tp;
+}__attribute__ ((packed));
 
 /*********************************************************************
  *
@@ -68,9 +99,10 @@ struct sockaddr_pppox { 
  *
  ********************************************************************/
 
-#define PPPOEIOCSFWD	_IOW(0xB1 ,0, sizeof(struct sockaddr_pppox))
+#define PPPOEIOCSFWD	_IOW(0xB1 ,0, size_t)
 #define PPPOEIOCDFWD	_IO(0xB1 ,1)
-/*#define PPPOEIOCGFWD	_IOWR(0xB1,2, sizeof(struct sockaddr_pppox))*/
+/*#define PPPOEIOCGFWD	_IOWR(0xB1,2, size_t)*/
+#define PPPTPIOWFP     _IOWR(0xB1 ,2,size_t)
 
 /* Codes to identify message types */
 #define PADI_CODE	0x09
@@ -90,11 +122,11 @@ struct pppoe_tag {
 #define PTT_AC_NAME	__constant_htons(0x0102)
 #define PTT_HOST_UNIQ	__constant_htons(0x0103)
 #define PTT_AC_COOKIE	__constant_htons(0x0104)
-#define PTT_VENDOR 	__constant_htons(0x0105)
+#define PTT_VENDOR	__constant_htons(0x0105)
 #define PTT_RELAY_SID	__constant_htons(0x0110)
-#define PTT_SRV_ERR     __constant_htons(0x0201)
-#define PTT_SYS_ERR  	__constant_htons(0x0202)
-#define PTT_GEN_ERR  	__constant_htons(0x0203)
+#define PTT_SRV_ERR	__constant_htons(0x0201)
+#define PTT_SYS_ERR	__constant_htons(0x0202)
+#define PTT_GEN_ERR	__constant_htons(0x0203)
 
 struct pppoe_hdr {
 #if defined(__LITTLE_ENDIAN_BITFIELD)
@@ -112,34 +144,90 @@ struct pppoe_hdr {
 	struct pppoe_tag tag[0];
 } __attribute__ ((packed));
 
+/* Socket options */
+//#define PPTP_SO_TIMEOUT 1
+//#define PPTP_SO_WINDOW  2
+
 #ifdef __KERNEL__
+struct pppoe_opt {
+	struct net_device	*dev;	  /* device associated with socket*/
+	struct pppoe_addr	pa;	  /* what this socket is bound to*/
+	struct sockaddr_pppox	relay;	  /* what socket data will be
+					     relayed to (PPPoE relaying) */
+};
+
+struct pptp_opt {
+	struct pptp_addr        src_addr;
+	struct pptp_addr        dst_addr;
+	/* int timeout; */
+	
+	
+	__u32 ack_sent, ack_recv;
+	__u32 seq_sent, seq_recv;
+	int ppp_flags; /* , flags;
+	struct sk_buff_head skb_buf;
+	
+	struct delayed_work buf_work; check bufferd packets work
+	
+	struct gre_statistics *stat;
+	
+	spinlock_t xmit_lock;
+	spinlock_t rcv_lock; */
+};
+#define PPTP_FLAG_PAUSE 0
+#define PPTP_FLAG_PROC 1
+
+#include <net/sock.h>
+
+struct pppox_sock {
+	/* struct sock must be the first member of pppox_sock */
+	struct sock		sk;
+	struct ppp_channel	chan;
+	struct pppox_sock	*next;	  /* for hash table */
+	union {
+		struct pppoe_opt pppoe;
+		struct pptp_opt pptp;
+	} proto;
+	unsigned short		num;
+};
+#define pppoe_dev	proto.pppoe.dev
+#define pppoe_pa	proto.pppoe.pa
+#define pppoe_relay	proto.pppoe.relay
+
+static inline struct pppox_sock *pppox_sk(struct sock *sk)
+{
+	return (struct pppox_sock *)sk;
+}
+
+static inline struct sock *sk_pppox(struct pppox_sock *po)
+{
+	return (struct sock *)po;
+}
+
+struct module;
 
 struct pppox_proto {
-	int (*create)(struct socket *sock);
-	int (*ioctl)(struct socket *sock, unsigned int cmd,
-		     unsigned long arg);
+	int		(*create)(struct socket *sock);
+	int		(*ioctl)(struct socket *sock, unsigned int cmd,
+				 unsigned long arg);
+	struct module	*owner;
 };
 
 extern int register_pppox_proto(int proto_num, struct pppox_proto *pp);
 extern void unregister_pppox_proto(int proto_num);
 extern void pppox_unbind_sock(struct sock *sk);/* delete ppp-channel binding */
-extern int pppox_channel_ioctl(struct ppp_channel *pc, unsigned int cmd,
-			       unsigned long arg);
+extern int pppox_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg);
 
-/* PPPoE socket states */
+/* PPPoX socket states */
 enum {
     PPPOX_NONE		= 0,  /* initial state */
     PPPOX_CONNECTED	= 1,  /* connection established ==TCP_ESTABLISHED */
     PPPOX_BOUND		= 2,  /* bound to ppp device */
     PPPOX_RELAY		= 4,  /* forwarding is enabled */
-    PPPOX_ZOMBIE        = 8,  /* dead, but still connected */
-    PPPOX_DEAD		= 16
+    PPPOX_ZOMBIE	= 8,  /* dead, but still bound to ppp device */
+    PPPOX_DEAD		= 16  /* dead, useless, please clean me up!*/
 };
 
-extern struct ppp_channel_ops pppoe_chan_ops;
-
-extern int pppox_proto_init(struct net_proto *np);
-
 #endif /* __KERNEL__ */
 
 #endif /* !(__LINUX_IF_PPPOX_H) */
