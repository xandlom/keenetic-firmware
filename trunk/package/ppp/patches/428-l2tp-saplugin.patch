--- ppp-2.4.4.orig/pppd/Makefile.linux	2011-01-24 18:56:46.000000000 +0300
+++ ppp-2.4.4/pppd/Makefile.linux	2011-01-24 13:53:48.000000000 +0300
@@ -138,7 +138,7 @@
 # For "Pluggable Authentication Modules", see ftp.redhat.com:/pub/pam/.
 ifdef USE_PAM
 CFLAGS   += -DUSE_PAM
-LIBS     += -lpam -ldl
+LIBS     += -lpam -ldl -lpthread
 endif
 
 # Multi-linnk
@@ -168,7 +168,7 @@
 ifdef PLUGIN
 CFLAGS	+= -DPLUGIN
 LDFLAGS	+= -Wl,-E
-LIBS	+= -ldl
+LIBS	+= -ldl -lpthread
 endif
 
 ifdef FILTER
--- ppp-2.4.4.orig/pppd/plugins/pppol2tp/aaa.c	1970-01-01 03:00:00.000000000 +0300
+++ ppp-2.4.4/pppd/plugins/pppol2tp/aaa.c	2011-01-24 13:53:48.000000000 +0300
@@ -0,0 +1,343 @@
+/*
+ * Layer Two Tunnelling Protocol Daemon
+ * Copyright (C) 1998 Adtran, Inc.
+ * Copyright (C) 2002 Jeff McAdams
+ *
+ * Mark Spencer
+ *
+ * This software is distributed under the terms
+ * of the GPL, which you should have received
+ * along with this source.
+ *
+ * Authorization, Accounting, and Access control
+ *
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <string.h>
+#include <errno.h>
+#include "l2tp.h"
+
+extern void bufferDump (char *, int);
+
+void mk_challenge (unsigned char *c, int length)
+{
+    get_entropy(c, length);
+
+    /* int x;
+    int *s = (int *) c;
+    for (x = 0; x < length / sizeof (int); x++)
+        s[x] = rand (); */
+}
+
+int get_secret (char *us, char *them, unsigned char *secret, int size)
+{
+    FILE *f;
+    char buf[STRLEN];
+    char *u, *t, *s;
+    int num = 0;
+    f = fopen (AUTH_FILE, "r");
+    if (!f)
+    {
+        l2tp_log (LOG_WARNING, "%s : Unable to open '%s' for authentication\n",
+             __FUNCTION__, AUTH_FILE);
+        return 0;
+    }
+    while (!feof (f))
+    {
+        num++;
+        fgets (buf, sizeof (buf), f);
+        if (feof (f))
+            break;
+        /* Strip comments */
+        for (t = buf; *t; t++)
+            *t = ((*t == '#') || (*t == ';')) ? 0 : *t;
+        /* Strip trailing whitespace */
+        for (t = buf + strlen (buf) - 1; (t >= buf) && (*t < 33); t--)
+            *t = 0;
+        if (!strlen (buf))
+            continue;           /* Empty line */
+        u = buf;
+        while (*u && (*u < 33))
+            u++;
+        /* us */
+        if (!*u)
+        {
+            l2tp_log (LOG_WARNING,
+                 "%s: Invalid authentication info (no us), line %d\n",
+                 __FUNCTION__, num);
+            continue;
+        }
+        t = u;
+        while (*t > 32)
+            t++;
+        *(t++) = 0;
+        while (*t && (*t < 33))
+            t++;
+        /* them */
+        if (!*t)
+        {
+            l2tp_log (LOG_WARNING,
+                 "%s: Invalid authentication info (nothem), line %d\n",
+                 __FUNCTION__, num);
+            continue;
+        }
+        s = t;
+        while (*s > 33)
+            s++;
+        *(s++) = 0;
+        while (*s && (*s < 33))
+            s++;
+        if (!*s)
+        {
+            l2tp_log (LOG_WARNING,
+                 "%s: Invalid authentication info (no secret), line %d\n",
+                 __FUNCTION__, num);
+            continue;
+        }
+        if ((!strcasecmp (u, us) || !strcasecmp (u, "*")) &&
+            (!strcasecmp (t, them) || !strcasecmp (t, "*")))
+        {
+#ifdef DEBUG_AUTH
+            l2tp_log (LOG_DEBUG,
+                 "%s: we are '%s', they are '%s', secret is '%s'\n",
+                 __FUNCTION__, u, t, s);
+#endif
+            strncpy ((char *)secret, s, size);
+            fclose(f);
+            return -1;
+        }
+    }
+    fclose(f);
+    return 0;
+}
+
+int handle_challenge (struct tunnel *t, struct challenge *chal)
+{
+    char *us;
+    char *them;
+    if (!t->lac)
+    {
+        l2tp_log (LOG_DEBUG, "%s: No LAC to handle challenge!\n",
+             __FUNCTION__);
+        return -1;
+    }
+#ifdef DEBUG_AUTH
+    l2tp_log (LOG_DEBUG, "%s: making response for tunnel: %d\n", __FUNCTION__,
+         t->ourtid);
+#endif
+    if (t->lac->hostname[0])
+        us = t->lac->hostname;
+    else
+        us = hostname;
+    if (t->lac->peername[0])
+        them = t->lac->peername;
+    else
+        them = t->hostname;
+
+    if (!get_secret (us, them, chal->secret, sizeof (chal->secret)))
+    {
+        l2tp_log (LOG_DEBUG, "%s: no secret found for us='%s' and them='%s'\n",
+             __FUNCTION__, us, them);
+        return -1;
+    }
+
+#if DEBUG_AUTH
+    l2tp_log (LOG_DEBUG, "*%s: Here comes the chal->ss:\n", __FUNCTION__);
+    bufferDump (&chal->ss, 1);
+
+    l2tp_log (LOG_DEBUG, "%s: Here comes the secret\n", __FUNCTION__);
+    bufferDump (chal->secret, strlen (chal->secret));
+
+    l2tp_log (LOG_DEBUG, "%s: Here comes the challenge\n", __FUNCTION__);
+    bufferDump (chal->challenge, chal->chal_len);
+#endif
+
+    memset (chal->response, 0, MD_SIG_SIZE);
+    MD5Init (&chal->md5);
+    MD5Update (&chal->md5, &chal->ss, 1);
+    MD5Update (&chal->md5, chal->secret, strlen ((char *)chal->secret));
+    MD5Update (&chal->md5, chal->challenge, chal->chal_len);
+    MD5Final (chal->response, &chal->md5);
+#ifdef DEBUG_AUTH
+    l2tp_log (LOG_DEBUG, "response is %X%X%X%X to '%s' and %X%X%X%X, %d\n",
+         *((int *) &chal->response[0]),
+         *((int *) &chal->response[4]),
+         *((int *) &chal->response[8]),
+         *((int *) &chal->response[12]),
+         chal->secret,
+         *((int *) &chal->challenge[0]),
+         *((int *) &chal->challenge[4]),
+         *((int *) &chal->challenge[8]),
+         *((int *) &chal->challenge[12]), chal->ss);
+#endif
+    chal->state = STATE_CHALLENGED;
+    return 0;
+}
+
+#ifdef DEBUG_HIDDEN
+void print_md5 (void *md5)
+{
+    int *i = (int *) md5;
+    l2tp_log (LOG_DEBUG, "%X%X%X%X\n", i[0], i[1], i[2], i[3], i[4]);
+}
+
+inline void print_challenge (struct challenge *chal)
+{
+    l2tp_log (LOG_DEBUG, "vector: ");
+    print_md5 (chal->vector);
+    l2tp_log (LOG_DEBUG, "secret: %s\n", chal->secret);
+}
+#endif
+void encrypt_avp (struct buffer *buf, _u16 len, struct tunnel *t)
+{
+    /* Encrypts an AVP of len, at data.  We assume there
+       are two "spare bytes" before the data pointer,l but otherwise
+       this is just a normal AVP that is about to be returned from
+       an avpsend routine */
+    struct avp_hdr *new_hdr =
+        (struct avp_hdr *) (buf->start + buf->len - len);
+    struct avp_hdr *old_hdr =
+        (struct avp_hdr *) (buf->start + buf->len - len + 2);
+    _u16 length, flags, attr;   /* New length, old flags */
+    unsigned char *ptr, *end;
+    int cnt;
+    unsigned char digest[MD_SIG_SIZE];
+    unsigned char *previous_segment;
+
+    /* FIXME: Should I pad more randomly? Right now I pad to nearest 16 bytes */
+    length =
+        ((len - sizeof (struct avp_hdr) + 1) / 16 + 1) * 16 +
+        sizeof (struct avp_hdr);
+    flags = htons (old_hdr->length) & 0xF000;
+    new_hdr->length = htons (length | flags | HBIT);
+    new_hdr->vendorid = old_hdr->vendorid;
+    new_hdr->attr = attr = old_hdr->attr;
+    /* This is really the length field of the hidden sub-format */
+    old_hdr->attr = htons (len - sizeof (struct avp_hdr));
+    /* Okay, now we've rewritten the header, as it should be.  Let's start
+       encrypting the actual data now */
+    buf->len -= len;
+    buf->len += length;
+    /* Back to the beginning of real data, including the original length AVP */
+
+    MD5Init (&t->chal_them.md5);
+    MD5Update (&t->chal_them.md5, (void *) &attr, 2);
+    MD5Update (&t->chal_them.md5, t->chal_them.secret,
+               strlen ((char *)t->chal_them.secret));
+    MD5Update (&t->chal_them.md5, t->chal_them.vector, VECTOR_SIZE);
+    MD5Final (digest, &t->chal_them.md5);
+
+    /* Though not a "MUST" in the spec, our subformat length is always a multiple of 16 */
+    ptr = ((unsigned char *) new_hdr) + sizeof (struct avp_hdr);
+    end = ((unsigned char *) new_hdr) + length;
+    previous_segment = ptr;
+    while (ptr < end)
+    {
+#if DEBUG_HIDDEN
+        l2tp_log (LOG_DEBUG, "%s: The digest to be XOR'ed\n", __FUNCTION__);
+        bufferDump (digest, MD_SIG_SIZE);
+        l2tp_log (LOG_DEBUG, "%s: The plaintext to be XOR'ed\n", __FUNCTION__);
+        bufferDump (ptr, MD_SIG_SIZE);
+#endif
+        for (cnt = 0; cnt < MD_SIG_SIZE; cnt++, ptr++)
+        {
+            *ptr = *ptr ^ digest[cnt];
+        }
+#if DEBUG_HIDDEN
+        l2tp_log (LOG_DEBUG, "%s: The result of XOR\n", __FUNCTION__);
+        bufferDump (previous_segment, MD_SIG_SIZE);
+#endif
+        if (ptr < end)
+        {
+            MD5Init (&t->chal_them.md5);
+            MD5Update (&t->chal_them.md5, t->chal_them.secret,
+                       strlen ((char *)t->chal_them.secret));
+            MD5Update (&t->chal_them.md5, previous_segment, MD_SIG_SIZE);
+            MD5Final (digest, &t->chal_them.md5);
+        }
+        previous_segment = ptr;
+    }
+}
+
+int decrypt_avp (char *buf, struct tunnel *t)
+{
+    /* Decrypts a hidden AVP pointed to by buf.  The
+       new header will be exptected to be two characters
+       offset from the old */
+    int cnt = 0;
+    int len, olen, flags;
+    unsigned char digest[MD_SIG_SIZE];
+    char *ptr, *end;
+    _u16 attr;
+    struct avp_hdr *old_hdr = (struct avp_hdr *) buf;
+    struct avp_hdr *new_hdr = (struct avp_hdr *) (buf + 2);
+    int saved_segment_len;      /* maybe less 16; may be used if the cipher is longer than 16 octets */
+    unsigned char saved_segment[MD_SIG_SIZE];
+    ptr = ((char *) old_hdr) + sizeof (struct avp_hdr);
+    olen = old_hdr->length & 0x0FFF;
+    end = buf + olen;
+    if (!t->chal_us.vector)
+    {
+        l2tp_log (LOG_DEBUG,
+             "decrypt_avp: Hidden bit set, but no random vector specified!\n");
+        return -EINVAL;
+    }
+    /* First, let's decrypt all the data.  We're not guaranteed
+       that it will be padded to a 16 byte boundary, so we
+       have to be more careful than when encrypting */
+    attr = ntohs (old_hdr->attr);
+    MD5Init (&t->chal_us.md5);
+    MD5Update (&t->chal_us.md5, (void *) &attr, 2);
+    MD5Update (&t->chal_us.md5, t->chal_us.secret,
+               strlen ((char *)t->chal_us.secret));
+    MD5Update (&t->chal_us.md5, t->chal_us.vector, t->chal_us.vector_len);
+    MD5Final (digest, &t->chal_us.md5);
+#ifdef DEBUG_HIDDEN
+    l2tp_log (LOG_DEBUG, "attribute is %d and challenge is: ", attr);
+    print_challenge (&t->chal_us);
+    l2tp_log (LOG_DEBUG, "md5 is: ");
+    print_md5 (digest);
+#endif
+    while (ptr < end)
+    {
+        if (cnt >= MD_SIG_SIZE)
+        {
+            MD5Init (&t->chal_us.md5);
+            MD5Update (&t->chal_us.md5, t->chal_us.secret,
+                       strlen ((char *)t->chal_us.secret));
+            MD5Update (&t->chal_us.md5, saved_segment, MD_SIG_SIZE);
+            MD5Final (digest, &t->chal_us.md5);
+            cnt = 0;
+        }
+        /* at the beginning of each segment, we save the current segment (16 octets or less) of cipher 
+         * so that the next round of MD5 (if there is a next round) hash could use it 
+         */
+        if (cnt == 0)
+        {
+            saved_segment_len =
+                (end - ptr < MD_SIG_SIZE) ? (end - ptr) : MD_SIG_SIZE;
+            memcpy (saved_segment, ptr, saved_segment_len);
+        }
+        *ptr = *ptr ^ digest[cnt++];
+        ptr++;
+    }
+    /* Hopefully we're all nice and decrypted now.  Let's rewrite the header. 
+       First save the old flags, and get the new stuff */
+    flags = old_hdr->length & 0xF000 & ~HBIT;
+    len = ntohs (new_hdr->attr) + sizeof (struct avp_hdr);
+    if (len > olen - 2)
+    {
+        l2tp_log (LOG_DEBUG,
+             "decrypt_avp: Decrypted length is too long (%d > %d)\n", len,
+             olen - 2);
+        return -EINVAL;
+    }
+    new_hdr->attr = old_hdr->attr;
+    new_hdr->vendorid = old_hdr->vendorid;
+    new_hdr->length = len | flags;
+    return 0;
+}
--- ppp-2.4.4.orig/pppd/plugins/pppol2tp/aaa.h	1970-01-01 03:00:00.000000000 +0300
+++ ppp-2.4.4/pppd/plugins/pppol2tp/aaa.h	2011-01-24 13:53:48.000000000 +0300
@@ -0,0 +1,52 @@
+/*
+ * Layer Two Tunnelling Protocol Daemon
+ * Copyright (C) 1998 Adtran, Inc.
+ * Copyright (C) 2002 Jeff McAdams
+ *
+ * Mark Spencer
+ *
+ * This software is distributed under the terms
+ * of the GPL, which you should have received
+ * along with this source.
+ *
+ * Authorization, Accounting, and Access control
+ *
+ */
+
+#ifndef _AAA_H
+#define _AAA_H
+#include "md5.h"
+
+#define ADDR_HASH_SIZE 256
+#define MD_SIG_SIZE 16
+#define MAX_VECTOR_SIZE 1024
+#define VECTOR_SIZE 16
+
+#define STATE_NONE 		 0
+#define STATE_CHALLENGED 1
+#define STATE_COMPLETE	 2
+
+struct addr_ent
+{
+    unsigned int addr;
+    struct addr_ent *next;
+};
+
+struct challenge
+{
+    struct MD5Context md5;
+    unsigned char ss;           /* State we're sending in */
+    unsigned char secret[MAXSTRLEN];    /* The shared secret */
+    unsigned char *challenge;       /* The original challenge */
+    unsigned int chal_len;       /* The length of the original challenge */
+    unsigned char response[MD_SIG_SIZE];        /* What we expect as a respsonse */
+    unsigned char reply[MD_SIG_SIZE];   /* What the peer sent */
+    unsigned char *vector;
+    unsigned int vector_len;
+    int state;                  /* What state is challenge in? */
+};
+
+extern void init_addr ();
+extern int handle_challenge (struct tunnel *, struct challenge *);
+extern void mk_challenge (unsigned char *, int);
+#endif
--- ppp-2.4.4.orig/pppd/plugins/pppol2tp/avp.c	1970-01-01 03:00:00.000000000 +0300
+++ ppp-2.4.4/pppd/plugins/pppol2tp/avp.c	2011-01-24 13:53:48.000000000 +0300
@@ -0,0 +1,1776 @@
+/*
+ * Layer Two Tunnelling Protocol Daemon
+ * Copyright (C) 1998 Adtran, Inc.
+ * Copyright (C) 2002 Jeff McAdams
+ *
+ * Mark Spencer
+ *
+ * This software is distributed under the terms
+ * of the GPL, which you should have received
+ * along with this source.
+ *
+ * Attribute Value Pair handler routines
+ */
+#include <stdlib.h>
+#include <string.h>
+#include <stdio.h>
+#include <errno.h>
+#include <netinet/in.h>
+#include "l2tp.h"
+
+#define AVP_MAX 39
+
+struct avp avps[] = {
+
+    {0, 1, &message_type_avp, "Message Type"},
+    {1, 1, &result_code_avp, "Result Code"},
+    {2, 1, &protocol_version_avp, "Protocol Version"},
+    {3, 1, &framing_caps_avp, "Framing Capabilities"},
+    {4, 1, &bearer_caps_avp, "Bearer Capabilities"},
+    {5, 0, NULL, "Tie Breaker"},
+    {6, 0, &firmware_rev_avp, "Firmware Revision"},
+    {7, 0, &hostname_avp, "Host Name"},
+    {8, 1, &vendor_avp, "Vendor Name"},
+    {9, 1, &assigned_tunnel_avp, "Assigned Tunnel ID"},
+    {10, 1, &receive_window_size_avp, "Receive Window Size"},
+    {11, 1, &challenge_avp, "Challenge"},
+    {12, 0, NULL, "Q.931 Cause Code"},
+    {13, 1, &chalresp_avp, "Challenge Response"},
+    {14, 1, &assigned_call_avp, "Assigned Call ID"},
+    {15, 1, &call_serno_avp, "Call Serial Number"},
+    {16, 1, NULL, "Minimum BPS"},
+    {17, 1, NULL, "Maximum BPS"},
+    {18, 1, &bearer_type_avp, "Bearer Type"},
+    {19, 1, &frame_type_avp, "Framing Type"},
+    {20, 1, &packet_delay_avp, "Packet Processing Delay"},
+    {21, 1, &dialed_number_avp, "Dialed Number"},
+    {22, 1, &dialing_number_avp, "Dialing Number"},
+    {23, 1, &sub_address_avp, "Sub-Address"},
+    {24, 1, &tx_speed_avp, "Transmit Connect Speed"},
+    {25, 1, &call_physchan_avp, "Physical channel ID"},
+    {26, 0, NULL, "Initial Received LCP Confreq"},
+    {27, 0, NULL, "Last Sent LCP Confreq"},
+    {28, 0, NULL, "Last Received LCP Confreq"},
+    {29, 1, &ignore_avp, "Proxy Authen Type"},
+    {30, 0, &ignore_avp, "Proxy Authen Name"},
+    {31, 0, &ignore_avp, "Proxy Authen Challenge"},
+    {32, 0, &ignore_avp, "Proxy Authen ID"},
+    {33, 1, &ignore_avp, "Proxy Authen Response"},
+    {34, 1, NULL, "Call Errors"},
+    {35, 1, &ignore_avp, "ACCM"},
+    {36, 1, &rand_vector_avp, "Random Vector"},
+    {37, 1, NULL, "Private Group ID"},
+    {38, 0, &rx_speed_avp, "Receive Connect Speed"},
+    {39, 1, &seq_reqd_avp, "Sequencing Required"}
+};
+
+char *msgtypes[] = {
+    NULL,
+    "Start-Control-Connection-Request",
+    "Start-Control-Connection-Reply",
+    "Start-Control-Connection-Connected",
+    "Stop-Control-Connection-Notification",
+    NULL,
+    "Hello",
+    "Outgoing-Call-Request",
+    "Outgoing-Call-Reply",
+    "Outgoing-Call-Connected",
+    "Incoming-Call-Request",
+    "Incoming-Call-Reply",
+    "Incoming-Call-Connected",
+    NULL,
+    "Call-Disconnect-Notify",
+    "WAN-Error-Notify",
+    "Set-Link-Info"
+};
+
+char *stopccn_result_codes[] = {
+    "Reserved",
+    "General request to clear control connection",
+    "General error--Error Code indicates the problem",
+    "Control channel already exists",
+    "Requester is not authorized to establish a control channel",
+    "The protocol version of the requester is not supported--Error Code indicates the highest version supported",
+    "Requester is being shut down",
+    "Finite State Machine error"
+};
+
+char *cdn_result_codes[] = {
+    "Reserved",
+    "Call disconnected due to loss of carrier",
+    "Call disconnected for the reason indicated in error code",
+    "Call disconnected for administrative reasons",
+    "Call failed due to lack of appropriate facilities being available (temporary condition)",
+    "Call failed due to lack of appropriate facilities being available (permanent condition)",
+    "Invalid destination",
+    "Call failed due to no carrier detected",
+    "Call failed due to lack of a dial tone",
+    "Call was no established within time allotted by LAC",
+    "Call was connected but no appropriate framing was detect"
+};
+
+void wrong_length (struct call *c, char *field, int expected, int found,
+                   int min)
+{
+    if (min)
+        snprintf (c->errormsg, sizeof (c->errormsg),
+                  "%s: expected at least %d, got %d", field, expected, found);
+    else
+        snprintf (c->errormsg, sizeof (c->errormsg),
+                  "%s: expected %d, got %d", field, expected, found);
+
+    c->error = ERROR_LENGTH;
+    c->result = RESULT_ERROR;
+    c->needclose = -1;
+}
+
+struct unaligned_u16 {
+	_u16	s;
+} __attribute__((packed));
+
+/*
+ * t, c, data, and datalen may be assumed to be defined for all avp's
+ */
+
+int message_type_avp (struct tunnel *t, struct call *c, void *data,
+                      int datalen)
+{
+    /*
+     * This will be with every control message.  It is critical that this
+     * procedure check for the validity of sending this kind of a message
+     * (assuming sanity check)
+     */
+
+    struct unaligned_u16 *raw = data;
+    c->msgtype = ntohs (raw[3].s);
+    if (datalen != 8)
+    {
+        if (DEBUG)
+            l2tp_log (LOG_DEBUG, "%s: wrong size (%d != 8)\n", __FUNCTION__,
+                 datalen);
+        wrong_length (c, "Message Type", 8, datalen, 0);
+        return -EINVAL;
+    }
+    if ((c->msgtype > MAX_MSG) || (!msgtypes[c->msgtype]))
+    {
+        if (DEBUG)
+            l2tp_log (LOG_DEBUG, "%s: unknown message type %d\n", __FUNCTION__,
+                 c->msgtype);
+        return -EINVAL;
+    }
+    if (gconfig.debug_avp)
+        if (DEBUG)
+            l2tp_log (LOG_DEBUG, "%s: message type %d (%s)\n", __FUNCTION__,
+                 c->msgtype, msgtypes[c->msgtype]);
+#ifdef SANITY
+    if (t->sanity)
+    {
+        /*
+         * Look ou our state for each message and make sure everything
+         * make sense...
+         */
+        if ((c != t->self) && (c->msgtype < Hello))
+        {
+            if (DEBUG)
+                l2tp_log (LOG_DEBUG,
+                     "%s: attempting to negotiate tunnel inside a call!\n",
+                     __FUNCTION__);
+            return -EINVAL;
+        }
+
+        switch (c->msgtype)
+        {
+        case SCCRQ:
+            if ((t->state != 0) && (t->state != SCCRQ))
+            {
+                /*
+                 * When we handle tie breaker AVP's, then we'll check
+                 * to see if we've both requested tunnels
+                 */
+
+                if (DEBUG)
+                    l2tp_log (LOG_DEBUG,
+                         "%s: attempting to negotiate SCCRQ with state != 0\n",
+                         __FUNCTION__);
+                return -EINVAL;
+            }
+            break;
+        case SCCRP:
+            if (t->state != SCCRQ)
+            {
+                if (DEBUG)
+                    l2tp_log (LOG_DEBUG,
+                         "%s: attempting to negotiate SCCRP with state != SCCRQ!\n",
+                         __FUNCTION__);
+                return -EINVAL;
+            }
+            break;
+        case SCCCN:
+            if (t->state != SCCRP)
+            {
+                if (DEBUG)
+                    l2tp_log (LOG_DEBUG,
+                         "%s: attempting to negotiate SCCCN with state != SCCRP!\n",
+                         __FUNCTION__);
+                return -EINVAL;
+            }
+            break;
+        case ICRQ:
+            if (t->state != SCCCN)
+            {
+                if (DEBUG)
+                    l2tp_log (LOG_DEBUG,
+                         "%s: attempting to negotiate ICRQ when state != SCCCN\n",
+                         __FUNCTION__);
+                return -EINVAL;
+            }
+            if (c != t->self)
+            {
+                if (DEBUG)
+                    l2tp_log (LOG_DEBUG,
+                         "%s: attempting to negotiate ICRQ on a call!\n",
+                         __FUNCTION__);
+                return -EINVAL;
+            }
+            break;
+        case ICRP:
+            if (t->state != SCCCN)
+            {
+                if (DEBUG)
+                    l2tp_log (LOG_DEBUG,
+                         "%s: attempting to negotiate ICRP on tunnel!=SCCCN\n",
+                         __FUNCTION__);
+                return -EINVAL;
+            }
+            if (c->state != ICRQ)
+            {
+                if (DEBUG)
+                    l2tp_log (LOG_DEBUG,
+                         "%s: attempting to negotiate ICRP when state != ICRQ\n",
+                         __FUNCTION__);
+                return -EINVAL;
+            }
+            break;
+        case ICCN:
+            if (c->state != ICRP)
+            {
+                if (DEBUG)
+                    l2tp_log (LOG_DEBUG,
+                         "%s: attempting to negotiate ICCN when state != ICRP\n",
+                         __FUNCTION__);
+                return -EINVAL;
+            }
+            break;
+        case SLI:
+            if (c->state != ICCN)
+            {
+                if (DEBUG)
+                    l2tp_log (LOG_DEBUG,
+                         "%s: attempting to negotiate SLI when state != ICCN\n",
+                         __FUNCTION__);
+                return -EINVAL;
+            }
+            break;
+        case OCRP:             /* jz: case for ORCP */
+            if (t->state != SCCCN)
+            {
+                if (DEBUG)
+                    l2tp_log (LOG_DEBUG,
+                         "%s: attempting to negotiate OCRP on tunnel!=SCCCN\n",
+                         __FUNCTION__);
+                return -EINVAL;
+            }
+            if (c->state != OCRQ)
+            {
+                if (DEBUG)
+                    l2tp_log (LOG_DEBUG,
+                         "%s: attempting to negotiate OCRP when state != OCRQ\n",
+                         __FUNCTION__);
+                return -EINVAL;
+            }
+            break;
+        case OCCN:             /* jz: case for OCCN */
+
+            if (c->state != OCRQ)
+            {
+                if (DEBUG)
+                    l2tp_log (LOG_DEBUG,
+                         "%s: attempting to negotiate OCCN when state != OCRQ\n",
+                         __FUNCTION__);
+                return -EINVAL;
+            }
+            break;
+        case StopCCN:
+        case CDN:
+        case Hello:
+            break;
+        default:
+            l2tp_log (LOG_WARNING, "%s: i don't know how to handle %s messages\n",
+                 __FUNCTION__, msgtypes[c->msgtype]);
+            return -EINVAL;
+        }
+    }
+#endif
+    if (c->msgtype == ICRQ)
+    {
+        struct call *tmp;
+        if (gconfig.debug_avp)
+        {
+            if (DEBUG)
+                l2tp_log (LOG_DEBUG, "%s: new incoming call\n", __FUNCTION__);
+        }
+        tmp = new_call (t);
+        if (!tmp)
+        {
+            l2tp_log (LOG_WARNING, "%s: unable to create new call\n", __FUNCTION__);
+            return -EINVAL;
+        }
+        tmp->next = t->call_head;
+        t->call_head = tmp;
+        t->count++;
+        /*
+           * Is this still safe to assume that the head will always
+           * be the most recent call being negotiated?
+           * Probably...  FIXME anyway...
+         */
+
+    }
+
+    return 0;
+}
+
+int rand_vector_avp (struct tunnel *t, struct call *c, void *data,
+                     int datalen)
+{
+    int size;
+    struct unaligned_u16 *raw = data;
+    size = raw[0].s & 0x03FF;
+    size -= sizeof (struct avp_hdr);
+#ifdef SANITY
+    if (t->sanity)
+    {
+        if (size < 0)
+        {
+            if (DEBUG)
+                l2tp_log (LOG_DEBUG, "%s: Random vector too small (%d < 0)\n",
+                     __FUNCTION__, size);
+            wrong_length (c, "Random Vector", 6, datalen, 1);
+            return -EINVAL;
+        }
+        if (size > MAX_VECTOR_SIZE)
+        {
+            if (DEBUG)
+                l2tp_log (LOG_DEBUG, "%s: Random vector too large (%d > %d)\n",
+                     __FUNCTION__, datalen, MAX_VECTOR_SIZE);
+            wrong_length (c, "Random Vector", 6, datalen, 1);
+            return -EINVAL;
+        }
+    }
+#endif
+    if (gconfig.debug_avp)
+        l2tp_log (LOG_DEBUG, "%s: Random Vector of %d octets\n", __FUNCTION__,
+             size);
+    t->chal_us.vector = (unsigned char *) &raw[3].s;
+    t->chal_us.vector_len = size;
+    return 0;
+}
+
+int ignore_avp (struct tunnel *t, struct call *c, void *data, int datalen)
+{
+    /*
+     * The spec says we have to accept authentication information
+     * even if we just ignore it, so that's exactly what
+     * we're going to do at this point.  Proxy authentication is such
+     * a rediculous security threat anyway except from local
+     * controled machines.
+     *
+     * FIXME: I need to handle proxy authentication as an option.
+     * One option is to simply change the options we pass to pppd.
+     *
+     */
+    if (gconfig.debug_avp)
+    {
+        if (DEBUG)
+            l2tp_log (LOG_DEBUG, "%s : Ignoring AVP\n", __FUNCTION__);
+    }
+    return 0;
+}
+
+int seq_reqd_avp (struct tunnel *t, struct call *c, void *data, int datalen)
+{
+#ifdef SANITY
+    if (t->sanity)
+    {
+        if (datalen != 6)
+        {
+            if (DEBUG)
+                l2tp_log (LOG_DEBUG,
+                     "%s: avp is incorrect size.  %d != 6\n", __FUNCTION__,
+                     datalen);
+            wrong_length (c, "Sequencing Required", 6, datalen, 1);
+            return -EINVAL;
+        }
+        switch (c->msgtype)
+        {
+        case ICCN:
+            break;
+        default:
+            if (DEBUG)
+                l2tp_log (LOG_DEBUG,
+                     "%s: sequencing required not appropriate for %s!\n",
+                     __FUNCTION__, msgtypes[c->msgtype]);
+            return -EINVAL;
+        }
+    }
+#endif
+    if (gconfig.debug_avp)
+    {
+        if (DEBUG)
+            l2tp_log (LOG_DEBUG, "%s: peer requires sequencing.\n", __FUNCTION__);
+    }
+    c->seq_reqd = -1;
+    return 0;
+}
+
+int result_code_avp (struct tunnel *t, struct call *c, void *data,
+                     int datalen)
+{
+    /*
+     * Find out what version of l2tp the other side is using.
+     * I'm not sure what we're supposed to do with this but whatever..
+     */
+
+    int error;
+    int result;
+    struct unaligned_u16 *raw = data;
+#ifdef SANITY
+    if (t->sanity)
+    {
+        if (datalen < 10)
+        {
+            if (DEBUG)
+                l2tp_log (LOG_DEBUG,
+                     "%s: avp is incorrect size.  %d < 10\n", __FUNCTION__,
+                     datalen);
+            wrong_length (c, "Result Code", 10, datalen, 1);
+            return -EINVAL;
+        }
+        switch (c->msgtype)
+        {
+        case CDN:
+        case StopCCN:
+            break;
+        default:
+            if (DEBUG)
+                l2tp_log (LOG_DEBUG,
+                     "%s: result code not appropriate for %s.  Ignoring.\n",
+                     __FUNCTION__, msgtypes[c->msgtype]);
+            return 0;
+        }
+    }
+#endif
+    result = ntohs (raw[3].s);
+    error = ntohs (raw[4].s);
+    if ((c->msgtype == StopCCN) && ((result > 7) || (result < 1)))
+    {
+        if (DEBUG)
+            l2tp_log (LOG_DEBUG,
+                 "%s: result code out of range (%d %d %d).  Ignoring.\n",
+                 __FUNCTION__, result, error, datalen);
+        return 0;
+    }
+
+    if ((c->msgtype == CDN) && ((result > 11) || (result < 1)))
+    {
+        if (DEBUG)
+            l2tp_log (LOG_DEBUG,
+                 "%s: result code out of range (%d %d %d).  Ignoring.\n",
+                 __FUNCTION__, result, error, datalen);
+        return 0;
+    }
+
+    c->error = error;
+    c->result = result;
+    safe_copy (c->errormsg, (char *) &raw[5].s, datalen - 10);
+    if (gconfig.debug_avp)
+    {
+        if (DEBUG && (c->msgtype == StopCCN))
+        {
+            l2tp_log (LOG_DEBUG,
+                 "%s: peer closing for reason %d (%s), error = %d (%s)\n",
+                 __FUNCTION__, result, stopccn_result_codes[result], error,
+                 c->errormsg);
+        }
+        else
+        {
+            l2tp_log (LOG_DEBUG,
+                 "%s: peer closing for reason %d (%s), error = %d (%s)\n",
+                 __FUNCTION__, result, cdn_result_codes[result], error,
+                 c->errormsg);
+        }
+    }
+    return 0;
+}
+
+int protocol_version_avp (struct tunnel *t, struct call *c, void *data,
+                          int datalen)
+{
+    /*
+     * Find out what version of l2tp the other side is using.
+     * I'm not sure what we're supposed to do with this but whatever..
+     */
+
+    int ver;
+    struct unaligned_u16 *raw = data;
+#ifdef SANITY
+    if (t->sanity)
+    {
+        if (datalen != 8)
+        {
+            if (DEBUG)
+                l2tp_log (LOG_DEBUG,
+                     "%s: avp is incorrect size.  %d != 8\n", __FUNCTION__,
+                     datalen);
+            wrong_length (c, "Protocol Version", 8, datalen, 1);
+            return -EINVAL;
+        }
+        switch (c->msgtype)
+        {
+        case SCCRP:
+        case SCCRQ:
+            break;
+        default:
+            if (DEBUG)
+                l2tp_log (LOG_DEBUG,
+                     "%s: protocol version not appropriate for %s.  Ignoring.\n",
+                     __FUNCTION__, msgtypes[c->msgtype]);
+            return 0;
+        }
+    }
+#endif
+    ver = ntohs (raw[3].s);
+    if (gconfig.debug_avp)
+    {
+        if (DEBUG)
+            l2tp_log (LOG_DEBUG,
+                 "%s: peer is using version %d, revision %d.\n", __FUNCTION__,
+                 (ver >> 8), ver & 0xFF);
+    }
+    return 0;
+}
+
+int framing_caps_avp (struct tunnel *t, struct call *c, void *data,
+                      int datalen)
+{
+    /*
+     * Retrieve the framing capabilities
+     * from the peer
+     */
+
+    int caps;
+    struct unaligned_u16 *raw = data;
+
+#ifdef SANITY
+    if (t->sanity)
+    {
+        switch (c->msgtype)
+        {
+        case SCCRP:
+        case SCCRQ:
+            break;
+        default:
+            if (DEBUG)
+                l2tp_log (LOG_DEBUG,
+                     "%s: framing capabilities not appropriate for %s.  Ignoring.\n",
+                     __FUNCTION__, msgtypes[c->msgtype]);
+            return 0;
+        }
+        if (datalen != 10)
+        {
+            if (DEBUG)
+                l2tp_log (LOG_DEBUG,
+                     "%s: avp is incorrect size.  %d != 10\n", __FUNCTION__,
+                     datalen);
+            wrong_length (c, "Framming Capabilities", 10, datalen, 0);
+            return -EINVAL;
+        }
+    }
+#endif
+    caps = ntohs (raw[4].s);
+    if (gconfig.debug_avp)
+        if (DEBUG)
+            l2tp_log (LOG_DEBUG,
+                 "%s: supported peer frames:%s%s\n", __FUNCTION__,
+                 caps & ASYNC_FRAMING ? " async" : "",
+                 caps & SYNC_FRAMING ? " sync" : "");
+    t->fc = caps & (ASYNC_FRAMING | SYNC_FRAMING);
+    return 0;
+}
+
+int bearer_caps_avp (struct tunnel *t, struct call *c, void *data,
+                     int datalen)
+{
+    /*
+     * What kind of bearer channels does our peer support?
+     */
+    int caps;
+    struct unaligned_u16 *raw = data;
+
+#ifdef SANITY
+    if (t->sanity)
+    {
+        switch (c->msgtype)
+        {
+        case SCCRP:
+        case SCCRQ:
+            break;
+        default:
+            if (DEBUG)
+                l2tp_log (LOG_DEBUG,
+                     "%s: bearer capabilities not appropriate for message %s.  Ignoring.\n",
+                     __FUNCTION__, msgtypes[c->msgtype]);
+            return 0;
+        }
+        if (datalen != 10)
+        {
+            if (DEBUG)
+                l2tp_log (LOG_DEBUG,
+                     "%s: avp is incorrect size.  %d != 10\n", __FUNCTION__,
+                     datalen);
+            wrong_length (c, "Bearer Capabilities", 10, datalen, 0);
+            return -EINVAL;
+        }
+    }
+#endif
+    caps = ntohs (raw[4].s);
+    if (gconfig.debug_avp)
+    {
+        if (DEBUG)
+        {
+            l2tp_log (LOG_DEBUG,
+                 "%s: supported peer bearers:%s%s\n",
+                 __FUNCTION__,
+                 caps & ANALOG_BEARER ? " analog" : "",
+                 caps & DIGITAL_BEARER ? " digital" : "");
+        }
+
+    }
+    t->bc = caps & (ANALOG_BEARER | DIGITAL_BEARER);
+    return 0;
+}
+
+
+/* FIXME: I need to handle tie breakers eventually */
+
+int firmware_rev_avp (struct tunnel *t, struct call *c, void *data,
+                      int datalen)
+{
+    /*
+     * Report and record remote firmware version
+     */
+    int ver;
+    struct unaligned_u16 *raw = data;
+
+#ifdef SANITY
+    if (t->sanity)
+    {
+        switch (c->msgtype)
+        {
+        case SCCRP:
+        case SCCRQ:
+            break;
+        default:
+            if (DEBUG)
+                l2tp_log (LOG_DEBUG,
+                     "%s: firmware revision not appropriate for message %s.  Ignoring.\n",
+                     __FUNCTION__, msgtypes[c->msgtype]);
+            return 0;
+        }
+        if (datalen != 8)
+        {
+            if (DEBUG)
+                l2tp_log (LOG_DEBUG,
+                     "%s: avp is incorrect size.  %d != 8\n", __FUNCTION__,
+                     datalen);
+            wrong_length (c, "Firmware Revision", 8, datalen, 0);
+            return -EINVAL;
+        }
+    }
+#endif
+    ver = ntohs (raw[3].s);
+    if (gconfig.debug_avp)
+    {
+        if (DEBUG)
+            l2tp_log (LOG_DEBUG,
+                 "%s: peer reports firmware version %d (0x%.4x)\n",
+                 __FUNCTION__, ver, ver);
+    }
+    t->firmware = ver;
+    return 0;
+}
+
+int bearer_type_avp (struct tunnel *t, struct call *c, void *data,
+                     int datalen)
+{
+    /*
+     * What kind of bearer channel is the call on?
+     */
+    int b;
+    struct unaligned_u16 *raw = data;
+
+#ifdef SANITY
+    if (t->sanity)
+    {
+        switch (c->msgtype)
+        {
+        case ICRQ:
+        case OCRQ:
+            break;
+        default:
+            if (DEBUG)
+                l2tp_log (LOG_DEBUG,
+                     "%s: bearer type not appropriate for message %s.  Ignoring.\n",
+                     __FUNCTION__, msgtypes[c->msgtype]);
+            return 0;
+        }
+        if (datalen != 10)
+        {
+            if (DEBUG)
+                l2tp_log (LOG_DEBUG,
+                     "%s: avp is incorrect size.  %d != 10\n", __FUNCTION__,
+                     datalen);
+            wrong_length (c, "Bearer Type", 10, datalen, 0);
+            return -EINVAL;
+        }
+    }
+#endif
+    b = ntohs (raw[4].s);
+    if (gconfig.debug_avp)
+    {
+        if (DEBUG)
+            l2tp_log (LOG_DEBUG,
+                 "%s: peer bears:%s\n", __FUNCTION__,
+                 b & ANALOG_BEARER ? " analog" : "digital");
+    }
+    t->call_head->bearer = b;
+    return 0;
+}
+
+int frame_type_avp (struct tunnel *t, struct call *c, void *data, int datalen)
+{
+    /*
+     * What kind of frame channel is the call on?
+     */
+    int b;
+    struct unaligned_u16 *raw = data;
+
+#ifdef SANITY
+    if (t->sanity)
+    {
+        switch (c->msgtype)
+        {
+        case ICCN:
+        case OCRQ:
+        case OCCN:
+            break;
+        default:
+            if (DEBUG)
+                l2tp_log (LOG_DEBUG,
+                     "%s: frame type not appropriate for message %s.  Ignoring.\n",
+                     __FUNCTION__, msgtypes[c->msgtype]);
+            return 0;
+        }
+        if (datalen != 10)
+        {
+            if (DEBUG)
+                l2tp_log (LOG_DEBUG,
+                     "%s: avp is incorrect size.  %d != 10\n", __FUNCTION__,
+                     datalen);
+            wrong_length (c, "Frame Type", 10, datalen, 0);
+            return -EINVAL;
+        }
+    }
+#endif
+    b = ntohs (raw[4].s);
+    if (gconfig.debug_avp)
+    {
+        if (DEBUG)
+            l2tp_log (LOG_DEBUG,
+                 "%s: peer uses:%s frames\n", __FUNCTION__,
+                 b & ASYNC_FRAMING ? " async" : "sync");
+    }
+    c->frame = b;
+    return 0;
+}
+
+int hostname_avp (struct tunnel *t, struct call *c, void *data, int datalen)
+{
+    /*
+     * What is the peer's name?
+     */
+    int size;
+    struct unaligned_u16 *raw = data;
+
+#ifdef SANITY
+    if (t->sanity)
+    {
+        switch (c->msgtype)
+        {
+        case SCCRP:
+        case SCCRQ:
+            break;
+        default:
+            if (DEBUG)
+                l2tp_log (LOG_DEBUG,
+                     "%s: hostname not appropriate for message %s.  Ignoring.\n",
+                     __FUNCTION__, msgtypes[c->msgtype]);
+            return 0;
+        }
+        if (datalen < 6)
+        {
+            if (DEBUG)
+                l2tp_log (LOG_DEBUG,
+                     "%s: avp is too small.  %d < 6\n", __FUNCTION__,
+                     datalen);
+            wrong_length (c, "Hostname", 6, datalen, 1);
+            return -EINVAL;
+        }
+    }
+#endif
+    size = raw[0].s & 0x03FF;
+    size -= sizeof (struct avp_hdr);
+    if (size > MAXSTRLEN - 1)
+    {
+        if (DEBUG)
+            l2tp_log (LOG_DEBUG, "%s: truncating reported hostname (size is %d)\n",
+                 __FUNCTION__, size);
+        size = MAXSTRLEN - 1;
+    }
+    safe_copy (t->hostname, (char *) &raw[3].s, size);
+    if (gconfig.debug_avp)
+    {
+        if (DEBUG)
+            l2tp_log (LOG_DEBUG,
+                 "%s: peer reports hostname '%s'\n", __FUNCTION__,
+                 t->hostname);
+    }
+    return 0;
+}
+
+int dialing_number_avp (struct tunnel *t, struct call *c, void *data,
+                        int datalen)
+{
+    /*
+     * What is the peer's name?
+     */
+    int size;
+    struct unaligned_u16 *raw = data;
+
+#ifdef SANITY
+    if (t->sanity)
+    {
+        switch (c->msgtype)
+        {
+        case ICRQ:
+            break;
+        default:
+            if (DEBUG)
+                l2tp_log (LOG_DEBUG,
+                     "%s: dialing number not appropriate for message %s.  Ignoring.\n",
+                     __FUNCTION__, msgtypes[c->msgtype]);
+            return 0;
+        }
+        if (datalen < 6)
+        {
+            if (DEBUG)
+                l2tp_log (LOG_DEBUG,
+                     "%s: avp is too small.  %d < 6\n", __FUNCTION__,
+                     datalen);
+            wrong_length (c, "Dialing Number", 6, datalen, 1);
+            return -EINVAL;
+        }
+    }
+#endif
+    size = raw[0].s & 0x03FF;
+    size -= sizeof (struct avp_hdr);
+    if (size > MAXSTRLEN - 1)
+    {
+        if (DEBUG)
+            l2tp_log (LOG_DEBUG,
+                 "%s: truncating reported dialing number (size is %d)\n",
+                 __FUNCTION__, size);
+        size = MAXSTRLEN - 1;
+    }
+    safe_copy (t->call_head->dialing, (char *) &raw[3].s, size);
+    if (gconfig.debug_avp)
+    {
+        if (DEBUG)
+            l2tp_log (LOG_DEBUG,
+                 "%s: peer reports dialing number '%s'\n", __FUNCTION__,
+                 t->call_head->dialing);
+    }
+    return 0;
+}
+
+int dialed_number_avp (struct tunnel *t, struct call *c, void *data,
+                       int datalen)
+{
+    /*
+     * What is the peer's name?
+     */
+    int size;
+    struct unaligned_u16 *raw = data;
+
+#ifdef SANITY
+    if (t->sanity)
+    {
+        switch (c->msgtype)
+        {
+        case OCRQ:
+        case ICRQ:
+            break;
+        default:
+            if (DEBUG)
+                l2tp_log (LOG_DEBUG,
+                     "%s: dialed number not appropriate for message %s.  Ignoring.\n",
+                     __FUNCTION__, msgtypes[c->msgtype]);
+            return 0;
+        }
+        if (datalen < 6)
+        {
+            if (DEBUG)
+                l2tp_log (LOG_DEBUG,
+                     "%s: avp is too small.  %d < 6\n", __FUNCTION__,
+                     datalen);
+            wrong_length (c, "Dialed Number", 6, datalen, 1);
+            return -EINVAL;
+        }
+    }
+#endif
+    size = raw[0].s & 0x03FF;
+    size -= sizeof (struct avp_hdr);
+    if (size > MAXSTRLEN - 1)
+    {
+        if (DEBUG)
+            l2tp_log (LOG_DEBUG,
+                 "%s: truncating reported dialed number (size is %d)\n",
+                 __FUNCTION__, size);
+        size = MAXSTRLEN - 1;
+    }
+    safe_copy (t->call_head->dialed, (char *) &raw[3].s, size);
+    if (gconfig.debug_avp)
+    {
+        if (DEBUG)
+            l2tp_log (LOG_DEBUG,
+                 "%s: peer reports dialed number '%s'\n", __FUNCTION__,
+                 t->call_head->dialed);
+    }
+    return 0;
+}
+
+int sub_address_avp (struct tunnel *t, struct call *c, void *data,
+                     int datalen)
+{
+    /*
+     * What is the peer's name?
+     */
+    int size;
+    struct unaligned_u16 *raw = data;
+
+#ifdef SANITY
+    if (t->sanity)
+    {
+        switch (c->msgtype)
+        {
+        case OCRP:
+        case ICRQ:
+            break;
+        default:
+            if (DEBUG)
+                l2tp_log (LOG_DEBUG,
+                     "%s: sub_address not appropriate for message %s.  Ignoring.\n",
+                     __FUNCTION__, msgtypes[c->msgtype]);
+            return 0;
+        }
+        if (datalen < 6)
+        {
+            if (DEBUG)
+                l2tp_log (LOG_DEBUG,
+                     "%s: avp is too small.  %d < 6\n", __FUNCTION__,
+                     datalen);
+            wrong_length (c, "Sub-address", 6, datalen, 1);
+            return -EINVAL;
+        }
+    }
+#endif
+    size = raw[0].s & 0x03FF;
+    size -= sizeof (struct avp_hdr);
+    if (size > MAXSTRLEN - 1)
+    {
+        if (DEBUG)
+            l2tp_log (LOG_DEBUG,
+                 "%s: truncating reported sub address (size is %d)\n",
+                 __FUNCTION__, size);
+        size = MAXSTRLEN - 1;
+    }
+    safe_copy (t->call_head->subaddy, (char *) &raw[3].s, size);
+    if (gconfig.debug_avp)
+    {
+        if (DEBUG)
+            l2tp_log (LOG_DEBUG,
+                 "%s: peer reports subaddress '%s'\n", __FUNCTION__,
+                 t->call_head->subaddy);
+    }
+    return 0;
+}
+
+int vendor_avp (struct tunnel *t, struct call *c, void *data, int datalen)
+{
+    /*
+     * What vendor makes the other end?
+     */
+    int size;
+    struct unaligned_u16 *raw = data;
+
+#ifdef SANITY
+    if (t->sanity)
+    {
+        switch (c->msgtype)
+        {
+        case SCCRP:
+        case SCCRQ:
+            break;
+        default:
+            if (DEBUG)
+                l2tp_log (LOG_DEBUG,
+                     "%s: vendor not appropriate for message %s.  Ignoring.\n",
+                     __FUNCTION__, msgtypes[c->msgtype]);
+            return 0;
+        }
+        if (datalen < 6)
+        {
+            if (DEBUG)
+                l2tp_log (LOG_DEBUG,
+                     "%s: avp is too small.  %d < 6\n", __FUNCTION__,
+                     datalen);
+            wrong_length (c, "Vendor", 6, datalen, 1);
+            return -EINVAL;
+        }
+    }
+#endif
+    size = raw[0].s & 0x03FF;
+    size -= sizeof (struct avp_hdr);
+    if (size > MAXSTRLEN - 1)
+    {
+        if (DEBUG)
+            l2tp_log (LOG_DEBUG, "%s: truncating reported vendor (size is %d)\n",
+                 __FUNCTION__, size);
+        size = MAXSTRLEN - 1;
+    }
+    safe_copy (t->vendor, (char *) &raw[3].s, size);
+    if (gconfig.debug_avp)
+    {
+        if (DEBUG)
+            l2tp_log (LOG_DEBUG,
+                 "%s: peer reports vendor '%s'\n", __FUNCTION__, t->vendor);
+    }
+    return 0;
+}
+
+int challenge_avp (struct tunnel *t, struct call *c, void *data, int datalen)
+{
+    /*
+     * We are sent a challenge
+     */
+    struct unaligned_u16 *raw = data;
+    int size;
+#ifdef SANITY
+    if (t->sanity)
+    {
+        switch (c->msgtype)
+        {
+        case SCCRP:
+        case SCCRQ:
+            break;
+        default:
+            if (DEBUG)
+                l2tp_log (LOG_DEBUG,
+                     "%s: challenge not appropriate for message %s.  Ignoring.\n",
+                     __FUNCTION__, msgtypes[c->msgtype]);
+            return 0;
+        }
+        if (datalen < 6)
+        {
+            if (DEBUG)
+                l2tp_log (LOG_DEBUG,
+                     "%s: avp is too small.  %d < 6\n", __FUNCTION__,
+                     datalen);
+            wrong_length (c, "challenge", 6, datalen, 1);
+            return -EINVAL;
+        }
+    }
+#endif
+    /* size = raw[0].s & 0x0FFF; */
+    /* length field of AVP's is only 10 bits long, not 12 */
+    size = raw[0].s & 0x03FF;
+    size -= sizeof (struct avp_hdr);
+    /* if (size != MD_SIG_SIZE)
+    {
+        l2tp_log (LOG_DEBUG, "%s: Challenge is not the right length (%d != %d)\n",
+             __FUNCTION__, size, MD_SIG_SIZE);
+        return -EINVAL;
+    } */
+    if (t->chal_us.challenge)
+	free(t->chal_us.challenge);
+    t->chal_us.challenge = zalloc(size);
+    if (t->chal_us.challenge == NULL)
+    {
+        return -ENOMEM;
+    }
+    bcopy (&raw[3].s, (t->chal_us.challenge), size);
+    t->chal_us.chal_len = size;
+    t->chal_us.state = STATE_CHALLENGED;
+    if (gconfig.debug_avp)
+    {
+        l2tp_log (LOG_DEBUG, "%s: challenge avp found\n", __FUNCTION__);
+    }
+    return 0;
+}
+
+int chalresp_avp (struct tunnel *t, struct call *c, void *data, int datalen)
+{
+    /*
+     * We are sent a challenge
+     */
+    struct unaligned_u16 *raw = data;
+    int size;
+#ifdef SANITY
+    if (t->sanity)
+    {
+        switch (c->msgtype)
+        {
+        case SCCRP:
+        case SCCCN:
+            break;
+        default:
+            if (DEBUG)
+                l2tp_log (LOG_DEBUG,
+                     "%s: challenge response not appropriate for message %s.  Ignoring.\n",
+                     __FUNCTION__, msgtypes[c->msgtype]);
+            return 0;
+        }
+        if (datalen < 6)
+        {
+            if (DEBUG)
+                l2tp_log (LOG_DEBUG,
+                     "%s: avp is too small.  %d < 6\n", __FUNCTION__,
+                     datalen);
+            wrong_length (c, "challenge", 6, datalen, 1);
+            return -EINVAL;
+        }
+    }
+#endif
+    size = raw[0].s & 0x03FF;
+    size -= sizeof (struct avp_hdr);
+    if (size != MD_SIG_SIZE)
+    {
+        l2tp_log (LOG_DEBUG, "%s: Challenge is not the right length (%d != %d)\n",
+             __FUNCTION__, size, MD_SIG_SIZE);
+        return -EINVAL;
+    }
+
+    bcopy (&raw[3].s, t->chal_them.reply, MD_SIG_SIZE);
+    if (gconfig.debug_avp)
+    {
+        l2tp_log (LOG_DEBUG, "%s: Challenge reply found\n", __FUNCTION__);
+    }
+    return 0;
+}
+
+int assigned_tunnel_avp (struct tunnel *t, struct call *c, void *data,
+                         int datalen)
+{
+    /*
+     * What is their TID that we must use from now on?
+     */
+    struct unaligned_u16 *raw = data;
+
+#ifdef SANITY
+    if (t->sanity)
+    {
+        switch (c->msgtype)
+        {
+        case SCCRP:
+        case SCCRQ:
+        case StopCCN:
+            break;
+        default:
+            if (DEBUG)
+                l2tp_log (LOG_DEBUG,
+                     "%s: tunnel ID not appropriate for message %s.  Ignoring.\n",
+                     __FUNCTION__, msgtypes[c->msgtype]);
+            return 0;
+        }
+        if (datalen != 8)
+        {
+            if (DEBUG)
+                l2tp_log (LOG_DEBUG,
+                     "%s: avp is wrong size.  %d != 8\n", __FUNCTION__,
+                     datalen);
+            wrong_length (c, "Assigned Tunnel ID", 8, datalen, 0);
+            return -EINVAL;
+        }
+    }
+#endif
+    if (c->msgtype == StopCCN)
+    {
+        t->qtid = ntohs (raw[3].s);
+    }
+    else
+    {
+        t->tid = ntohs (raw[3].s);
+    }
+    if (gconfig.debug_avp)
+    {
+        if (DEBUG)
+            l2tp_log (LOG_DEBUG,
+                 "%s: using peer's tunnel %d\n", __FUNCTION__,
+                 ntohs (raw[3].s));
+    }
+    return 0;
+}
+
+int assigned_call_avp (struct tunnel *t, struct call *c, void *data,
+                       int datalen)
+{
+    /*
+     * What is their CID that we must use from now on?
+     */
+    struct unaligned_u16 *raw = data;
+
+#ifdef SANITY
+    if (t->sanity)
+    {
+        switch (c->msgtype)
+        {
+        case CDN:
+        case ICRP:
+        case ICRQ:
+        case OCRP:             /* jz: deleting the debug message */
+            break;
+        case OCRQ:
+        default:
+            if (DEBUG)
+                l2tp_log (LOG_DEBUG,
+                     "%s: call ID not appropriate for message %s.  Ignoring.\n",
+                     __FUNCTION__, msgtypes[c->msgtype]);
+            return 0;
+        }
+        if (datalen != 8)
+        {
+            if (DEBUG)
+                l2tp_log (LOG_DEBUG,
+                     "%s: avp is wrong size.  %d != 8\n", __FUNCTION__,
+                     datalen);
+            wrong_length (c, "Assigned Call ID", 8, datalen, 0);
+            return -EINVAL;
+        }
+    }
+#endif
+    if (c->msgtype == CDN)
+    {
+        c->qcid = ntohs (raw[3].s);
+    }
+    else if (c->msgtype == ICRQ)
+    {
+        t->call_head->cid = ntohs (raw[3].s);
+    }
+    else if (c->msgtype == ICRP)
+    {
+        c->cid = ntohs (raw[3].s);
+    }
+    else if (c->msgtype == OCRP)
+    {                           /* jz: copy callid to c->cid */
+        c->cid = ntohs (raw[3].s);
+    }
+    else
+    {
+        l2tp_log (LOG_DEBUG, "%s:  Dunno what to do when it's state %s!\n",
+             __FUNCTION__, msgtypes[c->msgtype]);
+    }
+    if (gconfig.debug_avp)
+    {
+        if (DEBUG)
+            l2tp_log (LOG_DEBUG,
+                 "%s: using peer's call %d\n", __FUNCTION__, ntohs (raw[3].s));
+    }
+    return 0;
+}
+
+int packet_delay_avp (struct tunnel *t, struct call *c, void *data,
+                      int datalen)
+{
+    /*
+     * What is their CID that we must use from now on?
+     */
+    struct unaligned_u16 *raw = data;
+
+#ifdef SANITY
+    if (t->sanity)
+    {
+        switch (c->msgtype)
+        {
+        case ICRP:
+        case OCRQ:
+        case ICCN:
+        case OCRP:
+        case OCCN:
+            break;
+        default:
+            if (DEBUG)
+                l2tp_log (LOG_DEBUG,
+                     "%s: packet delay not appropriate for message %s.  Ignoring.\n",
+                     __FUNCTION__, msgtypes[c->msgtype]);
+            return 0;
+        }
+        if (datalen != 8)
+        {
+            if (DEBUG)
+                l2tp_log (LOG_DEBUG,
+                     "%s: avp is wrong size.  %d != 8\n", __FUNCTION__,
+                     datalen);
+            wrong_length (c, "Assigned Call ID", 8, datalen, 0);
+            return -EINVAL;
+        }
+    }
+#endif
+    c->ppd = ntohs (raw[3].s);
+    if (gconfig.debug_avp)
+    {
+        if (DEBUG)
+            l2tp_log (LOG_DEBUG,
+                 "%s: peer's delay is %d 1/10's of a second\n", __FUNCTION__,
+                 ntohs (raw[3].s));
+    }
+    return 0;
+}
+
+int call_serno_avp (struct tunnel *t, struct call *c, void *data, int datalen)
+{
+    /*
+     * What is the serial number of the call?
+     */
+    struct unaligned_u16 *raw = data;
+
+#ifdef SANITY
+    if (t->sanity)
+    {
+        switch (c->msgtype)
+        {
+        case ICRQ:
+        case OCRQ:
+            break;
+        default:
+            if (DEBUG)
+                l2tp_log (LOG_DEBUG,
+                     "%s: call ID not appropriate for message %s.  Ignoring.\n",
+                     __FUNCTION__, msgtypes[c->msgtype]);
+            return 0;
+        }
+        if (datalen != 10)
+        {
+#ifdef STRICT
+            if (DEBUG)
+                l2tp_log (LOG_DEBUG,
+                     "%s: avp is wrong size.  %d != 10\n", __FUNCTION__,
+                     datalen);
+            wrong_length (c, "Serial Number", 10, datalen, 0);
+            return -EINVAL;
+#else
+            l2tp_log (LOG_DEBUG,
+                 "%s: peer is using old style serial number.  Will be invalid.\n",
+                 __FUNCTION__);
+#endif
+
+        }
+    }
+#endif
+    t->call_head->serno = (((unsigned int) ntohs (raw[3].s)) << 16) |
+        ((unsigned int) ntohs (raw[4].s));
+    if (gconfig.debug_avp)
+    {
+        if (DEBUG)
+            l2tp_log (LOG_DEBUG,
+                 "%s: serial number is %d\n", __FUNCTION__,
+                 t->call_head->serno);
+    }
+    return 0;
+}
+
+int rx_speed_avp (struct tunnel *t, struct call *c, void *data, int datalen)
+{
+    /*
+     * What is the received baud rate of the call?
+     */
+    struct unaligned_u16 *raw = data;
+
+#ifdef SANITY
+    if (t->sanity)
+    {
+        switch (c->msgtype)
+        {
+        case ICCN:
+        case OCCN:
+        case OCRP:
+            break;
+        default:
+            if (DEBUG)
+                l2tp_log (LOG_DEBUG,
+                     "%s: rx connect speed not appropriate for message %s.  Ignoring.\n",
+                     __FUNCTION__, msgtypes[c->msgtype]);
+            return 0;
+        }
+        if (datalen != 10)
+        {
+            if (DEBUG)
+                l2tp_log (LOG_DEBUG,
+                     "%s: avp is wrong size.  %d != 10\n", __FUNCTION__,
+                     datalen);
+            wrong_length (c, "Connect Speed (RX)", 10, datalen, 0);
+            return -EINVAL;
+        }
+    }
+#endif
+    c->rxspeed = (((unsigned int) ntohs (raw[3].s)) << 16) |
+        ((unsigned int) ntohs (raw[4].s));
+    if (gconfig.debug_avp)
+    {
+        if (DEBUG)
+            l2tp_log (LOG_DEBUG,
+                 "%s: receive baud rate is %d\n", __FUNCTION__, c->rxspeed);
+    }
+    return 0;
+}
+
+int tx_speed_avp (struct tunnel *t, struct call *c, void *data, int datalen)
+{
+    /*
+     * What is the tranmsit baud rate of the call?
+     */
+    struct unaligned_u16 *raw = data;
+
+#ifdef SANITY
+    if (t->sanity)
+    {
+        switch (c->msgtype)
+        {
+        case ICCN:
+        case OCCN:
+        case OCRP:
+            break;
+        default:
+            if (DEBUG)
+                l2tp_log (LOG_DEBUG,
+                     "%s: tx connect speed not appropriate for message %s.  Ignoring.\n",
+                     __FUNCTION__, msgtypes[c->msgtype]);
+            return 0;
+        }
+        if (datalen != 10)
+        {
+            if (DEBUG)
+                l2tp_log (LOG_DEBUG,
+                     "%s: avp is wrong size.  %d != 10\n", __FUNCTION__,
+                     datalen);
+            wrong_length (c, "Connect Speed (tx)", 10, datalen, 0);
+            return -EINVAL;
+        }
+    }
+#endif
+    c->txspeed = (((unsigned int) ntohs (raw[3].s)) << 16) |
+        ((unsigned int) ntohs (raw[4].s));
+    if (gconfig.debug_avp)
+    {
+        if (DEBUG)
+            l2tp_log (LOG_DEBUG,
+                 "%s: transmit baud rate is %d\n", __FUNCTION__, c->txspeed);
+    }
+    return 0;
+}
+int call_physchan_avp (struct tunnel *t, struct call *c, void *data,
+                       int datalen)
+{
+    /*
+     * What is the physical channel?
+     */
+    struct unaligned_u16 *raw = data;
+
+#ifdef SANITY
+    if (t->sanity)
+    {
+        switch (c->msgtype)
+        {
+        case ICRQ:
+        case OCRQ:
+        case OCRP:
+        case OCCN:
+            break;
+        default:
+            if (DEBUG)
+                l2tp_log (LOG_DEBUG,
+                     "%s: physical channel not appropriate for message %s.  Ignoring.\n",
+                     __FUNCTION__, msgtypes[c->msgtype]);
+            return 0;
+        }
+        if (datalen != 10)
+        {
+            if (DEBUG)
+                l2tp_log (LOG_DEBUG,
+                     "%s: avp is wrong size.  %d != 10\n", __FUNCTION__,
+                     datalen);
+            wrong_length (c, "Physical Channel", 10, datalen, 0);
+            return -EINVAL;
+        }
+    }
+#endif
+    t->call_head->physchan = (((unsigned int) ntohs (raw[3].s)) << 16) |
+        ((unsigned int) ntohs (raw[4].s));
+    if (gconfig.debug_avp)
+    {
+        if (DEBUG)
+            l2tp_log (LOG_DEBUG,
+                 "%s: physical channel is %d\n", __FUNCTION__,
+                 t->call_head->physchan);
+    }
+    return 0;
+}
+
+int receive_window_size_avp (struct tunnel *t, struct call *c, void *data,
+                             int datalen)
+{
+    /*
+     * What is their RWS?
+     */
+    struct unaligned_u16 *raw = data;
+
+#ifdef SANITY
+    if (t->sanity)
+    {
+        switch (c->msgtype)
+        {
+        case SCCRP:
+        case SCCRQ:
+        case OCRP:             /* jz */
+        case OCCN:             /* jz */
+        case StopCCN:
+/*		case ICRP:
+		case ICCN: */
+            break;
+        default:
+            if (DEBUG)
+                l2tp_log (LOG_DEBUG,
+                     "%s: RWS not appropriate for message %s.  Ignoring.\n",
+                     __FUNCTION__, msgtypes[c->msgtype]);
+            return 0;
+        }
+        if (datalen != 8)
+        {
+            if (DEBUG)
+                l2tp_log (LOG_DEBUG,
+                     "%s: avp is wrong size.  %d != 8\n", __FUNCTION__,
+                     datalen);
+            wrong_length (c, "Receive Window Size", 8, datalen, 0);
+            return -EINVAL;
+        }
+    }
+#endif
+    t->rws = ntohs (raw[3].s);
+/*	if (c->rws >= 0)
+		c->fbit = FBIT; */
+    if (gconfig.debug_avp)
+    {
+        if (DEBUG)
+            l2tp_log (LOG_DEBUG,
+                 "%s: peer wants RWS of %d.  Will use flow control.\n",
+                 __FUNCTION__, t->rws);
+    }
+    return 0;
+}
+
+
+int handle_avps (struct buffer *buf, struct tunnel *t, struct call *c)
+{
+    /*
+     * buf's start should point to the beginning of a packet. We assume it's
+     * a valid packet and has had check_control done to it, so no error
+     * checking is done at this point.
+     */
+
+    struct avp_hdr *avp;
+    int len = buf->len - sizeof (struct control_hdr);
+    int firstavp = -1;
+    int hidlen = 0;
+    char *data = buf->start + sizeof (struct control_hdr);
+    avp = (struct avp_hdr *) data;
+    if (gconfig.debug_avp)
+        l2tp_log (LOG_DEBUG, "%s: handling avp's for tunnel %d, call %d\n",
+             __FUNCTION__, t->ourtid, c->ourcid);
+    while (len > 0)
+    {
+        /* Go ahead and byte-swap the header */
+        swaps (avp, sizeof (struct avp_hdr));
+        if (avp->attr > AVP_MAX)
+        {
+            if (AMBIT (avp->length))
+            {
+                l2tp_log (LOG_WARNING,
+                     "%s:  dont know how to handle mandatory attribute %d.  Closing %s.\n",
+                     __FUNCTION__, avp->attr,
+                     (c != t->self) ? "call" : "tunnel");
+                set_error (c, VENDOR_ERROR,
+                           "mandatory attribute %d cannot be handled",
+                           avp->attr);
+                c->needclose = -1;
+                return -EINVAL;
+            }
+            else
+            {
+                if (DEBUG)
+                    l2tp_log (LOG_WARNING,
+                         "%s:  dont know how to handle atribute %d.\n",
+                         __FUNCTION__, avp->attr);
+                goto next;
+            }
+        }
+        if (ALENGTH (avp->length) > len)
+        {
+            l2tp_log (LOG_WARNING,
+                 "%s: AVP received with length > remaining packet length!\n",
+                 __FUNCTION__);
+            set_error (c, ERROR_LENGTH, "Invalid AVP length");
+            c->needclose = -1;
+            return -EINVAL;
+        }
+        if (avp->attr && firstavp)
+        {
+            l2tp_log (LOG_WARNING, "%s: First AVP was not message type.\n",
+                 __FUNCTION__);
+            set_error (c, VENDOR_ERROR, "First AVP must be message type");
+            c->needclose = -1;
+            return -EINVAL;
+        }
+        if (ALENGTH (avp->length) < sizeof (struct avp_hdr))
+        {
+            l2tp_log (LOG_WARNING, "%s: AVP with too small of size (%d).\n",
+                 __FUNCTION__, ALENGTH (avp->length));
+            set_error (c, ERROR_LENGTH, "AVP too small");
+            c->needclose = -1;
+            return -EINVAL;
+        }
+        if (AZBITS (avp->length))
+        {
+            l2tp_log (LOG_WARNING, "%s: %sAVP has reserved bits set.\n", __FUNCTION__,
+                 AMBIT (avp->length) ? "Mandatory " : "");
+            if (AMBIT (avp->length))
+            {
+                set_error (c, ERROR_RESERVED, "reserved bits set in AVP");
+                c->needclose = -1;
+                return -EINVAL;
+            }
+            goto next;
+        }
+        if (AHBIT (avp->length))
+        {
+#ifdef DEBUG_HIDDEN
+            l2tp_log (LOG_DEBUG, "%s: Hidden bit set on AVP.\n", __FUNCTION__);
+#endif
+            /* We want to rewrite the AVP as an unhidden AVP
+               and then pass it along as normal.  Remeber how
+               long the AVP was in the first place though! */
+            hidlen = avp->length;
+            if (decrypt_avp (data, t))
+            {
+                if (gconfig.debug_avp)
+                    l2tp_log (LOG_WARNING, "%s: Unable to handle hidden %sAVP\n:",
+                         __FUNCTION__,
+                         (AMBIT (avp->length) ? "mandatory " : ""));
+                if (AMBIT (avp->length))
+                {
+                    set_error (c, VENDOR_ERROR, "Invalid Hidden AVP");
+                    c->needclose = -1;
+                    return -EINVAL;
+                }
+                goto next;
+            };
+            len -= 2;
+            hidlen -= 2;
+            data += 2;
+            avp = (struct avp_hdr *) data;
+            /* Now we should look like a normal AVP */
+        }
+        else
+            hidlen = 0;
+        if (avps[avp->attr].handler)
+        {
+            if (avps[avp->attr].handler (t, c, avp, ALENGTH (avp->length)))
+            {
+                if (AMBIT (avp->length))
+                {
+                    l2tp_log (LOG_WARNING,
+                         "%s: Bad exit status handling attribute %d (%s) on mandatory packet.\n",
+                         __FUNCTION__, avp->attr,
+                         avps[avp->attr].description);
+                    c->needclose = -1;
+                    return -EINVAL;
+                }
+                else
+                {
+                    if (DEBUG)
+                        l2tp_log (LOG_DEBUG,
+                             "%s: Bad exit status handling attribute %d (%s).\n",
+                             __FUNCTION__, avp->attr,
+                             avps[avp->attr].description);
+                }
+            }
+        }
+        else
+        {
+            if (AMBIT (avp->length))
+            {
+                l2tp_log (LOG_WARNING,
+                     "%s:  No handler for mandatory attribute %d (%s).  Closing %s.\n",
+                     __FUNCTION__, avp->attr, avps[avp->attr].description,
+                     (c != t->self) ? "call" : "tunnel");
+                set_error (c, VENDOR_ERROR, "No handler for attr %d (%s)\n",
+                           avp->attr, avps[avp->attr].description);
+                return -EINVAL;
+            }
+            else
+            {
+                if (DEBUG)
+                    l2tp_log (LOG_WARNING, "%s:  no handler for atribute %d (%s).\n",
+                         __FUNCTION__, avp->attr,
+                         avps[avp->attr].description);
+            }
+        }
+      next:
+        if (hidlen)
+        {
+            /* Skip over the complete length of the hidden AVP */
+            len -= ALENGTH (hidlen);
+            data += ALENGTH (hidlen);
+        }
+        else
+        {
+            len -= ALENGTH (avp->length);
+            data += ALENGTH (avp->length);      /* Next AVP, please */
+        }
+        avp = (struct avp_hdr *) data;
+        firstavp = 0;
+    }
+    if (len != 0)
+    {
+        l2tp_log (LOG_WARNING, "%s: negative overall packet length\n", __FUNCTION__);
+        return -EINVAL;
+    }
+    return 0;
+}
--- ppp-2.4.4.orig/pppd/plugins/pppol2tp/avp.h	1970-01-01 03:00:00.000000000 +0300
+++ ppp-2.4.4/pppd/plugins/pppol2tp/avp.h	2011-01-24 13:53:48.000000000 +0300
@@ -0,0 +1,144 @@
+/*
+ * Layer Two Tunnelling Protocol Daemon
+ * Copyright (C) 1998 Adtran, Inc.
+ * Copyright (C) 2002 Jeff McAdams
+ *
+ * Mark Spencer
+ *
+ * This software is distributed under the terms
+ * of the GPL, which you should have received
+ * along with this source.
+ *
+ * Attribute Value Pair structures and
+ * definitions
+ */
+
+#include "common.h"
+
+struct avp_hdr
+{
+    _u16 length;
+    _u16 vendorid;
+    _u16 attr;
+} __attribute__((packed));
+
+struct avp
+{
+    int num;                    /* Number of AVP */
+    int m;                      /* Set M? */
+    int (*handler) (struct tunnel *, struct call *, void *, int);
+    /* This should handle the AVP
+       taking a tunnel, call, the data,
+       and the length of the AVP as
+       parameters.  Should return 0
+       upon success */
+    char *description;          /* A name, for debugging */
+};
+
+extern int handle_avps (struct buffer *buf, struct tunnel *t, struct call *c);
+
+extern char *msgtypes[];
+
+#define VENDOR_ID 0             /* We don't have any extensions
+                                   so we shoouldn't have to
+                                   worry about this */
+
+/*
+ * Macros to extract information from length field of AVP
+ */
+
+#define AMBIT(len) (len & 0x8000)       /* Mandatory bit: If this is
+                                           set on an unknown AVP, 
+                                           we MUST terminate */
+
+#define AHBIT(len) (len & 0x4000)       /* Hidden bit: Specifies
+                                           information hiding */
+
+#define AZBITS(len) (len & 0x3C00)      /* Reserved bits:  We must
+                                           drop anything with any
+                                           of these set.  */
+
+#define ALENGTH(len) (len & 0x03FF)     /* Length:  Lenth of AVP */
+
+#define MAXAVPSIZE 1023
+
+#define MAXTIME 300             /* time to wait before checking
+                                   Ns and Nr, in ms */
+
+#define MBIT 0x8000             /* for setting */
+#define HBIT 0x4000             /* Set on hidden avp's */
+
+#define ASYNC_FRAMING 2
+#define SYNC_FRAMING 1
+
+#define ANALOG_BEARER 2
+#define DIGITAL_BEARER 1
+
+#define VENDOR_ERROR 6
+
+#define ERROR_RESERVED 3
+#define ERROR_LENGTH 2
+#define ERROR_NOTEXIST 1
+#define ERROR_NORES 4
+#define ERROR_INVALID 6
+#define RESULT_CLEAR 1
+#define RESULT_ERROR 2
+#define RESULT_EXISTS 3
+extern void encrypt_avp (struct buffer *, _u16, struct tunnel *);
+extern int decrypt_avp (char *, struct tunnel *);
+extern int message_type_avp (struct tunnel *, struct call *, void *, int);
+extern int protocol_version_avp (struct tunnel *, struct call *, void *, int);
+extern int framing_caps_avp (struct tunnel *, struct call *, void *, int);
+extern int bearer_caps_avp (struct tunnel *, struct call *, void *, int);
+extern int firmware_rev_avp (struct tunnel *, struct call *, void *, int);
+extern int hostname_avp (struct tunnel *, struct call *, void *, int);
+extern int vendor_avp (struct tunnel *, struct call *, void *, int);
+extern int assigned_tunnel_avp (struct tunnel *, struct call *, void *, int);
+extern int receive_window_size_avp (struct tunnel *, struct call *, void *,
+                                    int);
+extern int result_code_avp (struct tunnel *, struct call *, void *, int);
+extern int assigned_call_avp (struct tunnel *, struct call *, void *, int);
+extern int call_serno_avp (struct tunnel *, struct call *, void *, int);
+extern int bearer_type_avp (struct tunnel *, struct call *, void *, int);
+extern int call_physchan_avp (struct tunnel *, struct call *, void *, int);
+extern int dialed_number_avp (struct tunnel *, struct call *, void *, int);
+extern int dialing_number_avp (struct tunnel *, struct call *, void *, int);
+extern int sub_address_avp (struct tunnel *, struct call *, void *, int);
+extern int frame_type_avp (struct tunnel *, struct call *, void *, int);
+extern int rx_speed_avp (struct tunnel *, struct call *, void *, int);
+extern int tx_speed_avp (struct tunnel *, struct call *, void *, int);
+extern int packet_delay_avp (struct tunnel *, struct call *, void *, int);
+extern int ignore_avp (struct tunnel *, struct call *, void *, int);
+extern int seq_reqd_avp (struct tunnel *, struct call *, void *, int);
+extern int challenge_avp (struct tunnel *, struct call *, void *, int);
+extern int chalresp_avp (struct tunnel *, struct call *, void *, int);
+extern int rand_vector_avp (struct tunnel *, struct call *, void *, int);
+
+extern int add_challenge_avp (struct buffer *, unsigned char *, int);
+extern int add_avp_rws (struct buffer *, _u16);
+extern int add_tunnelid_avp (struct buffer *, _u16);
+extern int add_vendor_avp (struct buffer *);
+extern int add_hostname_avp (struct buffer *, const char *);
+extern int add_firmware_avp (struct buffer *);
+extern int add_bearer_caps_avp (struct buffer *buf, _u16 caps);
+extern int add_frame_caps_avp (struct buffer *buf, _u16 caps);
+extern int add_protocol_avp (struct buffer *buf);
+extern int add_message_type_avp (struct buffer *buf, _u16 type);
+extern int add_result_code_avp (struct buffer *buf, _u16, _u16, char *, int);
+extern int add_bearer_avp (struct buffer *, int);
+extern int add_frame_avp (struct buffer *, int);
+extern int add_rxspeed_avp (struct buffer *, int);
+extern int add_txspeed_avp (struct buffer *, int);
+extern int add_serno_avp (struct buffer *, unsigned int);
+#ifdef TEST_HIDDEN
+extern int add_callid_avp (struct buffer *, _u16, struct tunnel *);
+#else
+extern int add_callid_avp (struct buffer *, _u16);
+#endif
+extern int add_ppd_avp (struct buffer *, _u16);
+extern int add_seqreqd_avp (struct buffer *);
+extern int add_chalresp_avp (struct buffer *, unsigned char *, int);
+extern int add_randvect_avp (struct buffer *, unsigned char *, int);
+extern int add_minbps_avp (struct buffer *buf, int speed);      /* jz: needed for outgoing call */
+extern int add_maxbps_avp (struct buffer *buf, int speed);      /* jz: needed for outgoing call */
+extern int add_number_avp (struct buffer *buf, char *no);       /* jz: needed for outgoing call */
--- ppp-2.4.4.orig/pppd/plugins/pppol2tp/avpsend.c	1970-01-01 03:00:00.000000000 +0300
+++ ppp-2.4.4/pppd/plugins/pppol2tp/avpsend.c	2011-01-24 13:53:48.000000000 +0300
@@ -0,0 +1,294 @@
+/*
+ * Layer Two Tunnelling Protocol Daemon
+ * Copyright (C) 1998 Adtran, Inc.
+ * Copyright (C) 2002 Jeff McAdams
+ *
+ * Mark Spencer
+ *
+ * This software is distributed under the terms
+ * of the GPL, which you should have received
+ * along with this source.
+ *
+ * Attribute Value Pair creating routines
+ */
+
+#include <stdlib.h>
+#include <string.h>
+#include <netinet/in.h>
+#include "l2tp.h"
+
+struct half_words {
+	_u16 s0;
+	_u16 s1;
+	_u16 s2;
+	_u16 s3;
+} __attribute__ ((packed));
+
+void add_header(struct buffer *buf, _u8 length, _u16 type) {
+	struct avp_hdr *avp = (struct avp_hdr *) (buf->start + buf->len);
+	avp->length = htons (length | MBIT);
+	avp->vendorid = htons (VENDOR_ID);
+	avp->attr = htons (type);
+}
+
+/* 
+ * These routines should add avp's to a buffer
+ * to be sent
+ */
+
+/* FIXME:  If SANITY is on, we should check for buffer overruns */
+
+int add_message_type_avp (struct buffer *buf, _u16 type)
+{
+	struct half_words *ptr = (struct half_words *) (buf->start + buf->len + sizeof(struct avp_hdr));
+	add_header(buf, 0x8, 0);
+	ptr->s0 = htons(type);
+    buf->len += 0x8;
+    return 0;
+}
+
+int add_protocol_avp (struct buffer *buf)
+{
+    struct half_words *ptr = (struct half_words *) (buf->start + buf->len + sizeof(struct avp_hdr));
+    add_header(buf, 0x8, 0x2);        /* Length and M bit */
+    ptr->s0 = htons (OUR_L2TP_VERSION);
+    buf->len += 0x8;
+    return 0;
+}
+
+int add_frame_caps_avp (struct buffer *buf, _u16 caps)
+{
+    struct half_words *ptr = (struct half_words *) (buf->start + buf->len + sizeof(struct avp_hdr));
+    add_header(buf, 0xA, 0x3);
+    ptr->s0 = 0;
+    ptr->s1 = htons (caps);
+    buf->len += 0xA;
+    return 0;
+}
+
+int add_bearer_caps_avp (struct buffer *buf, _u16 caps)
+{
+    struct half_words *ptr = (struct half_words *) (buf->start + buf->len + sizeof(struct avp_hdr));
+    add_header(buf, 0xA, 0x4);
+    ptr->s0 = 0;
+    ptr->s1 = htons (caps);
+    buf->len += 0xA;
+    return 0;
+}
+
+/* FIXME: I need to send tie breaker AVP's */
+
+int add_firmware_avp (struct buffer *buf)
+{
+    struct half_words *ptr = (struct half_words *) (buf->start + buf->len + sizeof(struct avp_hdr));
+    add_header(buf, 0x8, 0x6);
+    ptr->s0 = htons (FIRMWARE_REV);
+    buf->len += 0x8;
+    return 0;
+}
+
+int add_hostname_avp (struct buffer *buf, const char *hostname)
+{
+    size_t namelen = strlen(hostname);
+    if (namelen > MAXAVPSIZE - 6) {
+        namelen = MAXAVPSIZE - 6;
+    }
+    add_header(buf, 0x6 + namelen, 0x7);
+    strncpy ((char *) (buf->start + buf->len + sizeof(struct avp_hdr)),
+	     hostname, namelen);
+    buf->len += 0x6 + namelen;
+    return 0;
+}
+
+int add_vendor_avp (struct buffer *buf)
+{
+    add_header(buf, 0x6 + strlen (VENDOR_NAME), 0x8);
+    strcpy ((char *) (buf->start + buf->len + sizeof(struct avp_hdr)), VENDOR_NAME);
+    buf->len += 0x6 + strlen (VENDOR_NAME);
+    return 0;
+}
+
+int add_tunnelid_avp (struct buffer *buf, _u16 tid)
+{
+    struct half_words *ptr = (struct half_words *) (buf->start + buf->len + sizeof(struct avp_hdr));
+    add_header(buf, 0x8, 0x9);
+    ptr->s0 = htons (tid);
+    buf->len += 0x8;
+    return 0;
+}
+
+int add_avp_rws (struct buffer *buf, _u16 rws)
+{
+    struct half_words *ptr = (struct half_words *) (buf->start + buf->len + sizeof(struct avp_hdr));
+    add_header(buf, 0x8, 0xA);
+    ptr->s0 = htons (rws);
+    buf->len += 0x8;
+    return 0;
+}
+
+int add_challenge_avp (struct buffer *buf, unsigned char *c, int len)
+{
+    add_header(buf, (0x6 + len), 0xB);
+    memcpy((char *) (buf->start + buf->len + sizeof(struct avp_hdr)), c, len);
+    buf->len += 0x6 + len;
+    return 0;
+}
+
+int add_chalresp_avp (struct buffer *buf, unsigned char *c, int len)
+{
+    add_header(buf, (0x6 + len), 0xD);
+    memcpy((char *) (buf->start + buf->len + sizeof(struct avp_hdr)), c, len);
+    buf->len += 0x6 + len;
+    return 0;
+}
+
+int add_randvect_avp (struct buffer *buf, unsigned char *c, int len)
+{
+    add_header(buf, (0x6 + len), 0x24);
+    memcpy((char *) (buf->start + buf->len + sizeof(struct avp_hdr)), c, len);
+    buf->len += 0x6 + len;
+    return 0;
+}
+
+int add_result_code_avp (struct buffer *buf, _u16 result, _u16 error,
+                         char *msg, int len)
+{
+    struct half_words *ptr = (struct half_words *) (buf->start + buf->len + sizeof(struct avp_hdr));
+    add_header(buf, (0xA + len), 0x1);
+    ptr->s0 = htons (result);
+    ptr->s1 = htons (error);
+    memcpy ((char *) &ptr->s2, msg, len);
+    buf->len += 0xA + len;
+    return 0;
+}
+
+#ifdef TEST_HIDDEN
+int add_callid_avp (struct buffer *buf, _u16 callid, struct tunnel *t)
+{
+#else
+int add_callid_avp (struct buffer *buf, _u16 callid)
+{
+#endif
+    struct half_words *ptr = (struct half_words *) (buf->start + buf->len + sizeof(struct avp_hdr));
+#ifdef TEST_HIDDEN
+    if (t->hbit)
+        raw++;
+#endif
+    add_header(buf, 0x8, 0xE);
+    ptr->s0 = htons (callid);
+    buf->len += 0x8;
+#ifdef TEST_HIDDEN
+    if (t->hbit)
+        encrypt_avp (buf, 8, t);
+#endif
+    return 0;
+}
+
+int add_serno_avp (struct buffer *buf, unsigned int serno)
+{
+    struct half_words *ptr = (struct half_words *) (buf->start + buf->len + sizeof(struct avp_hdr));
+    add_header(buf, 0xA, 0xF);
+    ptr->s0 = htons ((serno >> 16) & 0xFFFF);
+    ptr->s1 = htons (serno & 0xFFFF);
+    buf->len += 0xA;
+    return 0;
+}
+
+int add_bearer_avp (struct buffer *buf, int bearer)
+{
+    struct half_words *ptr = (struct half_words *) (buf->start + buf->len + sizeof(struct avp_hdr));
+    add_header(buf, 0xA, 0x12);
+    ptr->s0 = htons ((bearer >> 16) & 0xFFFF);
+    ptr->s1 = htons (bearer & 0xFFFF);
+    buf->len += 0xA;
+    return 0;
+}
+
+int add_frame_avp (struct buffer *buf, int frame)
+{
+    struct half_words *ptr = (struct half_words *) (buf->start + buf->len + sizeof(struct avp_hdr));
+    add_header(buf, 0xA, 0x13);
+    ptr->s0 = htons ((frame >> 16) & 0xFFFF);
+    ptr->s1 = htons (frame & 0xFFFF);
+    buf->len += 0xA;
+    return 0;
+}
+
+int add_txspeed_avp (struct buffer *buf, int speed)
+{
+    struct half_words *ptr = (struct half_words *) (buf->start + buf->len + sizeof(struct avp_hdr));
+    add_header(buf, 0xA, 0x18);
+    ptr->s0 = htons ((speed >> 16) & 0xFFFF);
+    ptr->s1 = htons (speed & 0xFFFF);
+    buf->len += 0xA;
+    return 0;
+}
+
+int add_rxspeed_avp (struct buffer *buf, int speed)
+{
+    struct half_words *ptr = (struct half_words *) (buf->start + buf->len + sizeof(struct avp_hdr));
+    add_header(buf, 0xA, 0x26);
+    ptr->s0 = htons ((speed >> 16) & 0xFFFF);
+    ptr->s1 = htons (speed & 0xFFFF);
+    buf->len += 0xA;
+    return 0;
+}
+
+int add_physchan_avp (struct buffer *buf, unsigned int physchan)
+{
+    struct half_words *ptr = (struct half_words *) (buf->start + buf->len + sizeof(struct avp_hdr));
+    add_header(buf, 0xA, 0x19);
+    ptr->s0 = htons ((physchan >> 16) & 0xFFFF);
+    ptr->s1 = htons (physchan & 0xFFFF);
+    buf->len += 0xA;
+    return 0;
+}
+
+int add_ppd_avp (struct buffer *buf, _u16 ppd)
+{
+    struct half_words *ptr = (struct half_words *) (buf->start + buf->len + sizeof(struct avp_hdr));
+    add_header(buf, 0x8, 0x14);
+    ptr->s0 = htons (ppd);
+    buf->len += 0x8;
+    return 0;
+}
+
+int add_seqreqd_avp (struct buffer *buf)
+{
+    add_header(buf, 0x6, 0x27);
+    buf->len += 0x6;
+    return 0;
+}
+
+/* jz: options dor the outgoing call */
+
+/* jz: Minimum BPS - 16 */
+int add_minbps_avp (struct buffer *buf, int speed)
+{
+    struct half_words *ptr = (struct half_words *) (buf->start + buf->len + sizeof(struct avp_hdr));
+    add_header(buf, 0xA, 0x10);
+    ptr->s0 = htons ((speed >> 16) & 0xFFFF);
+    ptr->s1 = htons (speed & 0xFFFF);
+    buf->len += 0xA;
+    return 0;
+}
+
+/* jz: Maximum BPS - 17 */
+int add_maxbps_avp (struct buffer *buf, int speed)
+{
+    struct half_words *ptr = (struct half_words *) (buf->start + buf->len + sizeof(struct avp_hdr));
+    add_header(buf, 0xA, 0x11);
+    ptr->s0 = htons ((speed >> 16) & 0xFFFF);
+    ptr->s1 = htons (speed & 0xFFFF);
+    buf->len += 0xA;
+    return 0;
+}
+
+/* jz: Dialed Number 21 */
+int add_number_avp (struct buffer *buf, char *no)
+{
+    add_header(buf, (0x6 + strlen (no)), 0x15);
+    strncpy ((char *) (buf->start + buf->len + sizeof(struct avp_hdr)), no, strlen (no));
+    buf->len += 0x6 + strlen (no);
+    return 0;
+}
--- ppp-2.4.4.orig/pppd/plugins/pppol2tp/call.c	1970-01-01 03:00:00.000000000 +0300
+++ ppp-2.4.4/pppd/plugins/pppol2tp/call.c	2011-01-24 13:53:48.000000000 +0300
@@ -0,0 +1,656 @@
+/*
+ * Layer Two Tunnelling Protocol Daemon
+ * Copyright (C) 1998 Adtran, Inc.
+ * Copyright (C) 2002 Jeff McAdams
+ *
+ * Mark Spencer
+ *
+ * This software is distributed under the terms
+ * of the GPL, which you should have received
+ * along with this source.
+ *
+ * Handle a call as a separate thread
+ */
+
+#include <stdio.h>
+#include <fcntl.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <sys/wait.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <errno.h>
+#include <signal.h>
+#include <termios.h>
+#include "l2tp.h"
+
+#include "ipsecmast.h"
+
+struct buffer *new_payload (struct sockaddr_in peer)
+{
+    struct buffer *tmp = new_buf (MAX_RECV_SIZE);
+    if (!tmp)
+        return NULL;
+    tmp->peer = peer;
+    tmp->start += sizeof (struct payload_hdr);
+    tmp->len = 0;
+    return tmp;
+}
+
+inline void recycle_payload (struct buffer *buf, struct sockaddr_in peer)
+{
+    buf->start = buf->rstart + sizeof (struct payload_hdr);
+    buf->len = 0;
+    buf->peer = peer;
+}
+
+void add_payload_hdr (struct tunnel *t, struct call *c, struct buffer *buf)
+{
+    struct payload_hdr *p;
+    buf->start -= sizeof (struct payload_hdr);
+    buf->len += sizeof (struct payload_hdr);
+    /* Account for no offset */
+    buf->start += 4;
+    buf->len -= 4;
+    if (!c->fbit && !c->ourfbit)
+    {
+        /* Forget about Ns and Nr fields then */
+        buf->start += 4;
+        buf->len -= 4;
+    }
+    if (!c->lbit)
+    {
+        /* Forget about specifying the length */
+        buf->start += 2;
+        buf->len -= 2;
+    }
+    p = (struct payload_hdr *) buf->start;
+/*	p->ver = htons(c->lbit | c->rbit | c->fbit | c->ourfbit | VER_L2TP); */
+    p->ver = htons (c->lbit | c->fbit | c->ourfbit | VER_L2TP);
+    if (c->lbit)
+    {
+        p->length = htons ((_u16) buf->len);
+    }
+    else
+    {
+        p = (struct payload_hdr *) (((char *) p) - 2);
+    }
+    p->tid = htons (t->tid);
+    p->cid = htons (c->cid);
+    if (c->fbit || c->ourfbit)
+    {
+        p->Ns = htons (c->data_seq_num);
+        p->Nr = htons (c->data_rec_seq_num);
+    }
+    c->data_seq_num++;
+/*	c->rbit=0; */
+}
+
+int call_read_packet (struct buffer *buf, int fd, int convert)
+{
+    unsigned char c;
+    unsigned char escape = 0;
+    unsigned char *p;
+    static unsigned char rbuf[MAX_RECV_SIZE];
+    static int pos = 0;
+    static int max = 0;
+    int res;
+    int errors = 0;
+
+    /* Read a packet, doing async->sync conversion if necessary */
+    p = buf->start;
+    while (1)
+    {
+        if (pos >= max)
+        {
+            max = read(fd, rbuf, sizeof (rbuf));
+            res = max;
+            pos = 0;
+        }
+        else
+        {
+            res = 1;
+        }
+
+        c = rbuf[pos++];
+
+	/* if there was a short read, then see what is about */
+        if (res < 1)
+        {
+            if (res == 0)
+            {
+                /*
+                   * Hmm..  Nothing to read.  It happens
+                 */
+                return 0;
+            }
+            else if ((errno == EIO) || (errno == EINTR) || (errno == EAGAIN))
+            {
+
+                /*
+                   * Oops, we were interrupted!
+                   * Or, we ran out of data too soon
+                   * anyway, we discared whatever it is we
+                   * have
+                 */
+                return 0;
+            }
+            errors++;
+            l2tp_log (LOG_DEBUG, "%s: Error %d (%s)\n", __FUNCTION__, errno,
+                 strerror (errno));
+            if (errors > 10)
+            {
+                l2tp_log (LOG_DEBUG,
+                     "%s: Too many errors.  Declaring call dead.\n",
+                     __FUNCTION__);
+		pos=0;
+		max=0;
+                return -errno;
+            }
+            continue;
+        }
+
+        switch (c)
+        {
+        case PPP_FLAG:
+            if (escape)
+            {
+                l2tp_log (LOG_DEBUG, "%s: got an escaped PPP_FLAG\n",
+                     __FUNCTION__);
+		pos=0;
+		max=0;
+                return -EINVAL;
+            }
+
+            if (convert)
+            {
+	      if (buf->len >= 2) {
+		/* must be the end, drop the FCS */
+		buf->len -= 2;
+	      }
+	      else if (buf->len == 1) {
+		/* Do nothing, just return the single character*/
+	      }
+	      else {
+		/* if the buffer is empty, then we have the beginning
+		 * of a packet, not the end
+		 */
+		break;
+	      }
+	    }
+            else
+            {
+		/* if there is space, then insert the byte */
+                if (buf->len < buf->maxlen)
+                {
+                    *p = c;
+                    p++;
+                    buf->len++;
+                }
+            }
+
+	    /* return what we have now */
+            return buf->len;
+
+        case PPP_ESCAPE:
+            escape = PPP_TRANS;
+            if (convert)
+                break;
+
+	    /* fall through */
+        default:
+            if (convert)
+                c ^= escape;
+            escape = 0;
+            if (buf->len < buf->maxlen)
+            {
+                *p = c;
+                p++;
+                buf->len++;
+                break;
+            }
+            l2tp_log (LOG_WARNING, "%s: read overrun\n", __FUNCTION__);
+	    pos=0;
+	    max=0;
+            return -EINVAL;
+        }
+    }
+
+    /* I should never get here */
+    l2tp_log (LOG_WARNING, "%s: You should not see this message.  If you do, please enter "
+			"a bug report at http://lists.xelerance.com/mailman/listinfo/xl2tpd", __FUNCTION__);
+    return -EINVAL;
+}
+
+void call_close (struct call *c)
+{
+    struct buffer *buf;
+    struct schedule_entry *se, *ose;
+    struct call *tmp, *tmp2;
+    if (!c || !c->container)
+    {
+        l2tp_log (LOG_DEBUG, "%s: called on null call or containerless call\n",
+             __FUNCTION__);
+        return;
+    }
+    if (c == c->container->self)
+    {
+        /*
+         * We're actually closing the
+         * entire tunnel
+         */
+
+        /* First deschedule any remaining packet transmissions
+           for this tunnel.  That means Hello's and any reminaing
+           packets scheduled for transmission.  This is a very
+           nasty little piece of code here. */
+
+        se = events;
+        ose = NULL;
+        while (se)
+        {
+            if ((((struct buffer *) se->data)->tunnel == c->container)
+                || ((struct tunnel *) se->data == c->container))
+            {
+#ifdef DEBUG_CLOSE
+                l2tp_log (LOG_DEBUG, "%s: Descheduling event\n", __FUNCTION__);
+#endif
+                if (ose)
+                {
+                    ose->next = se->next;
+                    if ((struct tunnel *) se->data != c->container)
+                        toss ((struct buffer *) (se->data));
+                    free (se);
+                    se = ose->next;
+                }
+                else
+                {
+                    events = se->next;
+                    if ((struct tunnel *) se->data != c->container)
+                        toss ((struct buffer *) (se->data));
+                    free (se);
+                    se = events;
+                }
+            }
+            else
+            {
+                ose = se;
+                se = se->next;
+            }
+        }
+
+        if (c->closing)
+        {
+            /* Really close this tunnel, as our
+               StopCCN has been ack'd */
+#ifdef DEBUG_CLOSE
+            l2tp_log (LOG_DEBUG, "%s: Actually closing tunnel %d\n", __FUNCTION__,
+                 c->container->ourtid);
+#endif
+            destroy_tunnel (c->container);
+            return;
+        }
+
+        /*
+           * We need to close, but need to provide reliable delivery
+           * of the final StopCCN. We record our state to know when
+           * we have actually received an ACK on our StopCCN
+         */
+        c->closeSs = c->container->control_seq_num;
+        buf = new_outgoing (c->container);
+        add_message_type_avp (buf, StopCCN);
+        if (c->container->hbit)
+        {
+            mk_challenge (c->container->chal_them.vector, VECTOR_SIZE);
+            add_randvect_avp (buf, c->container->chal_them.vector,
+                              VECTOR_SIZE);
+        }
+        add_tunnelid_avp (buf, c->container->ourtid);
+        if (c->result < 0)
+            c->result = RESULT_CLEAR;
+        if (c->error < 0)
+            c->error = 0;
+        add_result_code_avp (buf, c->result, c->error, c->errormsg,
+                             strlen (c->errormsg));
+        add_control_hdr (c->container, c, buf);
+        if (gconfig.packet_dump)
+            do_packet_dump (buf);
+#ifdef DEBUG_CLOSE
+        l2tp_log (LOG_DEBUG, "%s: enqueing close message for tunnel\n",
+             __FUNCTION__);
+#endif
+	control_xmit (buf);
+        /*
+           * We also need to stop all traffic on any calls contained
+           * within us.
+         */
+        tmp = c->container->call_head;
+        while (tmp)
+        {
+            tmp2 = tmp->next;
+            tmp->needclose = 0;
+            tmp->closing = -1;
+            call_close (tmp);
+            tmp = tmp2;
+        }
+        l2tp_log (LOG_INFO,
+             "Connection %d closed to %s, port %d (%s)\n", 
+             c->container->tid,
+             IPADDY (c->container->peer.sin_addr),
+             ntohs (c->container->peer.sin_port), c->errormsg);
+    }
+    else
+    {
+        /*
+           * Just close a call
+         */
+        if (c->zlb_xmit)
+            deschedule (c->zlb_xmit);
+/*		if (c->dethrottle) deschedule(c->dethrottle); */
+        if (c->closing)
+        {
+#ifdef DEBUG_CLOSE
+            l2tp_log (LOG_DEBUG, "%s: Actually closing call %d\n", __FUNCTION__,
+                 c->ourcid);
+#endif
+            destroy_call (c);
+            return;
+        }
+        c->closeSs = c->container->control_seq_num;
+        buf = new_outgoing (c->container);
+        add_message_type_avp (buf, CDN);
+        if (c->container->hbit)
+        {
+            mk_challenge (c->container->chal_them.vector, VECTOR_SIZE);
+            add_randvect_avp (buf, c->container->chal_them.vector,
+                              VECTOR_SIZE);
+        }
+        if (c->result < 0)
+            c->result = RESULT_CLEAR;
+        if (c->error < 0)
+            c->error = 0;
+        add_result_code_avp (buf, c->result, c->error, c->errormsg,
+                             strlen (c->errormsg));
+#ifdef TEST_HIDDEN
+        add_callid_avp (buf, c->ourcid, c->container);
+#else
+        add_callid_avp (buf, c->ourcid);
+#endif
+        add_control_hdr (c->container, c, buf);
+        if (gconfig.packet_dump)
+            do_packet_dump (buf);
+#ifdef DEBUG_CLOSE
+        l2tp_log (LOG_DEBUG, "%s: enqueuing close message for call %d\n",
+             __FUNCTION__, c->ourcid);
+#endif
+	control_xmit (buf);
+        l2tp_log (LOG_INFO, "%s: Call %d to %s disconnected\n", __FUNCTION__,
+             c->ourcid, IPADDY (c->container->peer.sin_addr));
+    }
+    /*
+       * Note that we're in the process of closing now
+     */
+    c->closing = -1;
+}
+
+void destroy_call (struct call *c)
+{
+    /*
+     * Here, we unconditionally destroy a call.
+     */
+
+    struct call *p;
+    struct timeval tv;
+    pid_t pid;
+    /*
+     * Close the tty
+     */
+    if (c->fd > 0)
+        close (c->fd);
+/*	if (c->dethrottle) deschedule(c->dethrottle); */
+    if (c->zlb_xmit)
+        deschedule (c->zlb_xmit);
+
+    /*
+     * Kill off pppd and wait for it to 
+     * return to us.  This should only be called
+     * in rare cases if pppd hasn't already died
+     * voluntarily
+     */
+    pid = c->pppd;
+    if (pid)
+    {
+        /* Set c->pppd to zero to prevent recursion with child_handler */
+        c->pppd = 0;
+	/* There is a bug in some pppd versions where sending a SIGTERM
+	   does not actually seem to kill pppd, and xl2tpd waits indefinately
+	   using waitpid, not accepting any new connections either. Therefor
+	   we now use some more force and send it a SIGKILL instead of SIGTERM.
+	   One confirmed buggy version of pppd is ppp-2.4.2-6.4.RHEL4
+	   See http://bugs.xelerance.com/view.php?id=739
+	*/
+	stop_pppd(0);
+    }
+
+    if (c->container)
+    {
+        p = c->container->call_head;
+        /*
+         * Remove us from the call list, although
+         * we might not actually be there
+         */
+        if (p)
+        {
+            if (p == c)
+            {
+                c->container->call_head = c->next;
+                c->container->count--;
+            }
+            else
+            {
+                while (p->next && (p->next != c))
+                    p = p->next;
+                if (p->next)
+                {
+                    p->next = c->next;
+                    c->container->count--;
+                }
+            }
+        }
+    }
+    if (c->lac) {
+        c->lac->c = NULL;
+    }
+
+    free (c);
+
+}
+
+
+struct call *new_call (struct tunnel *parent)
+{
+    unsigned char entropy_buf[2] = "\0";
+    struct call *tmp = zalloc (sizeof (struct call));
+
+    if (!tmp)
+        return NULL;
+    tmp->tx_pkts = 0;
+    tmp->rx_pkts = 0;
+    tmp->tx_bytes = 0;
+    tmp->rx_bytes = 0;
+    tmp->zlb_xmit = NULL;
+/*	tmp->throttle = 0; */
+/*	tmp->dethrottle=NULL; */
+    tmp->prx = 0;
+/*	tmp->rbit = 0; */
+    tmp->msgtype = 0;
+/*	tmp->timeout = 0; */
+    tmp->data_seq_num = 0;
+    tmp->data_rec_seq_num = 0;
+    tmp->pLr = -1;
+    tmp->nego = 0;
+    tmp->debug = 0;
+    tmp->seq_reqd = 0;
+    tmp->state = 0;             /* Nothing so far */
+    if (parent->self)
+    {
+#ifndef TESTING
+/*	while(get_call(parent->ourtid, (tmp->ourcid = (rand() && 0xFFFF)),0,0)); */
+            /* FIXME: What about possibility of multiple random #'s??? */
+            /* tmp->ourcid = (rand () & 0xFFFF); */
+            get_entropy(entropy_buf, 2);
+        {
+            unsigned short *temp;
+            temp = (unsigned short *)entropy_buf;
+            tmp->ourcid = *temp & 0xFFFF;
+#ifdef DEBUG_ENTROPY
+            l2tp_log(LOG_DEBUG, "ourcid = %u, entropy_buf = %hx\n", tmp->ourcid, *temp);
+#endif
+        }
+#else
+        tmp->ourcid = 0x6227;
+#endif
+    }
+    tmp->dialed[0] = 0;
+    tmp->dialing[0] = 0;
+    tmp->subaddy[0] = 0;
+    tmp->physchan = -1;
+    tmp->serno = 0;
+    tmp->bearer = -1;
+    tmp->cid = -1;
+    tmp->qcid = -1;
+    tmp->container = parent;
+/*	tmp->rws = -1; */
+    tmp->fd = -1;
+    tmp->pnu = 0;
+    tmp->cnu = 0;
+    tmp->needclose = 0;
+    tmp->closing = 0;
+    tmp->die = 0;
+    tmp->pppd = 0;
+    tmp->error = -1;
+    tmp->result = -1;
+    tmp->errormsg[0] = 0;
+    tmp->fbit = 0;
+    tmp->cid = 0;
+    tmp->lbit = 0;
+    /* Inherit LAC and LNS from parent */
+    tmp->lac = parent->lac;
+    tmp->addr = 0;
+/*	tmp->ourrws = DEFAULT_RWS_SIZE;	 */
+/*	if (tmp->ourrws >= 0)
+		tmp->ourfbit = FBIT;
+	else */
+    tmp->ourfbit = 0;           /* initialize to 0 since we don't actually use this 
+                                   value at this point anywhere in the code (I don't 
+                                   think)  We might just be able to remove it completely */
+	return tmp;
+}
+
+struct call *get_tunnel (int tunnel, unsigned int addr, int port)
+{
+    struct tunnel *st;
+    if (tunnel)
+    {
+        st = tunnels.head;
+        while (st)
+        {
+            if (st->ourtid == tunnel)
+            {
+                return st->self;
+            }
+            st = st->next;
+        }
+    }
+    return NULL;
+}
+
+struct call *get_call (int tunnel, int call, unsigned int addr, int port,
+		       IPsecSAref_t refme, IPsecSAref_t refhim)
+{
+    /*
+     * Figure out which call struct should handle this. 
+     * If we have tunnel and call ID's then they are unique.
+     * Otherwise, if the tunnel is 0, look for an existing connection
+     * or create a new tunnel.
+     */
+    struct tunnel *st;
+    struct call *sc;
+    if (tunnel)
+    {
+        st = tunnels.head;
+        while (st)
+        {
+	    if (st->ourtid == tunnel &&
+		(gconfig.ipsecsaref==0 ||
+		 (st->refhim == refhim
+		  || refhim==IPSEC_SAREF_NULL
+		  || st->refhim==IPSEC_SAREF_NULL)))
+            {
+                if (call)
+                {
+                    sc = st->call_head;
+                    while (sc)
+                    {
+			/* confirm that this is in fact a call with the right SA! */
+			if (sc->ourcid == call) return sc;
+                        sc = sc->next;
+                    }
+                    /* l2tp_log (LOG_DEBUG, "%s: can't find call %d in tunnel %d\n (ref=%d/%d)",
+			      __FUNCTION__, call, tunnel, refme, refhim); */
+                    return NULL;
+                }
+                else
+                {
+                    return st->self;
+                }
+            }
+            st = st->next;
+        }
+
+        /* l2tp_log (LOG_INFO, "Can not find tunnel %u (refhim=%u)\n",
+		  tunnel, refhim); */
+        return NULL;
+    }
+    else
+    {
+        /* You can't specify a call number if you haven't specified
+           a tunnel silly! */
+
+        if (call)
+        {
+            l2tp_log (LOG_WARNING,
+                 "%s: call ID specified, but no tunnel ID specified.  tossing.\n",
+                 __FUNCTION__);
+            return NULL;
+        }
+        /*
+         * Well, nothing appropriate...  Let's add a new tunnel, if
+         * we are not at capacity.
+         */
+        if (gconfig.debug_tunnel)
+        {
+            l2tp_log (LOG_DEBUG,
+                 "%s: allocating new tunnel for host %s, port %d.\n",
+                 __FUNCTION__, IPADDY (addr), ntohs (port));
+        }
+        if (!(st = new_tunnel ()))
+        {
+            l2tp_log (LOG_WARNING,
+                 "%s: unable to allocate new tunnel for host %s, port %d.\n",
+                 __FUNCTION__, IPADDY (addr), ntohs (port));
+            return NULL;
+        };
+        st->peer.sin_family = AF_INET;
+        st->peer.sin_port = port;
+	st->refme  = refme;
+	st->refhim = refhim;
+        bcopy (&addr, &st->peer.sin_addr, sizeof (addr));
+        st->next = tunnels.head;
+        tunnels.head = st;
+        tunnels.count++;
+        return st->self;
+    }
+}
--- ppp-2.4.4.orig/pppd/plugins/pppol2tp/call.h	1970-01-01 03:00:00.000000000 +0300
+++ ppp-2.4.4/pppd/plugins/pppol2tp/call.h	2011-01-24 13:53:48.000000000 +0300
@@ -0,0 +1,105 @@
+/*
+ * Layer Two Tunnelling Protocol Daemon
+ * Copyright (C) 1998 Adtran, Inc.
+ * Copyright (C) 2002 Jeff McAdams
+ *
+ * Mark Spencer
+ *
+ * This software is distributed under the terms
+ * of the GPL, which you should have received
+ * along with this source.
+ *
+ * Handle a call as a separate thread (header file)
+ */
+#include <sys/time.h>
+#include "misc.h"
+#include "common.h"
+#include "ipsecmast.h"
+
+#define CALL_CACHE_SIZE 256
+
+struct call
+{
+/*	int rbit;		Set the "R" bit on the next packet? */
+    int lbit;                   /* Should we send length field? */
+/*	int throttle;	Throttle the connection? */
+    int seq_reqd;               /* Sequencing required? */
+    int tx_pkts;                /* Transmitted packets */
+    int rx_pkts;                /* Received packets */
+    int tx_bytes;               /* transmitted bytes */
+    int rx_bytes;               /* received bytes */
+    struct schedule_entry *zlb_xmit;
+    /* Scheduled ZLB transmission */
+/*	struct schedule_entry *dethrottle; */
+    /* Scheduled dethrottling (overrun) */
+/*	int timeout;	Has our timeout expired? If so, we'll go ahead
+					 and transmit, full window or not, and set the
+					 R-bit on this packet.  */
+    int prx;                    /* What was the last packet we sent
+                                   as an Nr? Used to manage payload ZLB's */
+    int state;                  /* Current state */
+    int frame;                  /* Framing being used */
+    struct call *next;          /* Next call, for linking */
+    int fd;
+    int debug;
+    int msgtype;                /* What kind of message are we
+                                   working with right now? */
+
+    int ourcid;                 /* Our call number */
+    int cid;                    /* Their call number */
+    int qcid;                   /* Quitting CID */
+    int bearer;                 /* Bearer type of call */
+    unsigned int serno;         /* Call serial number */
+    unsigned int addr;          /* Address reserved for this call */
+    int txspeed;                /* Transmit speed */
+    int rxspeed;                /* Receive speed */
+    int ppd;                    /* Packet processing delay (of peer) */
+    int physchan;               /* Physical channel ID */
+    char dialed[MAXSTRLEN];     /* Number dialed for call */
+    char dialing[MAXSTRLEN];    /* Original caller ID */
+    char subaddy[MAXSTRLEN];    /* Sub address */
+
+    int needclose;              /* Do we need to close this call? */
+    int closing;                /* Are we actually in the process of closing? */
+    /*
+       needclose            closing         state
+       =========            =======         =====
+       0                       0            Running
+       1                       0            Send Closing notice
+       1                       1            Waiting for closing notice
+       0                       1            Closing ZLB received, actulaly close
+     */
+    struct tunnel *container;   /* Tunnel we belong to */
+     int pppd;
+    int die;
+    int nego;                   /* Show negotiation? */
+    int result;                 /* Result code */
+    int error;                  /* Error code */
+    int fbit;                   /* Use sequence numbers? */
+    int ourfbit;                /* Do we want sequence numbers? */
+/*	int ourrws;		Our RWS for the call */
+    int cnu;                    /* Do we need to send updated Ns, Nr values? */
+    int pnu;                    /* ditto for payload packet */
+    char errormsg[MAXSTRLEN];   /* Error message */
+/*	int rws;		Receive window size, or -1 for none */
+    struct timeval lastsent;    /* When did we last send something? */
+    _u16 data_seq_num;          /* Sequence for next payload packet */
+    _u16 data_rec_seq_num;      /* Sequence for next received payload packet */
+    _u16 closeSs;               /* What number was in Ns when we started to 
+                                   close? */
+    int pLr;                    /* Last packet received by peer */
+    struct lac *lac;            /* LAC that owns us */
+};
+
+
+extern void push_handler (int);
+extern void toss (struct buffer *);
+extern struct call *get_call (int tunnel, int call, unsigned int addr,
+			      int port,
+			      IPsecSAref_t refme, IPsecSAref_t refhim);
+extern struct call *get_tunnel (int, unsigned int, int);
+extern void destroy_call (struct call *);
+extern struct call *new_call (struct tunnel *);
+extern void set_error (struct call *, int, const char *, ...);
+void *call_thread_init (void *);
+void call_close (struct call *);
--- ppp-2.4.4.orig/pppd/plugins/pppol2tp/common.h	1970-01-01 03:00:00.000000000 +0300
+++ ppp-2.4.4/pppd/plugins/pppol2tp/common.h	2011-01-24 13:53:48.000000000 +0300
@@ -0,0 +1,17 @@
+/*
+ * Layer 2 Tunnelling Protocol Daemon
+ * Copyright (C) 2002 Jeff McAdams
+ *
+ * This software is distributed under the terms of the GPL, which you
+ * should have receivede along with this source.
+ *
+ * Defines common to several different files
+ */
+
+#ifndef _COMMON_H_
+typedef unsigned char _u8;
+typedef unsigned short _u16;
+typedef unsigned long long _u64;
+extern int rand_source;
+#define _COMMON_H_
+#endif
--- ppp-2.4.4.orig/pppd/plugins/pppol2tp/control.c	1970-01-01 03:00:00.000000000 +0300
+++ ppp-2.4.4/pppd/plugins/pppol2tp/control.c	2011-01-24 13:53:48.000000000 +0300
@@ -0,0 +1,1359 @@
+/*
+ * Layer Two Tunnelling Protocol Daemon
+ * Copyright (C) 1998 Adtran, Inc.
+ * Copyright (C) 2002 Jeff McAdams
+ *
+ * Mark Spencer
+ *
+ * This software is distributed under the terms
+ * of the GPL, which you should have received
+ * along with this source.
+ *
+ * Control Packet Handling
+ *
+ */
+
+#include <errno.h>
+#include <string.h>
+#include <stdio.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include "l2tp.h"
+
+_u16 ppp_crc16_table[256] = {
+    0x0000, 0x1189, 0x2312, 0x329b, 0x4624, 0x57ad, 0x6536, 0x74bf,
+    0x8c48, 0x9dc1, 0xaf5a, 0xbed3, 0xca6c, 0xdbe5, 0xe97e, 0xf8f7,
+    0x1081, 0x0108, 0x3393, 0x221a, 0x56a5, 0x472c, 0x75b7, 0x643e,
+    0x9cc9, 0x8d40, 0xbfdb, 0xae52, 0xdaed, 0xcb64, 0xf9ff, 0xe876,
+    0x2102, 0x308b, 0x0210, 0x1399, 0x6726, 0x76af, 0x4434, 0x55bd,
+    0xad4a, 0xbcc3, 0x8e58, 0x9fd1, 0xeb6e, 0xfae7, 0xc87c, 0xd9f5,
+    0x3183, 0x200a, 0x1291, 0x0318, 0x77a7, 0x662e, 0x54b5, 0x453c,
+    0xbdcb, 0xac42, 0x9ed9, 0x8f50, 0xfbef, 0xea66, 0xd8fd, 0xc974,
+    0x4204, 0x538d, 0x6116, 0x709f, 0x0420, 0x15a9, 0x2732, 0x36bb,
+    0xce4c, 0xdfc5, 0xed5e, 0xfcd7, 0x8868, 0x99e1, 0xab7a, 0xbaf3,
+    0x5285, 0x430c, 0x7197, 0x601e, 0x14a1, 0x0528, 0x37b3, 0x263a,
+    0xdecd, 0xcf44, 0xfddf, 0xec56, 0x98e9, 0x8960, 0xbbfb, 0xaa72,
+    0x6306, 0x728f, 0x4014, 0x519d, 0x2522, 0x34ab, 0x0630, 0x17b9,
+    0xef4e, 0xfec7, 0xcc5c, 0xddd5, 0xa96a, 0xb8e3, 0x8a78, 0x9bf1,
+    0x7387, 0x620e, 0x5095, 0x411c, 0x35a3, 0x242a, 0x16b1, 0x0738,
+    0xffcf, 0xee46, 0xdcdd, 0xcd54, 0xb9eb, 0xa862, 0x9af9, 0x8b70,
+    0x8408, 0x9581, 0xa71a, 0xb693, 0xc22c, 0xd3a5, 0xe13e, 0xf0b7,
+    0x0840, 0x19c9, 0x2b52, 0x3adb, 0x4e64, 0x5fed, 0x6d76, 0x7cff,
+    0x9489, 0x8500, 0xb79b, 0xa612, 0xd2ad, 0xc324, 0xf1bf, 0xe036,
+    0x18c1, 0x0948, 0x3bd3, 0x2a5a, 0x5ee5, 0x4f6c, 0x7df7, 0x6c7e,
+    0xa50a, 0xb483, 0x8618, 0x9791, 0xe32e, 0xf2a7, 0xc03c, 0xd1b5,
+    0x2942, 0x38cb, 0x0a50, 0x1bd9, 0x6f66, 0x7eef, 0x4c74, 0x5dfd,
+    0xb58b, 0xa402, 0x9699, 0x8710, 0xf3af, 0xe226, 0xd0bd, 0xc134,
+    0x39c3, 0x284a, 0x1ad1, 0x0b58, 0x7fe7, 0x6e6e, 0x5cf5, 0x4d7c,
+    0xc60c, 0xd785, 0xe51e, 0xf497, 0x8028, 0x91a1, 0xa33a, 0xb2b3,
+    0x4a44, 0x5bcd, 0x6956, 0x78df, 0x0c60, 0x1de9, 0x2f72, 0x3efb,
+    0xd68d, 0xc704, 0xf59f, 0xe416, 0x90a9, 0x8120, 0xb3bb, 0xa232,
+    0x5ac5, 0x4b4c, 0x79d7, 0x685e, 0x1ce1, 0x0d68, 0x3ff3, 0x2e7a,
+    0xe70e, 0xf687, 0xc41c, 0xd595, 0xa12a, 0xb0a3, 0x8238, 0x93b1,
+    0x6b46, 0x7acf, 0x4854, 0x59dd, 0x2d62, 0x3ceb, 0x0e70, 0x1ff9,
+    0xf78f, 0xe606, 0xd49d, 0xc514, 0xb1ab, 0xa022, 0x92b9, 0x8330,
+    0x7bc7, 0x6a4e, 0x58d5, 0x495c, 0x3de3, 0x2c6a, 0x1ef1, 0x0f78
+};
+
+int global_serno = 1;
+
+struct buffer *new_outgoing (struct tunnel *t)
+{
+    /*
+     * Make a new outgoing control packet
+     */
+    struct buffer *tmp = new_buf (MAX_RECV_SIZE);
+    if (!tmp)
+        return NULL;
+    tmp->peer = t->peer;
+    tmp->start += sizeof (struct control_hdr);
+    tmp->len = 0;
+    tmp->retries = 0;
+    tmp->tunnel = t;
+    return tmp;
+}
+
+inline void recycle_outgoing (struct buffer *buf, struct sockaddr_in peer)
+{
+    /* 
+     * This should only be used for ZLB's!
+     */
+    buf->start = buf->rstart + sizeof (struct control_hdr);
+    buf->peer = peer;
+    buf->len = 0;
+    buf->retries = -1;
+    buf->tunnel = NULL;
+}
+void add_fcs (struct buffer *buf)
+{
+    _u16 fcs = PPP_INITFCS;
+    unsigned char *c = buf->start;
+    int x;
+    for (x = 0; x < buf->len; x++)
+    {
+        fcs = PPP_FCS (fcs, *c);
+        c++;
+    }
+    fcs = fcs ^ 0xFFFF;
+    *c = fcs & 0xFF;
+    c++;
+    *c = (fcs >> 8) & 0xFF;
+    buf->len += 2;
+}
+
+void add_control_hdr (struct tunnel *t, struct call *c, struct buffer *buf)
+{
+    struct control_hdr *h;
+    buf->start -= sizeof (struct control_hdr);
+    buf->len += sizeof (struct control_hdr);
+    h = (struct control_hdr *) buf->start;
+    h->ver = htons (TBIT | LBIT | FBIT | VER_L2TP);
+    h->length = htons ((_u16) buf->len);
+    h->tid = htons (t->tid);
+    h->cid = htons (c->cid);
+    h->Ns = htons (t->control_seq_num);
+    h->Nr = htons (t->control_rec_seq_num);
+    t->control_seq_num++;
+
+}
+
+void hello (void *tun)
+{
+    struct buffer *buf;
+    struct tunnel *t;
+    struct timeval tv;
+    tv.tv_sec = HELLO_DELAY;
+    tv.tv_usec = 0;
+    t = (struct tunnel *) tun;
+    buf = new_outgoing (t);
+    add_message_type_avp (buf, Hello);
+    add_control_hdr (t, t->self, buf);
+    if (gconfig.packet_dump)
+        do_packet_dump (buf);
+#ifdef DEBUG_HELLO
+    l2tp_log (LOG_DEBUG, "%s: sending Hello on %d\n", __FUNCTION__, t->ourtid);
+#endif
+    control_xmit (buf);
+    
+    /*
+     * Schedule another Hello in a little bit.
+     */
+#ifdef DEBUG_HELLO
+    l2tp_log (LOG_DEBUG, "%s: scheduling another Hello on %d\n", __FUNCTION__,
+         t->ourtid);
+#endif
+    t->hello = schedule (tv, hello, (void *) t);
+}
+
+void control_zlb (struct buffer *buf, struct tunnel *t, struct call *c)
+{
+    recycle_outgoing (buf, t->peer);
+    add_control_hdr (t, c, buf);
+    t->control_seq_num--;
+#ifdef DEBUG_ZLB
+    l2tp_log (LOG_DEBUG, "%s: sending control ZLB on tunnel %d\n", __FUNCTION__,
+         t->tid);
+#endif
+    udp_xmit (buf, t);
+}
+
+int control_finish (struct tunnel *t, struct call *c)
+{
+    /*
+     * After all AVP's have been handled, do anything else
+     * which needs to be done, like prepare response
+     * packets to go back.  This is essentially the
+     * implementation of the state machine of section 7.2.1
+     *
+     * If we set c->needclose, the call (or tunnel) will
+     * be closed upon return.
+     */
+    struct buffer *buf;
+    struct call *p;
+    struct timeval tv;
+    int tmptid,tmpcid;
+
+    if (c->msgtype < 0)
+    {
+        l2tp_log (LOG_DEBUG, "%s: Whoa...  non-ZLB with no message type!\n",
+             __FUNCTION__);
+        return -EINVAL;
+    }
+    if (gconfig.debug_state)
+        l2tp_log (LOG_DEBUG,
+             "%s: message type is %s(%d).  Tunnel is %d, call is %d.\n",
+             __FUNCTION__, msgtypes[c->msgtype], c->msgtype, t->tid, c->cid);
+    switch (c->msgtype)
+    {
+    case 0:
+        /*
+         * We need to initiate a connection.
+         */
+        if (t->self == c)
+        {
+            if (t->lac)
+            {
+                t->ourrws = t->lac->tun_rws;
+                t->hbit = t->lac->hbit;
+            }
+            /* This is an attempt to bring up the tunnel */
+            t->state = SCCRQ;
+            buf = new_outgoing (t);
+            add_message_type_avp (buf, SCCRQ);
+            if (t->hbit)
+            {
+                mk_challenge (t->chal_them.vector, VECTOR_SIZE);
+                add_randvect_avp (buf, t->chal_them.vector, VECTOR_SIZE);
+            }
+            add_protocol_avp (buf);
+            add_frame_caps_avp (buf, t->ourfc);
+            add_bearer_caps_avp (buf, t->ourbc);
+            /* FIXME:  Tie breaker */
+            add_firmware_avp (buf);
+            if (t->lac && t->lac->hostname && t->lac->hostname[0])
+                add_hostname_avp (buf, t->lac->hostname);
+            else
+                add_hostname_avp (buf, hostname);
+            add_vendor_avp (buf);
+            add_tunnelid_avp (buf, t->ourtid);
+            if (t->ourrws >= 0)
+                add_avp_rws (buf, t->ourrws);
+            if ((t->lac && t->lac->challenge))
+            {
+		if (t->chal_them.challenge)
+		    free(t->chal_them.challenge);
+                t->chal_them.challenge = zalloc(MD_SIG_SIZE);
+                if (!(t->chal_them.challenge))
+                {
+                    l2tp_log (LOG_WARNING, "%s: zalloc failed for challenge\n",
+			 __FUNCTION__);
+		    toss (buf);
+                    return -EINVAL;
+                }
+                mk_challenge (t->chal_them.challenge, MD_SIG_SIZE);
+                t->chal_them.chal_len = MD_SIG_SIZE;
+                add_challenge_avp (buf, t->chal_them.challenge,
+				   t->chal_them.chal_len);
+                t->chal_them.state = STATE_CHALLENGED;
+                /* We generate the challenge and make a note that we plan to
+                   challenge the peer, but we can't predict the response yet
+                   because we don't know their hostname AVP */
+            }
+            add_control_hdr (t, c, buf);
+            c->cnu = 0;
+            if (gconfig.packet_dump)
+                do_packet_dump (buf);
+            if (gconfig.debug_state)
+                l2tp_log (LOG_DEBUG, "%s: sending SCCRQ\n",
+                     __FUNCTION__);
+            control_xmit (buf);
+        }
+        else
+        {
+                c->state = ICRQ;
+                if (c->lac)
+                {
+                    c->lbit = c->lac->lbit ? LBIT : 0;
+/*					c->ourrws = c->lac->call_rws;
+					if (c->ourrws > -1) c->ourfbit = FBIT; else c->ourfbit = 0; */
+                }
+                buf = new_outgoing (t);
+                add_message_type_avp (buf, ICRQ);
+                if (t->hbit)
+                {
+                    mk_challenge (t->chal_them.vector, VECTOR_SIZE);
+                    add_randvect_avp (buf, t->chal_them.vector, VECTOR_SIZE);
+                }
+#ifdef TEST_HIDDEN
+                add_callid_avp (buf, c->ourcid, t);
+#else
+                add_callid_avp (buf, c->ourcid);
+#endif
+                add_serno_avp (buf, global_serno);
+                c->serno = global_serno;
+                global_serno++;
+                add_bearer_avp (buf, 0);
+                add_control_hdr (t, c, buf);
+                c->cnu = 0;
+                if (gconfig.packet_dump)
+                    do_packet_dump (buf);
+                if (gconfig.debug_state)
+                    l2tp_log (LOG_DEBUG, "%s: sending ICRQ\n", __FUNCTION__);
+		control_xmit (buf);
+        }
+        break;
+    case SCCRP:
+        /*
+         * We have a reply.  If everything is okay, send
+         * a connected message
+         */
+        if (t->fc < 0)
+        {
+            if (DEBUG)
+                l2tp_log (LOG_DEBUG,
+                     "%s: Peer did not specify framing capability.  Closing.\n",
+                     __FUNCTION__);
+            set_error (c, VENDOR_ERROR, "Specify framing capability");
+            c->needclose = -1;
+            return -EINVAL;
+        }
+        /* FIXME: Do we need to be sure they specified a version number?
+         *   Theoretically, yes, but we don't have anything in the code
+         *   to actually *do* anything with it, so...why check at this point?
+         * We shouldn't be requiring a bearer capabilities avp to be present in 
+         * SCCRQ and SCCRP as they aren't required
+         if (t->bc < 0 ) {
+         if (DEBUG) log(LOG_DEBUG,
+         "%s: Peer did not specify bearer capability.  Closing.\n",__FUNCTION__);
+         set_error(c, VENDOR_ERROR, "Specify bearer capability");
+         c->needclose = -1;
+         return -EINVAL;
+         } */
+        if ((!strlen (t->hostname)) && ((t->chal_them.state) || ((t->chal_us.state))))
+        {
+            if (DEBUG)
+                l2tp_log (LOG_DEBUG,
+                     "%s: Peer did not specify hostname.  Closing.\n",
+                     __FUNCTION__);
+            set_error (c, VENDOR_ERROR, "Specify your hostname");
+            c->needclose = -1;
+            return -EINVAL;
+        }
+        if (t->tid <= 0)
+        {
+            if (DEBUG)
+                l2tp_log (LOG_DEBUG,
+                     "%s: Peer did not specify assigned tunnel ID.  Closing.\n",
+                     __FUNCTION__);
+            set_error (c, VENDOR_ERROR, "Specify your assigned tunnel ID");
+            c->needclose = -1;
+            return -EINVAL;
+        }
+        if (t->chal_them.state)
+        {
+            t->chal_them.ss = SCCRP;
+            if (handle_challenge (t, &t->chal_them))
+            {
+                set_error (c, VENDOR_ERROR, "No secret key on our side");
+                l2tp_log (LOG_WARNING, "%s: No secret key for authenticating '%s'\n",
+                     __FUNCTION__, t->hostname);
+                c->needclose = -1;
+                return -EINVAL;
+            }
+            if (memcmp
+                (t->chal_them.reply, t->chal_them.response, MD_SIG_SIZE))
+            {
+                set_error (c, VENDOR_ERROR,
+                           "Invalid challenge authentication");
+                l2tp_log (LOG_DEBUG, "%s: Invalid authentication for host '%s'\n",
+                     __FUNCTION__, t->hostname);
+                c->needclose = -1;
+                return -EINVAL;
+            }
+        }
+        if (t->chal_us.state)
+        {
+            t->chal_us.ss = SCCCN;
+            if (handle_challenge (t, &t->chal_us))
+            {
+                l2tp_log (LOG_WARNING, "%s: No secret for authenticating to '%s'\n",
+                     __FUNCTION__, t->hostname);
+                set_error (c, VENDOR_ERROR, "No secret key on our end");
+                c->needclose = -1;
+                return -EINVAL;
+            };
+        }
+        t->state = SCCCN;
+        buf = new_outgoing (t);
+        add_message_type_avp (buf, SCCCN);
+        if (t->hbit)
+        {
+            mk_challenge (t->chal_them.vector, VECTOR_SIZE);
+            add_randvect_avp (buf, t->chal_them.vector, VECTOR_SIZE);
+        }
+        if (t->chal_us.state)
+            add_chalresp_avp (buf, t->chal_us.response, MD_SIG_SIZE);
+        add_control_hdr (t, c, buf);
+        if (gconfig.packet_dump)
+            do_packet_dump (buf);
+        c->cnu = 0;
+        if (gconfig.debug_state)
+            l2tp_log (LOG_DEBUG, "%s: sending SCCCN\n", __FUNCTION__);
+	control_xmit (buf);
+        /* Schedule a HELLO */
+        tv.tv_sec = HELLO_DELAY;
+        tv.tv_usec = 0;
+#ifdef DEBUG_HELLO
+        l2tp_log (LOG_DEBUG, "%s: scheduling initial HELLO on %d\n", __FUNCTION__,
+             t->ourtid);
+#endif
+        t->hello = schedule (tv, hello, (void *) t);
+        l2tp_log (LOG_NOTICE,
+		  "Connection established to %s, %d.  Local: %d, Remote: %d (ref=%u/%u).\n",
+		  IPADDY (t->peer.sin_addr),
+		  ntohs (t->peer.sin_port), t->ourtid, t->tid, t->refme, t->refhim);
+        if (t->lac)
+        {
+            /* This is part of a LAC, so we want to go ahead
+               and start an ICRQ now */
+            magic_lac_dial (t->lac);
+        }
+        break;
+    case SCCCN:
+        if (t->chal_them.state)
+        {
+            if (memcmp
+                (t->chal_them.reply, t->chal_them.response, MD_SIG_SIZE))
+            {
+                set_error (c, VENDOR_ERROR,
+                           "Invalid challenge authentication");
+                l2tp_log (LOG_DEBUG, "%s: Invalid authentication for host '%s'\n",
+                     __FUNCTION__, t->hostname);
+                c->needclose = -1;
+                return -EINVAL;
+            }
+        }
+        t->state = SCCCN;
+        l2tp_log (LOG_NOTICE,
+             "Connection established to %s, %d.  Local: %d, Remote: %d (ref=%u/%u).\n",
+		  IPADDY (t->peer.sin_addr),
+		  ntohs (t->peer.sin_port), t->ourtid, t->tid, t->refme, t->refhim);
+        /* Schedule a HELLO */
+        tv.tv_sec = HELLO_DELAY;
+        tv.tv_usec = 0;
+#ifdef DEBUG_HELLO
+        l2tp_log (LOG_DEBUG, "%s: scheduling initial HELLO on %d\n", __FUNCTION__,
+             t->ourtid);
+#endif
+        t->hello = schedule (tv, hello, (void *) t);
+        break;
+    case StopCCN:
+        if (t->qtid < 0)
+        {
+            if (DEBUG)
+                l2tp_log (LOG_DEBUG,
+                     "%s: Peer tried to disconnect without specifying tunnel ID\n",
+                     __FUNCTION__);
+            return -EINVAL;
+        }
+
+       /* Work around bug in MSL2TP client */
+        if ((t->firmware == 0xff00) && (!(strncmp(t->vendor, "Deterministic Networks Inc.", 27))))
+            tmptid = t->ourtid;
+        else
+            tmptid = t->tid;
+        if ((t->qtid != tmptid) && (tmptid > 0))
+        {
+            if (DEBUG)
+                l2tp_log (LOG_DEBUG,
+                     "%s: Peer [Vendor:%s] [Firmware:%d (0x%.4x)] tried to disconnect with invalid TID (%d != %d)\n",
+                     __FUNCTION__, t->vendor, t->firmware, t->firmware, t->qtid, tmptid);
+            return -EINVAL;
+        }
+        /* In case they're disconnecting immediately after SCCN */
+        if (!t->tid)
+            t->tid = t->qtid;
+        if (t->self->result < 0)
+        {
+            if (DEBUG)
+                l2tp_log (LOG_DEBUG,
+                     "%s: Peer tried to disconnect without specifying result code.\n",
+                     __FUNCTION__);
+            return -EINVAL;
+        }
+        l2tp_log (LOG_INFO,
+             "%s: Connection closed to %s, port %d (%s), Local: %d, Remote: %d\n",
+             __FUNCTION__, IPADDY (t->peer.sin_addr),
+             ntohs (t->peer.sin_port), t->self->errormsg, t->ourtid, t->tid);
+        c->needclose = 0;
+        c->closing = -1;
+        break;
+    case ICRP:
+        if (c->cid < 0)
+        {
+            if (DEBUG)
+                l2tp_log (LOG_DEBUG,
+                     "%s: Peer tried to negotiate ICRP without specifying call ID\n",
+                     __FUNCTION__);
+            c->needclose = -1;
+            return -EINVAL;
+        }
+        c->state = ICCN;
+        if (t->fc & SYNC_FRAMING)
+            c->frame = SYNC_FRAMING;
+        else
+            c->frame = ASYNC_FRAMING;
+
+        buf = new_outgoing (t);
+        add_message_type_avp (buf, ICCN);
+        if (t->hbit)
+        {
+            mk_challenge (t->chal_them.vector, VECTOR_SIZE);
+            add_randvect_avp (buf, t->chal_them.vector, VECTOR_SIZE);
+        }
+        add_txspeed_avp (buf, DEFAULT_TX_BPS);
+        add_frame_avp (buf, c->frame);
+/*		if (c->ourrws >= 0)
+			add_avp_rws(buf, c->ourrws); */
+        /* FIXME: Packet Processing Delay */
+        /* We don't need any kind of proxy PPP stuff */
+        /* Can we proxy authenticate ourselves??? */
+        add_rxspeed_avp (buf, DEFAULT_RX_BPS);
+/* add_seqreqd_avp (buf); *//* We don't have sequencing code, so
+ * don't ask for sequencing */
+        add_control_hdr (t, c, buf);
+        if (gconfig.packet_dump)
+            do_packet_dump (buf);
+        c->cnu = 0;
+        if (gconfig.debug_state)
+            l2tp_log (LOG_DEBUG, "%s: Sending ICCN\n", __FUNCTION__);
+        l2tp_log (LOG_NOTICE,
+		  "Call established with %s, Local: %d, Remote: %d, Serial: %d (ref=%u/%u)\n",
+		  IPADDY (t->peer.sin_addr), c->ourcid, c->cid,
+		  c->serno, t->refme, t->refhim);
+	control_xmit (buf);
+
+        start_pppd (c);
+        break;
+    case OCRP:                 /* jz: nothing to do for OCRP, waiting for OCCN */
+        break;
+    case OCCN:                 /* jz: get OCCN, so the only thing we must do is to start the pppd */
+	/*  jz: just show some information */
+        l2tp_log (LOG_INFO,
+		  "parameters: Local: %d , Remote: %d , Serial: %d , Pid: %d , Tunnelid: %d\n",
+		  c->ourcid, c->cid, c->serno, c->pppd, t->ourtid); 
+
+        start_pppd (c);
+        break;
+    case CDN:
+        if (c->qcid < 0)
+        {
+            if (DEBUG)
+                l2tp_log (LOG_DEBUG,
+                     "%s: Peer tried to disconnect without specifying call ID\n",
+                     __FUNCTION__);
+            return -EINVAL;
+        }
+        if (c == t->self)
+        {
+            p = t->call_head;
+            while (p && (p->cid != c->qcid))
+                p = p->next;
+            if (!p)
+            {
+                if (DEBUG)
+                    l2tp_log (LOG_DEBUG,
+                         "%s: Unable to determine call to be disconnected.\n",
+                         __FUNCTION__);
+                return -EINVAL;
+            }
+        }
+        else {
+            p = c;
+	}
+
+       /* Work around bug in MSL2TP client */
+        if ((t->firmware == 0xff00) && (!(strncmp(t->vendor, "Deterministic Networks Inc.", 27))))
+            tmpcid = p->ourcid;
+        else
+            tmpcid = p->cid;
+
+        if ((c->qcid != tmpcid) && tmpcid > 0)
+        {
+            if (DEBUG)
+                l2tp_log (LOG_DEBUG,
+                     "%s: Peer tried to disconnect with invalid CID (%d != %d)\n",
+                     __FUNCTION__, c->qcid, c->ourcid);
+            return -EINVAL;
+        }
+        c->qcid = -1;
+        if (c->result < 0)
+        {
+            if (DEBUG)
+                l2tp_log (LOG_DEBUG,
+                     "%s: Peer tried to disconnect without specifying result code.\n",
+                     __FUNCTION__);
+            return -EINVAL;
+        }
+        l2tp_log (LOG_INFO,
+             "%s: Connection closed to %s, serial %d (%s)\n", __FUNCTION__,
+             IPADDY (t->peer.sin_addr), c->serno, c->errormsg);
+        c->needclose = 0;
+        c->closing = -1;
+        break;
+    case Hello:
+        break;
+    case SLI:
+        break;
+    default:
+	if(DEBUG)
+    	    l2tp_log (LOG_DEBUG,
+             "%s: Don't know how to finish a message of type %d\n",
+             __FUNCTION__, c->msgtype);
+        set_error (c, VENDOR_ERROR, "Unimplemented message %d\n", c->msgtype);
+    }
+    return 0;
+}
+
+inline int check_control (const struct buffer *buf, struct tunnel *t,
+                          struct call *c)
+{
+    /*
+     * Check if this is a valid control
+     * or not.  Returns 0 on success
+     */
+    struct control_hdr *h = (struct control_hdr *) (buf->start);
+    struct buffer *zlb;
+    if (buf->len < sizeof (struct control_hdr))
+    {
+        if (DEBUG)
+        {
+            l2tp_log (LOG_DEBUG,
+                 "%s: Received too small of packet\n", __FUNCTION__);
+        }
+        return -EINVAL;
+    }
+#ifdef SANITY
+    if (buf->len != h->length)
+    {
+        if (DEBUG)
+        {
+            l2tp_log (LOG_DEBUG,
+                 "%s: Reported and actual sizes differ (%d != %d)\n",
+                 __FUNCTION__, h->length, buf->len);
+        }
+        return -EINVAL;
+    }
+    /*
+     * FIXME: H-bit handling goes here
+     */
+#ifdef DEBUG_CONTROL
+    l2tp_log (LOG_DEBUG, "%s: control, cid = %d, Ns = %d, Nr = %d\n", __FUNCTION__,
+         c->cid, h->Ns, h->Nr);
+#endif
+    if (h->Ns != t->control_rec_seq_num)
+    {
+        if (DEBUG)
+            l2tp_log (LOG_DEBUG,
+                 "%s: Received out of order control packet on tunnel %d (got %d, expected %d)\n",
+                 __FUNCTION__, t->tid, h->Ns, t->control_rec_seq_num);
+        if (((h->Ns < t->control_rec_seq_num) && 
+            ((t->control_rec_seq_num - h->Ns) < 32768)) ||
+            ((h->Ns > t->control_rec_seq_num) &&
+            ((t->control_rec_seq_num - h->Ns) > 32768)))
+        {
+            /*
+               * Woopsies, they sent us a message we should have already received
+               * so we should send them a ZLB so they know
+               * for sure that we already have it.
+             */
+#ifdef DEBUG_ZLB
+            if (DEBUG)
+                l2tp_log (LOG_DEBUG, "%s: Sending an updated ZLB in reponse\n",
+                     __FUNCTION__);
+#endif
+            zlb = new_outgoing (t);
+            control_zlb (zlb, t, c);
+            udp_xmit (zlb, t);
+            toss (zlb);
+        }
+        else if (!t->control_rec_seq_num && (t->tid == -1))
+        {
+            /* We made this tunnel just for this message, so let's
+               destroy it.  */
+            c->needclose = 0;
+            c->closing = -1;
+        }
+        return -EINVAL;
+    }
+    else
+    {
+        t->control_rec_seq_num++;
+        c->cnu = -1;
+    }
+    /*
+     * So we know what the other end has received
+     * so far
+     */
+
+    t->cLr = h->Nr;
+    if (t->sanity)
+    {
+        if (!CTBIT (h->ver))
+        {
+            if (DEBUG)
+            {
+                l2tp_log (LOG_DEBUG, "%s: Control bit not set\n", __FUNCTION__);
+            }
+            return -EINVAL;
+        }
+        if (!CLBIT (h->ver))
+        {
+            if (DEBUG)
+            {
+                l2tp_log (LOG_DEBUG, "%s: Length bit not set\n", __FUNCTION__);
+            }
+            return -EINVAL;
+        }
+        if (!CFBIT (h->ver))
+        {
+            if (DEBUG)
+            {
+                l2tp_log (LOG_DEBUG, "%s: Flow bit not set\n", __FUNCTION__);
+            }
+            return -EINVAL;
+        }
+        if (CVER (h->ver) != VER_L2TP)
+        {
+            if (DEBUG)
+            {
+                if (CVER (h->ver) == VER_PPTP)
+                {
+                    l2tp_log (LOG_DEBUG,
+                         "%s: PPTP packet received\n", __FUNCTION__);
+                }
+                else if (CVER (h->ver) < VER_L2TP)
+                {
+                    l2tp_log (LOG_DEBUG,
+                         "%s: L2F packet received\n", __FUNCTION__);
+                }
+                else
+                {
+                    l2tp_log (LOG_DEBUG,
+                         "%s: Unknown version received\n", __FUNCTION__);
+                }
+            }
+            return -EINVAL;
+        }
+
+    }
+#endif
+    return 0;
+}
+
+inline int check_payload (struct buffer *buf, struct tunnel *t,
+                          struct call *c)
+{
+    /*
+     * Check if this is a valid payload
+     * or not.  Returns 0 on success.
+     */
+
+    int ehlen = MIN_PAYLOAD_HDR_LEN;
+    struct payload_hdr *h = (struct payload_hdr *) (buf->start);
+    if (!c)
+    {
+        if (DEBUG)
+        {
+            l2tp_log (LOG_DEBUG, "%s: Aempted to send payload on tunnel\n",
+                 __FUNCTION__);
+        }
+        return -EINVAL;
+    }
+    if (buf->len < MIN_PAYLOAD_HDR_LEN)
+    {
+        /* has to be at least MIN_PAYLOAD_HDR_LEN 
+           no matter what.  we'll look more later */
+        if (DEBUG)
+        {
+            l2tp_log (LOG_DEBUG, "%s:Recieved to small of packet\n", __FUNCTION__);
+        }
+        return -EINVAL;
+    }
+#ifdef SANITY
+    if (t->sanity)
+    {
+        if (PTBIT (h->ver))
+        {
+            if (DEBUG)
+            {
+                l2tp_log (LOG_DEBUG, "%s Control bit set\n", __FUNCTION__);
+            }
+            return -EINVAL;
+        }
+        if (PLBIT (h->ver))
+            ehlen += 2;         /* Should have length information */
+        if (PFBIT (h->ver))
+        {
+/*			if (!c->fbit && !c->ourfbit) {
+				if (DEBUG)
+					l2tp_log(LOG_DEBUG,"%s: flow bit set, but no RWS negotiated.\n",__FUNCTION__);
+				return -EINVAL;
+			} */
+            ehlen += 4;         /* Should have Ns and Nr too */
+        }
+/*		if (!PFBIT(h->ver)) {
+			if (c->fbit || c->ourfbit) {
+				if (DEBUG)
+					l2tp_log(LOG_DEBUG, "%s: no flow bit, but RWS was negotiated.\n",__FUNCTION__);
+				return -EINVAL;;
+			}
+		} */
+        if (PSBIT (h->ver))
+            ehlen += 4;         /* Offset information */
+        if (PLBIT (h->ver))
+            ehlen += h->length; /* include length if available */
+        if (PVER (h->ver) != VER_L2TP)
+        {
+            if (DEBUG)
+            {
+                if (PVER (h->ver) == VER_PPTP)
+                {
+                    l2tp_log (LOG_DEBUG, "%s: PPTP packet received\n",
+                         __FUNCTION__);
+                }
+                else if (CVER (h->ver) < VER_L2TP)
+                {
+                    l2tp_log (LOG_DEBUG, "%s: L2F packet received\n",
+                         __FUNCTION__);
+                }
+                else
+                {
+                    l2tp_log (LOG_DEBUG, "%s: Unknown version received\n",
+                         __FUNCTION__);
+                }
+            }
+            return -EINVAL;
+        }
+        if ((buf->len < ehlen) && !PLBIT (h->ver))
+        {
+            if (DEBUG)
+            {
+                l2tp_log (LOG_DEBUG, "%s payload too small (%d < %d)\n",
+                     __FUNCTION__, buf->len, ehlen);
+            }
+            return -EINVAL;
+        }
+        if ((buf->len != h->length) && PLBIT (h->ver))
+        {
+            if (DEBUG)
+            {
+                l2tp_log (LOG_DEBUG, "%s: size mismatch (%d != %d)\n",
+                     __FUNCTION__, buf->len, h->length);
+            }
+            return -EINVAL;
+        }
+    }
+#endif
+    return 0;
+}
+inline int expand_payload (struct buffer *buf, struct tunnel *t,
+                           struct call *c)
+{
+    /*
+     * Expands payload header.  Does not check for valid header,
+     * check_payload() should already be called as a prerequisite.
+     */
+    struct payload_hdr *h = (struct payload_hdr *) (buf->start);
+    _u16 *r = (_u16 *) h;       /* Nice to have raw word pointers */
+    struct payload_hdr *new_hdr;
+    int ehlen = 0;
+    /*
+     * We first calculate our offset
+     */
+    if (!PLBIT (h->ver))
+        ehlen += 2;             /* Should have length information */
+    if (!PFBIT (h->ver))
+        ehlen += 4;             /* Should have Ns and Nr too */
+    if (!PSBIT (h->ver))
+        ehlen += 4;             /* Offset information */
+    if (ehlen)
+    {
+        /*
+         * If this payload is missing any information, we'll
+         * fill it in
+         */
+        new_hdr = (struct payload_hdr *) (buf->start - ehlen);
+        if ((void *) new_hdr < (void *) buf->rstart)
+        {
+            l2tp_log (LOG_WARNING, "%s: not enough space to decompress frame\n",
+                 __FUNCTION__);
+            return -EINVAL;
+
+        };
+        new_hdr->ver = *r;
+        if (PLBIT (new_hdr->ver))
+        {
+            r++;
+            new_hdr->length = *r;
+        }
+        else
+        {
+            new_hdr->length = buf->len + ehlen;
+        };
+        r++;
+        new_hdr->tid = *r;
+        r++;
+        new_hdr->cid = *r;
+        if (PFBIT (new_hdr->ver))
+        {
+            r++;
+            new_hdr->Ns = *r;
+            r++;
+            new_hdr->Nr = *r;
+        }
+        else
+        {
+            new_hdr->Nr = c->data_seq_num;
+            new_hdr->Ns = c->data_rec_seq_num;
+        };
+        if (PSBIT (new_hdr->ver))
+        {
+            r++;
+            new_hdr->o_size = *r;
+            r++;
+            new_hdr->o_pad = *r;
+        }
+        else
+        {
+            new_hdr->o_size = 0;
+            new_hdr->o_pad = 0;
+        }
+    }
+    else
+        new_hdr = h;
+    /*
+       * Handle sequence numbers
+       *
+     */
+/*  JLM	if (PRBIT(new_hdr->ver)) {
+		if (c->pSr > new_hdr->Ns) {
+			l2tp_log(LOG_DEBUG, "%s: R-bit set with Ns < pSr!\n",__FUNCTION__);
+			return -EINVAL;
+		}
+#ifdef DEBUG_FLOW
+		l2tp_log(LOG_DEBUG, "%s: R-bit set on packet %d\n",__FUNCTION__,new_hdr->Ns);
+#endif
+		c->pSr=new_hdr->Ns;
+	} */
+#ifdef DEBUG_PAYLOAD
+    l2tp_log (LOG_DEBUG, "%s: payload, cid = %d, Ns = %d, Nr = %d\n", __FUNCTION__,
+         c->cid, new_hdr->Ns, new_hdr->Nr);
+#endif
+    if (new_hdr->Ns != c->data_seq_num)
+    {
+        /* RFC1982-esque comparison of serial numbers */
+        if (((new_hdr->Ns < c->data_rec_seq_num) && 
+            ((c->data_rec_seq_num - new_hdr->Ns) < 32768)) ||
+            ((new_hdr->Ns > c->data_rec_seq_num) && 
+            ((c->data_rec_seq_num - new_hdr->Ns) > 32768)))
+        {
+#ifdef DEBUG_FLOW
+            if (DEBUG)
+                l2tp_log (LOG_DEBUG,
+                     "%s: Already seen this packet before (%d)\n",
+                     __FUNCTION__, new_hdr->Ns);
+#endif
+            return -EINVAL;
+        }
+        else if (new_hdr->Ns <= c->data_rec_seq_num + PAYLOAD_FUDGE)
+        {
+            /* FIXME: I should buffer for out of order packets */
+#ifdef DEBUG_FLOW
+            if (DEBUG)
+                l2tp_log (LOG_DEBUG,
+                     "%s: Oops, lost a packet or two (%d).  continuing...\n",
+                     __FUNCTION__, new_hdr->Ns);
+#endif
+            c->data_rec_seq_num = new_hdr->Ns;
+        }
+        else
+        {
+#ifdef DEBUG_FLOW
+            if (DEBUG)
+                l2tp_log (LOG_DEBUG,
+                     "%s: Received out of order payload packet (%d)\n",
+                     __FUNCTION__, new_hdr->Ns);
+#endif
+            return -EINVAL;
+        }
+    }
+    else
+    {
+        c->data_rec_seq_num++;
+        c->pnu = -1;
+    }
+    /*
+     * Check to see what the last thing
+     * we got back was
+     */
+    c->pLr = new_hdr->Nr;
+    buf->start = new_hdr;
+    buf->len += ehlen;
+    return 0;
+}
+
+void send_zlb (void *data)
+{
+    /*
+     * Send a ZLB.  This procedure should be schedule()able
+     */
+    struct call *c;
+    struct tunnel *t;
+    struct buffer *buf;
+    c = (struct call *) data;
+    if (!c)
+    {
+        l2tp_log (LOG_WARNING, "%s: called on NULL call\n", __FUNCTION__);
+        return;
+    }
+    t = c->container;
+    if (!t)
+    {
+        l2tp_log (LOG_WARNING, "%s: called on call with NULL container\n",
+             __FUNCTION__);
+        return;
+    }
+    /* Update the counter so we know what Lr was when we last transmited a ZLB */
+    c->prx = c->data_rec_seq_num;
+    buf = new_payload (t->peer);
+    add_payload_hdr (t, c, buf);
+    c->data_seq_num--;                   /* We don't increment on ZLB's */
+    c->zlb_xmit = NULL;
+#ifdef DEBUG_ZLB
+    l2tp_log (LOG_DEBUG, "%s: sending payload ZLB\n", __FUNCTION__);
+#endif
+    udp_xmit (buf, t);
+    toss (buf);
+}
+
+inline int call_write_packet (struct buffer *buf, struct tunnel *t, struct call *c,
+                         int convert)
+{
+    /*
+     * Write a packet, doing sync->async conversion if
+     * necessary
+     */
+    int x;
+    unsigned char e;
+    int err;
+    static unsigned char wbuf[MAX_RECV_SIZE];
+    int pos = 0;
+
+    if (c->fd < 0)
+    {
+        if (DEBUG)
+            l2tp_log (LOG_DEBUG, "%s: tty is not open yet.\n", __FUNCTION__);
+        return -EIO;
+    }
+    /*
+     * Skip over header 
+     */
+    buf->start += sizeof (struct payload_hdr);
+    buf->len -= sizeof (struct payload_hdr);
+
+    c->rx_pkts++;
+    c->rx_bytes += buf->len;
+
+    /*
+     * FIXME:  What about offset?
+     */
+    while (!convert)
+    {
+        /* We are given async frames, so write them
+           directly to the tty */
+        err = write (c->fd, buf->start, buf->len);
+        if (err == buf->len)
+        {
+            return 0;
+        }
+        else if (err == 0)
+        {
+            l2tp_log (LOG_WARNING, "%s: wrote no bytes of async packet\n",
+                 __FUNCTION__);
+            return -EINVAL;
+        }
+        else if (err < 0)
+        {
+            if ((errno == EAGAIN) || (errno == EINTR))
+            {
+                continue;
+            }
+            else
+            {
+                l2tp_log (LOG_WARNING, "%s: async write failed: %s\n", __FUNCTION__,
+                     strerror (errno));
+            }
+        }
+        else if (err < buf->len)
+        {
+            l2tp_log (LOG_WARNING, "%s: short write (%d of %d bytes)\n", __FUNCTION__,
+                 err, buf->len);
+            return -EINVAL;
+        }
+        else if (err > buf->len)
+        {
+            l2tp_log (LOG_WARNING, "%s: write returned LONGER than buffer length?\n",
+                 __FUNCTION__);
+            return -EINVAL;
+        }
+    }
+
+    /*
+     * sync->async conversion if we're doing sync frames
+     * since the pppd driver will expect async frames
+     * Write leading flag character
+     */
+
+    add_fcs (buf);
+    e = PPP_FLAG;
+    wbuf[pos++] = e;
+    for (x = 0; x < buf->len; x++)
+    {
+        // we must at least still have 3 bytes left in the worst case scenario:
+        // 1 for a possible escape, 1 for the value and 1 to end the PPP stream.
+        if(pos >= (sizeof(wbuf) - 4)) {
+            if(DEBUG)
+                l2tp_log(LOG_CRIT, "%s: rx packet is too big after PPP encoding (size %u, max is %u)\n",
+                                __FUNCTION__, buf->len, MAX_RECV_SIZE);
+            return -EINVAL;
+        }
+        e = *((char *) buf->start + x);
+        if ((e < 0x20) || (e == PPP_ESCAPE) || (e == PPP_FLAG))
+        {
+            /* Escape this */
+            e = e ^ 0x20;
+            wbuf[pos++] = PPP_ESCAPE;
+        }
+        wbuf[pos++] = e;
+
+    }
+    wbuf[pos++] = PPP_FLAG;
+
+#if 0
+    if(DEBUG) {
+      l2tp_log(LOG_DEBUG, "after sync->async, expanded %d->%d\n",
+	       buf->len, pos);
+    }
+#endif
+
+    x = write (c->fd, wbuf, pos);
+    if (x < pos)
+    {
+      if (DEBUG)
+	l2tp_log (LOG_WARNING, "%s: %s(%d)\n", __FUNCTION__, strerror (errno),
+		  errno);
+
+        if (!(errno == EINTR) && !(errno == EAGAIN))
+        {
+            /*
+               * I guess pppd died.  we'll pretend
+               * everything ended normally
+             */
+            c->needclose = -1;
+            c->fd = -1;
+            return -EIO;
+        }
+    }
+    return 0;
+}
+
+void handle_special (struct buffer *buf, struct call *c, _u16 call)
+{
+    /*
+       * This procedure is called when we have received a packet
+       * on a call which doesn't exist in our tunnel.  We want to
+       * send back a ZLB to keep the tunnel alive, on that particular
+       * call if it was a CDN, otherwise, send a CDN to notify them
+       * that this call has been terminated.
+     */
+    struct buffer *outgoing;
+    struct tunnel *t = c->container;
+    /* Don't do anything unless it's a control packet */
+    if (!CTBIT (*((_u16 *) buf->start)))
+        return;
+    /* Temporarily, we make the tunnel have cid of call instead of 0,
+       but we need to stop any scheduled events (like Hello's in
+       particular) which might use this value */
+    c->cid = call;
+    if (!check_control (buf, t, c))
+    {
+        if (buf->len == sizeof (struct control_hdr))
+        {
+            /* If it's a ZLB, we ignore it */
+            if (gconfig.debug_tunnel)
+                l2tp_log (LOG_DEBUG, "%s: ZLB for closed call\n", __FUNCTION__);
+            c->cid = 0;
+            return;
+        }
+        /* Make a packet with the specified call number */
+        outgoing = new_outgoing (t);
+        /* FIXME: If I'm not a CDN, I need to send a CDN */
+        control_zlb (buf, t, c);
+        c->cid = 0;
+        udp_xmit (buf, t);
+        toss (buf);
+    }
+    else
+    {
+        c->cid = 0;
+        if (gconfig.debug_tunnel)
+            l2tp_log (LOG_DEBUG, "%s: invalid control packet\n", __FUNCTION__);
+    }
+}
+
+inline int handle_packet (struct buffer *buf, struct tunnel *t,
+                          struct call *c)
+{
+    int res;
+/* tv code is commented out below
+#ifdef DEBUG_ZLB
+    struct timeval tv;
+#endif
+*/
+    if (CTBIT (*((_u16 *) buf->start)))
+    {
+        /* We have a control packet */
+        if (!check_control (buf, t, c))
+        {
+            c->msgtype = -1;
+            if (buf->len == sizeof (struct control_hdr))
+            {
+#ifdef DEBUG_ZLB
+                l2tp_log (LOG_DEBUG, "%s: control ZLB received\n", __FUNCTION__);
+#endif
+                t->control_rec_seq_num--;
+                c->cnu = 0;
+                if (c->needclose && c->closing)
+                {
+                    if (c->container->cLr >= c->closeSs)
+                    {
+#ifdef DEBUG_ZLB
+                        l2tp_log (LOG_DEBUG, "%s: ZLB for closing message found\n",
+                             __FUNCTION__);
+#endif
+                        c->needclose = 0;
+                        /* Trigger final closing of call */
+                    }
+                }
+                return 0;
+            }
+            else if (!handle_avps (buf, t, c))
+            {
+                return control_finish (t, c);
+            }
+            else
+            {
+                if (gconfig.debug_tunnel)
+                    l2tp_log (LOG_DEBUG, "%s: bad AVP handling!\n", __FUNCTION__);
+                return -EINVAL;
+            }
+        }
+        else
+        {
+	    if(DEBUG)
+        	l2tp_log (LOG_DEBUG, "%s: bad control packet!\n", __FUNCTION__);
+            return -EINVAL;
+        }
+    }
+    else
+    {
+        if (!check_payload (buf, t, c))
+        {
+            if (!expand_payload (buf, t, c))
+            {
+                if (buf->len > sizeof (struct payload_hdr))
+                {
+/*					if (c->throttle) {
+						if (c->pSs > c->pLr + c->rws) {
+#ifdef DEBUG_FLOW
+							l2tp_log(LOG_DEBUG, "%s: not yet dethrottling call\n",__FUNCTION__);
+#endif
+						} else {
+#ifdef DEBUG_FLOW
+							l2tp_log(LOG_DEBUG, "%s: dethrottling call\n",__FUNCTION__);
+#endif
+							if (c->dethrottle) deschedule(c->dethrottle);
+							c->dethrottle=NULL;
+							c->throttle = 0;
+						}
+					} */
+/*	JLM				res = call_write_packet(buf,t,c, c->frame & SYNC_FRAMING); */
+                    res = call_write_packet (buf, t, c, SYNC_FRAMING);
+                    if (res)
+                        return res;
+                    /* 
+                       * Assuming we wrote to the ppp driver okay, we should
+                       * do something about ZLB's unless *we* requested no
+                       * window size or if they we have turned off our fbit. 
+                     */
+
+/*					if (c->ourfbit && (c->ourrws > 0)) {
+						if (c->pSr >= c->prx + c->ourrws - 2) {
+						We've received enough to fill our receive window.  At
+						this point, we should immediately send a ZLB!
+#ifdef DEBUG_ZLB
+							l2tp_log(LOG_DEBUG, "%s: Sending immediate ZLB!\n",__FUNCTION__);
+#endif
+							if (c->zlb_xmit) {
+							Deschedule any existing zlb_xmit's
+								deschedule(c->zlb_xmit);
+								c->zlb_xmit = NULL;
+							}
+							send_zlb((void *)c);
+						} else {
+						struct timeval tv;
+						We need to schedule sending a ZLB.  FIXME:  Should
+						be 1/4 RTT instead, when rate adaptive stuff is
+						in place. Spec allows .5 seconds though
+							tv.tv_sec = 0;
+							tv.tv_usec = 500000;
+							if (c->zlb_xmit)
+								deschedule(c->zlb_xmit);
+#ifdef DEBUG_ZLB
+							l2tp_log(LOG_DEBUG, "%s: scheduling ZLB\n",__FUNCTION__);
+#endif
+							c->zlb_xmit = schedule(tv, &send_zlb, (void *)c);
+						}
+					} */
+                    return 0;
+                }
+                else if (buf->len == sizeof (struct payload_hdr))
+                {
+#ifdef DEBUG_ZLB
+                    l2tp_log (LOG_DEBUG, "%s: payload ZLB received\n",
+                         __FUNCTION__);
+#endif
+/*					if (c->throttle) {
+						if (c->pSs > c->pLr + c->rws) {
+#ifdef DEBUG_FLOW
+							l2tp_log(LOG_DEBUG, "%s: not yet dethrottling call\n",__FUNCTION__);
+#endif
+						} else {
+#ifdef DEBUG_FLOW
+							l2tp_log(LOG_DEBUG, "%s: dethrottling call\n",__FUNCTION__);
+#endif
+							if (c->dethrottle)
+								deschedule(c->dethrottle);
+							c->dethrottle=NULL;
+							c->throttle = 0;
+						}
+					} */
+                    c->data_rec_seq_num--;
+                    return 0;
+                }
+                else
+                {
+		    if(DEBUG)
+                	l2tp_log (LOG_DEBUG, "%s: payload too small!\n", __FUNCTION__);
+                    return -EINVAL;
+                }
+            }
+            else
+            {
+                if (gconfig.debug_tunnel)
+                    l2tp_log (LOG_DEBUG, "%s: unable to expand payload!\n",
+                         __FUNCTION__);
+                return -EINVAL;
+            }
+        }
+        else
+        {
+	    if(DEBUG)
+        	l2tp_log (LOG_DEBUG, "%s: invalid payload packet!\n", __FUNCTION__);
+            return -EINVAL;
+        }
+    }
+}
--- ppp-2.4.4.orig/pppd/plugins/pppol2tp/control.h	1970-01-01 03:00:00.000000000 +0300
+++ ppp-2.4.4/pppd/plugins/pppol2tp/control.h	2011-01-24 13:53:48.000000000 +0300
@@ -0,0 +1,67 @@
+/*
+ * Layer Two Tunnelling Protocol Daemon
+ * Copyright (C) 1998 Adtran, Inc.
+ * Copyright (C) 2002 Jeff McAdams
+ *
+ * Mark Spencer
+ *
+ * This software is distributed under the terms
+ * of the GPL, which you should have received
+ * along with this source.
+ *
+ * Control Packet Handling header
+ *
+ */
+
+#include "common.h"
+
+/* Declaration of FIFO used for maintaining
+   a reliable control connection, as well
+   as for queueing stuff for the individual
+   threads */
+#ifndef _CONTROL_H
+#define _CONTROL_H
+/* Control message types  for vendor-ID 0, placed in the VALUE
+   field of AVP requests */
+
+/* Control Connection Management */
+#define SCCRQ 	1               /* Start-Control-Connection-Request */
+#define SCCRP 	2               /* Start-Control-Connection-Reply */
+#define SCCCN 	3               /* Start-Control-Connection-Connected */
+#define StopCCN 4               /* Stop-Control-Connection-Notification */
+/* 5 is reserved */
+#define Hello	6               /* Hello */
+/* Call Management */
+#define OCRQ	7               /* Outgoing-Call-Request */
+#define OCRP	8               /* Outgoing-Call-Reply */
+#define OCCN	9               /* Outgoing-Call-Connected */
+#define ICRQ	10              /* Incoming-Call-Request */
+#define ICRP	11              /* Incoming-Call-Reply */
+#define ICCN	12              /* Incoming-Call-Connected */
+/* 13 is reserved */
+#define CDN	14              /* Call-Disconnect-Notify */
+/* Error Reporting */
+#define WEN	15              /* WAN-Error-Notify */
+/* PPP Sesssion Control */
+#define SLI	16              /* Set-Link-Info */
+
+#define MAX_MSG 16
+
+#define TBIT 0x8000
+#define LBIT 0x4000
+#define RBIT 0x2000
+#define FBIT 0x0800
+
+extern int handle_packet (struct buffer *, struct tunnel *, struct call *);
+extern struct buffer *new_outgoing (struct tunnel *);
+extern void add_control_hdr (struct tunnel *t, struct call *c,
+                             struct buffer *);
+extern int control_finish (struct tunnel *t, struct call *c);
+extern void control_zlb (struct buffer *, struct tunnel *, struct call *);
+extern void recycle_outgoing (struct buffer *, struct sockaddr_in);
+extern void handle_special (struct buffer *, struct call *, _u16);
+extern void hello (void *);
+extern void send_zlb (void *);
+extern void dethrottle (void *);
+
+#endif
--- ppp-2.4.4.orig/pppd/plugins/pppol2tp/file.c	1970-01-01 03:00:00.000000000 +0300
+++ ppp-2.4.4/pppd/plugins/pppol2tp/file.c	2011-01-24 13:53:48.000000000 +0300
@@ -0,0 +1,87 @@
+/*
+ * Layer Two Tunnelling Protocol Daemon
+ * Copyright (C) 1998 Adtran, Inc.
+ * Copyright (C) 2002 Jeff McAdams
+ *
+ * Mark Spencer
+ *
+ * This software is distributed under the terms
+ * of the GPL, which you should have received
+ * along with this source.
+ *
+ * File format handling
+ *
+ */
+
+#include <stdio.h>
+#include <string.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <netdb.h>
+#include <netinet/in.h>
+#include <time.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+
+#include "l2tp.h"
+
+struct lac *laclist;
+struct global gconfig;
+
+struct lac *new_lac ()
+{
+    struct lac *tmp;
+    tmp = (struct lac *) zalloc (sizeof (struct lac));
+    if (!tmp)
+    {
+        l2tp_log (LOG_CRIT, "%s: Unable to allocate memory for lac entry!\n",
+             __FUNCTION__);
+        return NULL;
+    }
+    tmp->rsched = NULL;
+    tmp->lns = 0;
+    tmp->tun_rws = 4;
+    tmp->call_rws = 10;
+    tmp->hbit = 0;
+    tmp->lbit = 0;
+    tmp->t = NULL;
+    tmp->challenge = 0;
+    tmp->active = 0;
+    return tmp;
+}
+
+
+
+int init_config (char *lns) {
+    char *port;
+    
+    gconfig.port = UDP_LISTEN_PORT;
+    gconfig.listenaddr = htonl(INADDR_ANY); /* Default is to bind (listen) to all interfaces */
+    gconfig.debug_avp = 0;
+    gconfig.debug_network = 0;
+    gconfig.packet_dump = 0;
+    gconfig.debug_tunnel = 0;
+    gconfig.debug_state = 0;
+    gconfig.ipsecsaref = 0;
+
+    if( (laclist = new_lac()) ) {
+	if( !(laclist->lns = (struct host*)zalloc(sizeof(struct host))) ) {
+	    l2tp_log (LOG_CRIT, "%s: Unable to allocate memory for lns entry!\n",
+             __FUNCTION__);
+	     free(laclist);
+	     laclist = NULL;
+	     return -1;
+	}
+	memset(laclist->lns, 0, sizeof(struct host));
+	if( (port = strchr(lns, ':')) ) {
+	    memcpy(laclist->lns->hostname, lns, MIN((int)(port - lns), (sizeof(laclist->lns->hostname) - 1)));
+	    laclist->lns->port = atoi(port + 1);
+	} else {
+	    strncpy(laclist->lns->hostname, lns, sizeof(laclist->lns->hostname) - 1);
+	    laclist->lns->port = UDP_LISTEN_PORT;
+	}
+    }
+    
+    return 0;
+}
+
--- ppp-2.4.4.orig/pppd/plugins/pppol2tp/file.h	1970-01-01 03:00:00.000000000 +0300
+++ ppp-2.4.4/pppd/plugins/pppol2tp/file.h	2011-01-24 13:53:48.000000000 +0300
@@ -0,0 +1,71 @@
+/*
+ * Layer Two Tunnelling Protocol Daemon
+ * Copyright (C) 1998 Adtran, Inc.
+ * Copyright (C) 2002 Jeff McAdams
+ *
+ * Mark Spencer
+ *
+ * This software is distributed under the terms
+ * of the GPL, which you should have received
+ * along with this source.
+ *
+ * File format handling header file
+ *
+ */
+
+#ifndef _FILE_H
+#define _FILE_H
+
+#define STRLEN 80               /* Length of a string */
+
+struct host
+{
+    char hostname[STRLEN];
+    int port;
+};
+
+#define AUTH_FILE "/etc/ppp/l2tp-secrets"
+
+#define CONTEXT_GLOBAL 	1
+#define CONTEXT_LNS	   	2
+#define CONTEXT_LAC		3
+#define CONTEXT_DEFAULT	256
+
+#define SENSE_ALLOW -1
+#define SENSE_DENY 0
+
+struct lac
+{
+    struct host *lns;           /* LNS's we can connect to */
+    struct schedule_entry *rsched;
+    int tun_rws;                /* Receive window size (tunnel) */
+    int call_rws;               /* Call rws */
+    int active;                 /* Is this connection in active use? */
+    int hbit;                   /* Permit hidden AVP's? */
+    int lbit;                   /* Use the length field? */
+    int challenge;              /* Challenge authenticate the peer? */
+    char peername[STRLEN];      /* Force peer name to this */
+    char hostname[STRLEN];      /* Hostname to report */
+    char entname[STRLEN];       /* Name of this entry */
+    int idle;                   /* Idle timeout in seconds */
+    struct tunnel *t;           /* Our tunnel */
+    struct call *c;             /* Our call */
+};
+
+struct global
+{
+    unsigned int listenaddr;    /* IP address to bind to */ 
+    int port;                   /* Port number to listen to */
+    int packet_dump;		/* Dump (print) all packets? */
+    int debug_avp;		/* Print AVP debugging info? */
+    int debug_network;		/* Print network debugging info? */
+    int debug_tunnel;		/* Print tunnel debugging info? */
+    int debug_state;		/* Print FSM debugging info? */
+    int ipsecsaref;
+};
+
+extern struct global gconfig;   /* Global configuration options */
+
+extern struct lac *laclist;     /* All LAC entries */
+extern int init_config(char *lns);
+#endif
--- ppp-2.4.4.orig/pppd/plugins/pppol2tp/ipsecmast.h	1970-01-01 03:00:00.000000000 +0300
+++ ppp-2.4.4/pppd/plugins/pppol2tp/ipsecmast.h	2011-01-24 13:53:48.000000000 +0300
@@ -0,0 +1,14 @@
+#ifndef _IPSECMAST_H
+#define _IPSECMAST_H
+
+#ifndef IP_IPSEC_REFINFO
+#define IP_IPSEC_REFINFO 18
+#endif
+
+#ifndef IPSEC_SAREF_NULL
+typedef uint32_t IPsecSAref_t;
+
+#define IPSEC_SAREF_NULL ((IPsecSAref_t)0)
+#endif
+
+#endif
--- ppp-2.4.4.orig/pppd/plugins/pppol2tp/l2tp.c	1970-01-01 03:00:00.000000000 +0300
+++ ppp-2.4.4/pppd/plugins/pppol2tp/l2tp.c	2011-01-24 15:16:22.000000000 +0300
@@ -0,0 +1,443 @@
+/* pppol2tp.c - pppd plugin to implement PPPoL2TP protocol
+ *   for Linux using kernel pppol2tp support.
+ *
+ * Requires kernel pppol2tp driver which is distributed with
+ * OpenL2TP at http://www.sourceforge.net/projects/openl2tp/
+ *
+ * By Martijn van Oosterhout <kleptog@svana.org>
+ * Modified for OpenL2TP by jchapman@katalix.com
+ *
+ * Heavily based upon pppoatm.c: original notice follows
+ *
+ * Copyright 2000 Mitchell Blank Jr.
+ * Based in part on work from Jens Axboe and Paul Mackerras.
+ * Updated to ppp-2.4.1 by Bernhard Kaindl
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License
+ *  as published by the Free Software Foundation; either version
+ *  2 of the License, or (at your option) any later version.
+ */
+#include <unistd.h>
+#include <string.h>
+#include <stdlib.h>
+#include <errno.h>
+#include "pppd.h"
+#include "pathnames.h"
+#include "fsm.h"
+#include "lcp.h"
+#include "ccp.h"
+#include "ipcp.h"
+#include <sys/stat.h>
+#include <net/if.h>
+#include <sys/ioctl.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <signal.h>
+#include <linux/version.h>
+#include <linux/sockios.h>
+#ifndef aligned_u64
+/* should be defined in sys/types.h */
+#define aligned_u64 unsigned long long __attribute__((aligned(8)))
+#endif
+#include <linux/types.h>
+#include <linux/if_ether.h>
+#include <linux/ppp_defs.h>
+#include <linux/if_ppp.h>
+#include <linux/if_pppox.h>
+#include <linux/if_pppol2tp.h>
+#include "l2tp.h"
+
+/* should be added to system's socket.h... */
+#ifndef SOL_PPPOL2TP
+#define SOL_PPPOL2TP	273
+#endif
+
+const char pppd_version[] = VERSION;
+
+static int setdevname_pppol2tp();
+static char * pppol2tp_lns = "";
+
+static bool pppol2tp_recv_seq = 0;
+static bool pppol2tp_send_seq = 0;
+static int pppol2tp_debug_mask = 0;
+static int pppol2tp_reorder_timeout = 0;
+static char pppol2tp_ifname[32] = { 0, };
+
+static int device_got_set = 0;
+struct channel pppol2tp_channel;
+static int pppol2tp_num = 0;
+
+static void (*old_snoop_recv_hook)(unsigned char *p, int len) = NULL;
+static void (*old_snoop_send_hook)(unsigned char *p, int len) = NULL;
+static void (*old_ip_up_hook)(void) = NULL;
+static void (*old_ip_down_hook)(void) = NULL;
+
+/* Hook provided to allow other plugins to handle ACCM changes */
+void (*pppol2tp_send_accm_hook)(int tunnel_id, int session_id, uint32_t send_accm, uint32_t recv_accm) = NULL;
+
+/* Hook provided to allow other plugins to handle IP up/down */
+void (*pppol2tp_ip_updown_hook)(int tunnel_id, int session_id, int up) = NULL;
+
+static option_t pppol2tp_options[] = {
+	{ "l2tp_send_seq", o_bool, &pppol2tp_send_seq,
+	  "L2TP enable sequence numbers in transmitted data packets. Default off.", 
+	  OPT_PRIO | OPRIO_CFGFILE },
+	{ "l2tp_lns", o_string, &pppol2tp_lns,
+          "L2TP lns server" },
+	{ "l2tp_recv_seq", o_bool, &pppol2tp_recv_seq,
+	  "L2TP enforce sequence numbers in received data packets. Default off.", 
+	  OPT_PRIO | OPRIO_CFGFILE },
+	{ "l2tp_reorderto", o_int, &pppol2tp_reorder_timeout,
+	  "L2TP data packet reorder timeout. Default 0 (no reordering).", 
+	  OPT_PRIO },
+	{ "l2tp_debug_mask", o_int, &pppol2tp_debug_mask,
+	  "L2TP debug mask. Default: no debug.", 
+	  OPT_PRIO },
+	{ "l2tp_ifname", o_string, &pppol2tp_ifname,
+	  "L2TP interface name of PPP interface",
+	  OPT_PRIO | OPT_PRIV | OPT_STATIC, NULL, 16 },
+	{ NULL }
+};
+
+static int setdevname_pppol2tp()
+{
+	if (device_got_set)
+		return 0;
+		
+	sprintf(ppp_devnam, "l2tp[%d]", pppol2tp_num++);
+	pppol2tp_num %= 100;	
+	
+#ifndef _DISABLE_SERIAL_
+	modem = 0;
+#endif
+
+	lcp_allowoptions[0].neg_accompression = 1;
+	lcp_wantoptions[0].neg_accompression = 0;
+
+	lcp_allowoptions[0].neg_pcompression = 1;
+	lcp_wantoptions[0].neg_pcompression = 0;
+
+#ifdef CCP_SUPPORT
+	ccp_allowoptions[0].deflate = 0;
+	ccp_wantoptions[0].deflate = 0;
+#endif
+
+	ipcp_allowoptions[0].neg_vj = 0;
+	ipcp_wantoptions[0].neg_vj = 0;
+
+#ifdef CCP_SUPPORT
+	ccp_allowoptions[0].bsd_compress = 0;
+	ccp_wantoptions[0].bsd_compress = 0;
+#endif
+
+	the_channel = &pppol2tp_channel;
+	device_got_set = 1;
+
+	return 1;
+}
+
+static int connect_pppol2tp(void)
+{
+    if( l2tp_init(pppol2tp_lns) ) {
+	fatal("l2tp_init failed");
+    } else {
+   	l2tp_wait_socket();
+		if( isock_fd == -1 ) {
+	    fatal("l2tp_get_socket failed");
+		}
+    }
+    return isock_fd;
+}
+
+static void disconnect_pppol2tp(void) {
+    l2tp_exit();
+}
+
+static void clean_pppol2tp(void) {
+    l2tp_exit();
+}
+
+static void send_config_pppol2tp(int mtu,
+			      u_int32_t asyncmap,
+			      int pcomp,
+			      int accomp)
+{
+    int on = 1;
+    char reorderto[16];
+    char tid[8];
+    char sid[8];
+    
+    if( isock_fd == -1 ) return;
+    
+	if (pppol2tp_ifname[0]) {
+		struct ifreq ifr;
+		int fd;
+
+		fd = socket(AF_INET, SOCK_DGRAM, 0);
+		if (fd >= 0) {
+			memset (&ifr, '\0', sizeof (ifr));
+			strlcpy(ifr.ifr_name, ifname, sizeof(ifr.ifr_name));
+			strlcpy(ifr.ifr_newname, pppol2tp_ifname, sizeof(ifr.ifr_name));
+			ioctl(fd, SIOCSIFNAME, (caddr_t) &ifr);
+			strlcpy(ifname, pppol2tp_ifname, 32);
+			if (pppol2tp_debug_mask & PPPOL2TP_MSG_CONTROL) {
+				dbglog("ppp%d: interface name %s", ifunit, ifname);
+			}
+		}
+		close(fd);
+	}
+
+	if ((lcp_allowoptions[0].mru > 0) && (mtu > lcp_allowoptions[0].mru)) {
+		warn("Overriding mtu %d to %d", mtu, lcp_allowoptions[0].mru);
+		mtu = lcp_allowoptions[0].mru;
+	}
+	netif_set_mtu(ifunit, mtu);
+
+	reorderto[0] = '\0';
+	if (pppol2tp_reorder_timeout > 0)
+		sprintf(&reorderto[0], "%d ", pppol2tp_reorder_timeout);
+	tid[0] = '\0';
+	sid[0] = '\0';
+	
+	if (pppol2tp_debug_mask & PPPOL2TP_MSG_CONTROL)
+	    dbglog("PPPoL2TP options: %s%s%s%s%s%s%s%s%sdebugmask %d", 
+	       pppol2tp_recv_seq ? "recvseq " : "",
+	       pppol2tp_send_seq ? "sendseq " : "",
+	       "",
+	       pppol2tp_reorder_timeout ? "reorderto " : "", reorderto,
+	       "", tid,
+	       "", sid,
+	       pppol2tp_debug_mask);	
+
+	if (pppol2tp_recv_seq)
+		if (setsockopt(isock_fd, SOL_PPPOL2TP, PPPOL2TP_SO_RECVSEQ, &on, sizeof(on)) < 0)
+			fatal("setsockopt(PPPOL2TP_RECVSEQ): %m");
+	if (pppol2tp_send_seq)
+		if (setsockopt(isock_fd, SOL_PPPOL2TP, PPPOL2TP_SO_SENDSEQ, &on, sizeof(on)) < 0)
+			fatal("setsockopt(PPPOL2TP_SENDSEQ): %m");
+	if (pppol2tp_reorder_timeout)
+		if (setsockopt(isock_fd, SOL_PPPOL2TP, PPPOL2TP_SO_REORDERTO, &pppol2tp_reorder_timeout, sizeof(pppol2tp_reorder_timeout)) < 0)
+			fatal("setsockopt(PPPOL2TP_REORDERTO): %m");
+	if (pppol2tp_debug_mask)
+		if (setsockopt(isock_fd, SOL_PPPOL2TP, PPPOL2TP_SO_DEBUG, &pppol2tp_debug_mask, sizeof(pppol2tp_debug_mask)) < 0)
+			fatal("setsockopt(PPPOL2TP_DEBUG): %m");
+}
+
+static void recv_config_pppol2tp(int mru,
+			      u_int32_t asyncmap,
+			      int pcomp,
+			      int accomp)
+{
+	if( isock_fd == -1 ) return;
+	
+	if ((lcp_allowoptions[0].mru > 0) && (mru > lcp_allowoptions[0].mru)) {
+		warn("Overriding mru %d to mtu value %d", mru, lcp_allowoptions[0].mru);
+		mru = lcp_allowoptions[0].mru;
+	}
+	if ((ifunit >= 0) && ioctl(isock_fd, PPPIOCSMRU, (caddr_t) &mru) < 0)
+		error("Couldn't set PPP MRU: %m");
+}
+
+/*****************************************************************************
+ * Snoop LCP message exchanges to capture negotiated ACCM values.
+ * When asyncmap values have been seen from both sides, give the values to
+ * L2TP.
+ * This code is derived from Roaring Penguin L2TP.
+ *****************************************************************************/
+
+static void pppol2tp_lcp_snoop(unsigned char *buf, int len, int incoming)
+{
+	static bool got_send_accm = 0;
+	static bool got_recv_accm = 0;
+	static uint32_t recv_accm = 0xffffffff;
+	static uint32_t send_accm = 0xffffffff;
+	static bool snooping = 1;
+
+	uint16_t protocol;
+	uint16_t lcp_pkt_len;
+	int opt, opt_len;
+	int reject;
+	unsigned char const *opt_data;
+	uint32_t accm;
+
+	/* Skip HDLC header */
+	buf += 2;
+	len -= 2;
+
+	/* Unreasonably short frame?? */
+	if (len <= 0) return;	
+
+	/* Get protocol */
+	if (buf[0] & 0x01) {
+		/* Compressed protcol field */
+		protocol = buf[0];
+	} else {
+		protocol = ((unsigned int) buf[0]) * 256 + buf[1];
+	}
+
+	/* If it's a network protocol, stop snooping */
+	if (protocol <= 0x3fff) {
+		if (pppol2tp_debug_mask & PPPOL2TP_MSG_DEBUG) {
+			dbglog("Turning off snooping: Network protocol %04x found.", protocol);
+		}
+		snooping = 0;
+		return;
+	}
+
+	/* If it's not LCP, do not snoop */
+	if (protocol != 0xc021) {
+		return;
+	}
+
+	/* Skip protocol; go to packet data */
+	buf += 2;
+	len -= 2;
+
+	/* Unreasonably short frame?? */
+	if (len <= 0) return;
+
+	/* Look for Configure-Ack or Configure-Reject code */
+	if (buf[0] != CONFACK && buf[0] != CONFREJ) return;
+
+	reject = (buf[0] == CONFREJ);
+
+	lcp_pkt_len = ((unsigned int) buf[2]) * 256 + buf[3];
+
+	/* Something fishy with length field? */
+	if (lcp_pkt_len > len) return;
+
+	/* Skip to options */
+	len = lcp_pkt_len - 4;
+	buf += 4;
+
+	while (len > 0) {
+		/* Pull off an option */
+		opt = buf[0];
+		opt_len = buf[1];
+		opt_data = &buf[2];
+		if (opt_len > len || opt_len < 2) break;
+		len -= opt_len;
+		buf += opt_len;
+		if (pppol2tp_debug_mask & PPPOL2TP_MSG_DEBUG) {
+			dbglog("Found option type %02x; len %d", opt, opt_len);
+		}
+
+		/* We are specifically interested in ACCM */
+		if (opt == CI_ASYNCMAP && opt_len == 0x06) {
+			if (reject) {
+				/* ACCM negotiation REJECTED; use default */
+				accm = 0xffffffff;
+				if (pppol2tp_debug_mask & PPPOL2TP_MSG_DATA) {
+					dbglog("Rejected ACCM negotiation; defaulting (%s)", incoming ? "incoming" : "outgoing");
+				}
+				recv_accm = accm;
+				send_accm = accm;
+				got_recv_accm = 1;
+				got_send_accm = 1;
+			} else {
+				memcpy(&accm, opt_data, sizeof(accm));
+				if (pppol2tp_debug_mask & PPPOL2TP_MSG_DATA) {
+					dbglog("Found ACCM of %08x (%s)", accm, incoming ? "incoming" : "outgoing");
+				}
+				if (incoming) {
+					recv_accm = accm;
+					got_recv_accm = 1;
+				} else {
+					send_accm = accm;
+					got_send_accm = 1;
+				}
+			}
+
+			if (got_recv_accm && got_send_accm) {
+				if (pppol2tp_debug_mask & PPPOL2TP_MSG_CONTROL) {
+					dbglog("Telling L2TP: Send ACCM = %08x; Receive ACCM = %08x", send_accm, recv_accm);
+				}
+				if (pppol2tp_send_accm_hook != NULL) {
+					(*pppol2tp_send_accm_hook)(0, 0, send_accm, recv_accm);
+				}
+				got_recv_accm = 0;
+				got_send_accm = 0;
+			}
+		}
+	}
+}
+
+static void pppol2tp_lcp_snoop_recv(unsigned char *p, int len)
+{
+	if (old_snoop_recv_hook != NULL)
+		(*old_snoop_recv_hook)(p, len);
+	pppol2tp_lcp_snoop(p, len, 1);
+}
+
+static void pppol2tp_lcp_snoop_send(unsigned char *p, int len)
+{
+	if (old_snoop_send_hook != NULL)
+		(*old_snoop_send_hook)(p, len);
+	pppol2tp_lcp_snoop(p, len, 0);
+}
+
+/*****************************************************************************
+ * Interface up/down events
+ *****************************************************************************/
+
+static void pppol2tp_ip_up_hook(void)
+{
+	if (old_ip_up_hook != NULL)
+		(*old_ip_up_hook)();
+
+	if (pppol2tp_ip_updown_hook != NULL) {
+		(*pppol2tp_ip_updown_hook)(0, 0, 1);
+	}
+}
+
+static void pppol2tp_ip_down_hook(void)
+{
+	if (old_ip_down_hook != NULL)
+		(*old_ip_down_hook)();
+
+	if (pppol2tp_ip_updown_hook != NULL) {
+		(*pppol2tp_ip_updown_hook)(0, 0, 0);
+	}
+}
+
+/*****************************************************************************
+ * Application init
+ *****************************************************************************/
+
+static void pppol2tp_check_options(void)
+{
+	/* Hook up ip up/down hooks to send indicator to openl2tpd that the link is up */
+	old_ip_up_hook = ip_up_hook;
+	ip_up_hook = pppol2tp_ip_up_hook;
+	old_ip_down_hook = ip_down_hook;
+	ip_down_hook = pppol2tp_ip_down_hook;
+}
+
+void plugin_init(void)
+{
+#if defined(__linux__)
+	extern int new_style_driver;	/* From sys-linux.c */
+	if (!ppp_available() && !new_style_driver)
+		fatal("Kernel doesn't support ppp_generic - "
+		    "needed for PPPoL2TP");
+#else
+	fatal("No PPPoL2TP support on this OS");
+#endif
+	add_options(pppol2tp_options);
+	setdevname_pppol2tp();
+}
+
+struct channel pppol2tp_channel = {
+    options: pppol2tp_options,
+    process_extra_options: NULL,
+    check_options: &pppol2tp_check_options,
+    connect: &connect_pppol2tp,
+    disconnect: &disconnect_pppol2tp,
+    establish_ppp: &generic_establish_ppp,
+    disestablish_ppp: &generic_disestablish_ppp,
+    send_config: &send_config_pppol2tp,
+    recv_config: &recv_config_pppol2tp, 
+    close: NULL,
+    cleanup: &clean_pppol2tp, 
+};
--- ppp-2.4.4.orig/pppd/plugins/pppol2tp/l2tp.h	1970-01-01 03:00:00.000000000 +0300
+++ ppp-2.4.4/pppd/plugins/pppol2tp/l2tp.h	2011-01-24 14:02:22.000000000 +0300
@@ -0,0 +1,244 @@
+/*
+ * Layer Two Tunnelling Protocol Daemon
+ * Copyright (C) 1998 Adtran, Inc.
+ * Copyright (C) 2002 Jeff McAdams
+ *
+ * Mark Spencer
+ *
+ * This software is distributed under the terms
+ * of the GPL, which you should have received
+ * along with this source.
+ *
+ * Protocol and implementation information,
+ * structures and constants.
+ */
+/*
+typedef unsigned short _u16;
+typedef unsigned long long _u64;
+ */
+#ifndef _L2TP_H
+#define _L2TP_H
+
+#define MAXSTRLEN 120           /* Maximum length of common strings */
+
+#include <netinet/in.h>
+#include <termios.h>
+#include "osport.h"
+#include "scheduler.h"
+#include "misc.h"
+#include "file.h"
+#include "call.h"
+#include "avp.h"
+#include "control.h"
+#include "common.h"
+#include "ipsecmast.h"
+#include "aaa.h"
+
+#define BINARY "l2tp_plugin"
+#define SERVER_VERSION "xl2tpd-1.1.11-plugin-0.1"
+#define VENDOR_NAME "xelerance.com"
+#define FIRMWARE_REV	0x0690  /* Revision of our firmware (software, in this case) */
+#define DEF_MAX_TUNNELS 1      /* By default only allow this many
+                                   tunnels to exist */
+
+#define HELLO_DELAY 60          /* How often to send a Hello message */
+
+struct control_hdr
+{
+    _u16 ver;                   /* Version and more */
+    _u16 length;                /* Length field */
+    _u16 tid;                   /* Tunnel ID */
+    _u16 cid;                   /* Call ID */
+    _u16 Ns;                    /* Next sent */
+    _u16 Nr;                    /* Next received */
+} __attribute__((packed));
+
+#define CTBIT(ver) (ver & 0x8000)       /* Determins if control or not */
+#define CLBIT(ver) (ver & 0x4000)       /* Length bit present.  Must be 1
+                                           for control messages */
+
+#define CZBITS(ver) (ver &0x37F8)       /* Reserved bits:  We must drop 
+                                           anything with these there */
+
+#define CFBIT(ver) (ver & 0x0800)       /* Presence of Ns and Nr fields
+                                           flow bit? */
+
+#define CVER(ver) (ver & 0x0007)        /* Version of encapsulation */
+
+
+struct payload_hdr
+{
+    _u16 ver;                   /* Version and friends */
+    _u16 length;                /* Optional Length */
+    _u16 tid;                   /* Tunnel ID */
+    _u16 cid;                   /* Caller ID */
+    _u16 Ns;                    /* Optional next sent */
+    _u16 Nr;                    /* Optional next received */
+    _u16 o_size;                /* Optional offset size */
+    _u16 o_pad;                 /* Optional offset padding */
+} __attribute__((packed));
+
+#define NZL_TIMEOUT_DIVISOR 4   /* Divide TIMEOUT by this and
+                                   you know how often to send
+                                   a zero byte packet */
+
+#define PAYLOAD_BUF 10          /* Provide 10 expansion bytes
+                                   so we can "decompress" the
+                                   payloads and simplify coding */
+#if 1
+#define DEFAULT_MAX_RETRIES 10    /* Recommended value from spec */
+#else
+#define DEFAULT_MAX_RETRIES 95   /* give us more time to debug */
+#endif
+
+#define DEFAULT_RWS_SIZE   4    /* Default max outstanding 
+                                   control packets in queue */
+#define DEFAULT_TX_BPS		10000000        /* For outgoing calls, report this speed */
+#define DEFAULT_RX_BPS		10000000
+#define DEFAULT_MAX_BPS		10000000        /* jz: outgoing calls max bps */
+#define DEFAULT_MIN_BPS		10000   /* jz: outgoing calls min bps */
+#define PAYLOAD_FUDGE		2       /* How many packets we're willing to drop */
+#define MIN_PAYLOAD_HDR_LEN 6
+
+#define UDP_LISTEN_PORT  1701
+                                /* FIXME: MAX_RECV_SIZE, what is it? */
+#define MAX_RECV_SIZE 4096      /* Biggest packet we'll accept */
+
+#define OUR_L2TP_VERSION 0x100  /* We support version 1, revision 0 */
+
+#define PTBIT(ver) CTBIT(ver)   /* Type bit:  Must be zero for us */
+#define PLBIT(ver) CLBIT(ver)   /* Length specified? */
+#define PFBIT(ver) CFBIT(ver)   /* Flow control specified? */
+#define PVER(ver) CVER(ver)     /* Version */
+#define PZBITS(ver) (ver & 0x14F8)      /* Reserved bits */
+#define PRBIT(ver) (ver & 0x2000)       /* Reset Sr bit */
+#define PSBIT(ver) (ver & 0x0200)       /* Offset size bit */
+#define PPBIT(ver) (ver & 0x0100)       /* Preference bit */
+
+struct tunnel
+{
+    struct call *call_head;     /* Member calls */
+    struct tunnel *next;        /* Allows us to be linked easily */
+
+    int fc;                     /* Framing capabilities of peer */
+    struct schedule_entry *hello;
+    int ourfc;                  /* Our framing capabilities */
+    int bc;                     /* Peer's bearer channels */
+    int hbit;                   /* Allow hidden AVP's? */
+    int ourbc;                  /* Our bearer channels */
+    _u64 tb;                    /* Their tie breaker */
+    _u64 ourtb;                 /* Our tie breaker */
+    int tid;                    /* Peer's tunnel identifier */
+    IPsecSAref_t refme;         /* IPsec SA particulars */
+    IPsecSAref_t refhim;
+    int ourtid;                 /* Our tunnel identifier */
+    int qtid;                   /* TID for disconnection */
+    int firmware;               /* Peer's firmware revision */
+#if 0
+    unsigned int addr;          /* Remote address */
+    unsigned short port;        /* Port on remote end */
+#else
+    struct sockaddr_in peer;    /* Peer's Address */
+#endif
+    int debug;                  /* Are we debugging or not? */
+    int nego;                   /* Show Negotiation? */
+    int count;
+    int state;                  /* State of tunnel */
+    _u16 control_seq_num;       /* Sequence for next packet */
+    _u16 control_rec_seq_num;   /* Next expected to receive */
+    int cLr;                    /* Last packet received by peer */
+    char hostname[MAXSTRLEN];   /* Remote hostname */
+    char vendor[MAXSTRLEN];     /* Vendor of remote product */
+    struct challenge chal_us;   /* Their Challenge to us */
+    struct challenge chal_them; /* Our challenge to them */
+    char secret[MAXSTRLEN];     /* Secret to use */
+#ifdef SANITY
+    int sanity;                 /* check for sanity? */
+#endif
+    int rws;                    /* Peer's Receive Window Size */
+    int ourrws;                 /* Receive Window Size */
+    struct call *self;
+    struct lac *lac;            /* LAC that owns us */
+};
+
+struct tunnel_list
+{
+    struct tunnel *head;
+    int count;
+    int calls;
+};
+
+/* Values for version */
+#define VER_L2TP 2
+#define VER_PPTP 3
+
+/* Some PPP sync<->async stuff */
+#define fcstab  ppp_crc16_table
+
+#define PPP_FLAG 0x7e
+#define PPP_ESCAPE 0x7d
+#define PPP_TRANS 0x20
+
+#define PPP_INITFCS 0xffff
+#define PPP_GOODFCS 0xf0b8
+#define PPP_FCS(fcs,c) (((fcs) >> 8) ^ fcstab[((fcs) ^ (c)) & 0xff])
+
+/* Values for Randomness sources */
+#define RAND_DEV 0x0
+#define RAND_SYS 0x1
+#define RAND_EGD 0x2
+
+
+/* Error Values */
+
+extern struct tunnel_list tunnels;
+extern void tunnel_close (struct tunnel *t);
+extern void *network_thread (void*);
+extern int init_network ();
+extern void close_network ();
+extern int max_tunnels;
+extern int server_socket; 
+extern struct tunnel *new_tunnel ();
+extern struct packet_queue xmit_udp;
+extern void destroy_tunnel (struct tunnel *);
+extern struct buffer *new_payload (struct sockaddr_in);
+extern void recycle_payload (struct buffer *, struct sockaddr_in);
+extern void add_payload_hdr (struct tunnel *, struct call *, struct buffer *);
+extern int call_read_packet (struct buffer *, int, int);
+extern void udp_xmit (struct buffer *buf, struct tunnel *t);
+extern void control_xmit (void *);
+extern int ppd;
+extern int iexit;
+extern void start_pppd (struct call *c);
+extern void stop_pppd(int istat);
+extern void magic_lac_dial (void *);
+extern int get_entropy (unsigned char *, int);
+
+#ifndef MIN
+#define MIN(a,b) (((a)<(b)) ? (a) : (b))
+#endif
+#endif
+
+static inline void *zalloc(int isize) {
+    void *pdata;
+    if( (pdata = malloc(isize)) )
+	memset(pdata, 0, isize);
+    else exit(-111);
+    return pdata;
+}
+
+extern int isock_fd;
+extern void l2tp_wait_socket();
+extern void l2tp_unblock();
+extern int l2tp_init(char *lns);
+extern void l2tp_exit();
+
+/* 
+ * This is just some stuff to take
+ * care of kernel definitions
+ */
+
+#include <net/if.h>
+#include <linux/if_ether.h>
+#include <linux/if_pppox.h>
+#include <linux/if_pppol2tp.h>
--- ppp-2.4.4.orig/pppd/plugins/pppol2tp/Makefile.linux	2011-01-24 18:56:46.000000000 +0300
+++ ppp-2.4.4/pppd/plugins/pppol2tp/Makefile.linux	2011-01-24 13:53:48.000000000 +0300
@@ -10,7 +10,7 @@
 
 LDFLAGS	= -shared
 
-CFLAGS+=-D_linux_=1 -DMPPE  -DUSE_CRYPT -D_DISABLE_SERIAL
+CFLAGS+=-D_linux_=1 -DMPPE  -DUSE_CRYPT -D_DISABLE_SERIAL -DLINUX -DSANITY
 
 CCP_SUPPORT=y
 
@@ -23,7 +23,7 @@
 PPPDVERSION = $(shell awk -F '"' '/VERSION/ { print $$2; }' ../../patchlevel.h)
 LIBDIR = $(DESTDIR)/lib/pppd/$(PPPDVERSION)
 
-PLUGINSRCS= pppol2tp.c
+PLUGINSRCS= *.c
 
 #
 # include dependancies if present and backup if as a header file
@@ -31,7 +31,7 @@
 include .depend
 endif
 
-pppol2tp.so: pppol2tp.o
+pppol2tp.so: l2tp.o xl2tpd.o misc.o control.o avp.o call.o network.o avpsend.o scheduler.o file.o aaa.o md5.o
 	$(CC) -o $@ $(LDFLAGS) $^
 	cp pppol2tp.so libpppol2tp.so
 
--- ppp-2.4.4.orig/pppd/plugins/pppol2tp/md5.c	1970-01-01 03:00:00.000000000 +0300
+++ ppp-2.4.4/pppd/plugins/pppol2tp/md5.c	2011-01-24 13:53:48.000000000 +0300
@@ -0,0 +1,272 @@
+#ifdef FREEBSD
+# include <machine/endian.h>
+#elif defined(LINUX)
+# include <endian.h>
+#elif defined(SOLARIS)
+# include <sys/isa_defs.h>
+#endif
+#if __BYTE_ORDER == __BIG_ENDIAN
+#define HIGHFIRST 1
+#endif
+
+/*
+ * This code implements the MD5 message-digest algorithm.
+ * The algorithm is due to Ron Rivest.  This code was
+ * written by Colin Plumb in 1993, no copyright is claimed.
+ * This code is in the public domain; do with it what you wish.
+ *
+ * Equivalent code is available from RSA Data Security, Inc.
+ * This code has been tested against that, and is equivalent,
+ * except that you don't need to include two pages of legalese
+ * with every copy.
+ *
+ * To compute the message digest of a chunk of bytes, declare an
+ * MD5Context structure, pass it to MD5Init, call MD5Update as
+ * needed on buffers full of bytes, and then call MD5Final, which
+ * will fill a supplied 16-byte array with the digest.
+ */
+#include <string.h>             /* for memcpy() */
+#include "md5.h"
+
+#ifndef HIGHFIRST
+#define byteReverse(buf, len)   /* Nothing */
+#else
+void byteReverse (unsigned char *buf, unsigned longs);
+
+#ifndef ASM_MD5
+/*
+ * Note: this code is harmless on little-endian machines.
+ */
+void byteReverse (unsigned char *buf, unsigned longs)
+{
+    uint32 t;
+    do
+    {
+        t = (uint32) ((unsigned) buf[3] << 8 | buf[2]) << 16 |
+            ((unsigned) buf[1] << 8 | buf[0]);
+        *(uint32 *) buf = t;
+        buf += 4;
+    }
+    while (--longs);
+}
+#endif
+#endif
+
+/*
+ * Start MD5 accumulation.  Set bit count to 0 and buffer to mysterious
+ * initialization constants.
+ */
+void MD5Init (struct MD5Context *ctx)
+{
+    ctx->buf[0] = 0x67452301;
+    ctx->buf[1] = 0xefcdab89;
+    ctx->buf[2] = 0x98badcfe;
+    ctx->buf[3] = 0x10325476;
+
+    ctx->bits[0] = 0;
+    ctx->bits[1] = 0;
+}
+
+/*
+ * Update context to reflect the concatenation of another buffer full
+ * of bytes.
+ */
+void MD5Update (struct MD5Context *ctx, unsigned char const *buf,
+                unsigned len)
+{
+    uint32 t;
+
+    /* Update bitcount */
+
+    t = ctx->bits[0];
+    if ((ctx->bits[0] = t + ((uint32) len << 3)) < t)
+        ctx->bits[1]++;         /* Carry from low to high */
+    ctx->bits[1] += len >> 29;
+
+    t = (t >> 3) & 0x3f;        /* Bytes already in shsInfo->data */
+
+    /* Handle any leading odd-sized chunks */
+
+    if (t)
+    {
+        unsigned char *p = (unsigned char *) ctx->in + t;
+
+        t = 64 - t;
+        if (len < t)
+        {
+            memcpy (p, buf, len);
+            return;
+        }
+        memcpy (p, buf, t);
+        byteReverse (ctx->in, 16);
+        MD5Transform (ctx->buf, (uint32 *) ctx->in);
+        buf += t;
+        len -= t;
+    }
+    /* Process data in 64-byte chunks */
+
+    while (len >= 64)
+    {
+        memcpy (ctx->in, buf, 64);
+        byteReverse (ctx->in, 16);
+        MD5Transform (ctx->buf, (uint32 *) ctx->in);
+        buf += 64;
+        len -= 64;
+    }
+
+    /* Handle any remaining bytes of data. */
+
+    memcpy (ctx->in, buf, len);
+}
+
+/*
+ * Final wrapup - pad to 64-byte boundary with the bit pattern 
+ * 1 0* (64-bit count of bits processed, MSB-first)
+ */
+void MD5Final (unsigned char digest[16], struct MD5Context *ctx)
+{
+    unsigned count;
+    unsigned char *p;
+
+    /* Compute number of bytes mod 64 */
+    count = (ctx->bits[0] >> 3) & 0x3F;
+
+    /* Set the first char of padding to 0x80.  This is safe since there is
+       always at least one byte free */
+    p = ctx->in + count;
+    *p++ = 0x80;
+
+    /* Bytes of padding needed to make 64 bytes */
+    count = 64 - 1 - count;
+
+    /* Pad out to 56 mod 64 */
+    if (count < 8)
+    {
+        /* Two lots of padding:  Pad the first block to 64 bytes */
+        memset (p, 0, count);
+        byteReverse (ctx->in, 16);
+        MD5Transform (ctx->buf, (uint32 *) ctx->in);
+
+        /* Now fill the next block with 56 bytes */
+        memset (ctx->in, 0, 56);
+    }
+    else
+    {
+        /* Pad block to 56 bytes */
+        memset (p, 0, count - 8);
+    }
+    byteReverse (ctx->in, 14);
+
+    /* Append length in bits and transform */
+    ((uint32 *) ctx->in)[14] = ctx->bits[0];
+    ((uint32 *) ctx->in)[15] = ctx->bits[1];
+
+    MD5Transform (ctx->buf, (uint32 *) ctx->in);
+    byteReverse ((unsigned char *) ctx->buf, 4);
+    memcpy (digest, ctx->buf, 16);
+    memset (ctx, 0, sizeof (ctx));      /* In case it's sensitive */
+}
+
+#ifndef ASM_MD5
+
+/* The four core functions - F1 is optimized somewhat */
+
+/* #define F1(x, y, z) (x & y | ~x & z) */
+#define F1(x, y, z) (z ^ (x & (y ^ z)))
+#define F2(x, y, z) F1(z, x, y)
+#define F3(x, y, z) (x ^ y ^ z)
+#define F4(x, y, z) (y ^ (x | ~z))
+
+/* This is the central step in the MD5 algorithm. */
+#define MD5STEP(f, w, x, y, z, data, s) \
+	( w += f(x, y, z) + data,  w = w<<s | w>>(32-s),  w += x )
+
+/*
+ * The core of the MD5 algorithm, this alters an existing MD5 hash to
+ * reflect the addition of 16 longwords of new data.  MD5Update blocks
+ * the data and converts bytes into longwords for this routine.
+ */
+void MD5Transform (uint32 buf[4], uint32 const in[16])
+{
+    register uint32 a, b, c, d;
+
+    a = buf[0];
+    b = buf[1];
+    c = buf[2];
+    d = buf[3];
+
+    MD5STEP (F1, a, b, c, d, in[0] + 0xd76aa478, 7);
+    MD5STEP (F1, d, a, b, c, in[1] + 0xe8c7b756, 12);
+    MD5STEP (F1, c, d, a, b, in[2] + 0x242070db, 17);
+    MD5STEP (F1, b, c, d, a, in[3] + 0xc1bdceee, 22);
+    MD5STEP (F1, a, b, c, d, in[4] + 0xf57c0faf, 7);
+    MD5STEP (F1, d, a, b, c, in[5] + 0x4787c62a, 12);
+    MD5STEP (F1, c, d, a, b, in[6] + 0xa8304613, 17);
+    MD5STEP (F1, b, c, d, a, in[7] + 0xfd469501, 22);
+    MD5STEP (F1, a, b, c, d, in[8] + 0x698098d8, 7);
+    MD5STEP (F1, d, a, b, c, in[9] + 0x8b44f7af, 12);
+    MD5STEP (F1, c, d, a, b, in[10] + 0xffff5bb1, 17);
+    MD5STEP (F1, b, c, d, a, in[11] + 0x895cd7be, 22);
+    MD5STEP (F1, a, b, c, d, in[12] + 0x6b901122, 7);
+    MD5STEP (F1, d, a, b, c, in[13] + 0xfd987193, 12);
+    MD5STEP (F1, c, d, a, b, in[14] + 0xa679438e, 17);
+    MD5STEP (F1, b, c, d, a, in[15] + 0x49b40821, 22);
+
+    MD5STEP (F2, a, b, c, d, in[1] + 0xf61e2562, 5);
+    MD5STEP (F2, d, a, b, c, in[6] + 0xc040b340, 9);
+    MD5STEP (F2, c, d, a, b, in[11] + 0x265e5a51, 14);
+    MD5STEP (F2, b, c, d, a, in[0] + 0xe9b6c7aa, 20);
+    MD5STEP (F2, a, b, c, d, in[5] + 0xd62f105d, 5);
+    MD5STEP (F2, d, a, b, c, in[10] + 0x02441453, 9);
+    MD5STEP (F2, c, d, a, b, in[15] + 0xd8a1e681, 14);
+    MD5STEP (F2, b, c, d, a, in[4] + 0xe7d3fbc8, 20);
+    MD5STEP (F2, a, b, c, d, in[9] + 0x21e1cde6, 5);
+    MD5STEP (F2, d, a, b, c, in[14] + 0xc33707d6, 9);
+    MD5STEP (F2, c, d, a, b, in[3] + 0xf4d50d87, 14);
+    MD5STEP (F2, b, c, d, a, in[8] + 0x455a14ed, 20);
+    MD5STEP (F2, a, b, c, d, in[13] + 0xa9e3e905, 5);
+    MD5STEP (F2, d, a, b, c, in[2] + 0xfcefa3f8, 9);
+    MD5STEP (F2, c, d, a, b, in[7] + 0x676f02d9, 14);
+    MD5STEP (F2, b, c, d, a, in[12] + 0x8d2a4c8a, 20);
+
+    MD5STEP (F3, a, b, c, d, in[5] + 0xfffa3942, 4);
+    MD5STEP (F3, d, a, b, c, in[8] + 0x8771f681, 11);
+    MD5STEP (F3, c, d, a, b, in[11] + 0x6d9d6122, 16);
+    MD5STEP (F3, b, c, d, a, in[14] + 0xfde5380c, 23);
+    MD5STEP (F3, a, b, c, d, in[1] + 0xa4beea44, 4);
+    MD5STEP (F3, d, a, b, c, in[4] + 0x4bdecfa9, 11);
+    MD5STEP (F3, c, d, a, b, in[7] + 0xf6bb4b60, 16);
+    MD5STEP (F3, b, c, d, a, in[10] + 0xbebfbc70, 23);
+    MD5STEP (F3, a, b, c, d, in[13] + 0x289b7ec6, 4);
+    MD5STEP (F3, d, a, b, c, in[0] + 0xeaa127fa, 11);
+    MD5STEP (F3, c, d, a, b, in[3] + 0xd4ef3085, 16);
+    MD5STEP (F3, b, c, d, a, in[6] + 0x04881d05, 23);
+    MD5STEP (F3, a, b, c, d, in[9] + 0xd9d4d039, 4);
+    MD5STEP (F3, d, a, b, c, in[12] + 0xe6db99e5, 11);
+    MD5STEP (F3, c, d, a, b, in[15] + 0x1fa27cf8, 16);
+    MD5STEP (F3, b, c, d, a, in[2] + 0xc4ac5665, 23);
+
+    MD5STEP (F4, a, b, c, d, in[0] + 0xf4292244, 6);
+    MD5STEP (F4, d, a, b, c, in[7] + 0x432aff97, 10);
+    MD5STEP (F4, c, d, a, b, in[14] + 0xab9423a7, 15);
+    MD5STEP (F4, b, c, d, a, in[5] + 0xfc93a039, 21);
+    MD5STEP (F4, a, b, c, d, in[12] + 0x655b59c3, 6);
+    MD5STEP (F4, d, a, b, c, in[3] + 0x8f0ccc92, 10);
+    MD5STEP (F4, c, d, a, b, in[10] + 0xffeff47d, 15);
+    MD5STEP (F4, b, c, d, a, in[1] + 0x85845dd1, 21);
+    MD5STEP (F4, a, b, c, d, in[8] + 0x6fa87e4f, 6);
+    MD5STEP (F4, d, a, b, c, in[15] + 0xfe2ce6e0, 10);
+    MD5STEP (F4, c, d, a, b, in[6] + 0xa3014314, 15);
+    MD5STEP (F4, b, c, d, a, in[13] + 0x4e0811a1, 21);
+    MD5STEP (F4, a, b, c, d, in[4] + 0xf7537e82, 6);
+    MD5STEP (F4, d, a, b, c, in[11] + 0xbd3af235, 10);
+    MD5STEP (F4, c, d, a, b, in[2] + 0x2ad7d2bb, 15);
+    MD5STEP (F4, b, c, d, a, in[9] + 0xeb86d391, 21);
+
+    buf[0] += a;
+    buf[1] += b;
+    buf[2] += c;
+    buf[3] += d;
+}
+
+#endif
--- ppp-2.4.4.orig/pppd/plugins/pppol2tp/md5.h	1970-01-01 03:00:00.000000000 +0300
+++ ppp-2.4.4/pppd/plugins/pppol2tp/md5.h	2011-01-24 13:53:48.000000000 +0300
@@ -0,0 +1,28 @@
+#ifndef MD5_H
+#define MD5_H
+
+#ifdef __alpha
+typedef unsigned int uint32;
+#else
+typedef unsigned long uint32;
+#endif
+
+struct MD5Context
+{
+    uint32 buf[4];
+    uint32 bits[2];
+    unsigned char in[64];
+};
+
+void MD5Init (struct MD5Context *context);
+void MD5Update (struct MD5Context *context, unsigned char const *buf,
+                unsigned len);
+void MD5Final (unsigned char digest[16], struct MD5Context *context);
+void MD5Transform (uint32 buf[4], uint32 const in[16]);
+
+/*
+ * This is needed to make RSAREF happy on some MS-DOS compilers.
+ */
+typedef struct MD5Context MD5_CTX;
+
+#endif /* !MD5_H */
--- ppp-2.4.4.orig/pppd/plugins/pppol2tp/misc.c	1970-01-01 03:00:00.000000000 +0300
+++ ppp-2.4.4/pppd/plugins/pppol2tp/misc.c	2011-01-24 13:53:48.000000000 +0300
@@ -0,0 +1,274 @@
+/*
+ * Layer Two Tunnelling Protocol Daemon
+ * Copyright (C) 1998 Adtran, Inc.
+ * Copyright (C) 2002 Jeff McAdams
+ *
+ * Mark Spencer
+ *
+ * This software is distributed under the terms
+ * of the GPL, which you should have received
+ * along with this source.
+ *
+ * Miscellaneous but important functions
+ *
+ */
+
+#include <unistd.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <stdarg.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <string.h>
+#include <syslog.h>
+#if defined(SOLARIS)
+# include <varargs.h>
+#endif
+#include <netinet/in.h>
+#include "l2tp.h"
+
+void init_log()
+{
+    static int logopen=0;
+    
+    if(!logopen) {
+	openlog (BINARY, LOG_PID, LOG_DAEMON);
+    }
+}
+
+void l2tp_log (int level, const char *fmt, ...)
+{
+    char buf[256];
+    va_list args;
+    va_start (args, fmt);
+    vsnprintf (buf, sizeof (buf), fmt, args);
+    va_end (args);
+    
+    init_log();
+    syslog (level, "%s", buf);
+    /* printf(buf); */
+}
+
+void set_error (struct call *c, int error, const char *fmt, ...)
+{
+    va_list args;
+    va_start (args, fmt);
+    c->error = error;
+    c->result = RESULT_ERROR;
+    c->needclose = -1;
+    vsnprintf (c->errormsg, sizeof (c->errormsg), fmt, args);
+    if (c->errormsg[strlen (c->errormsg) - 1] == '\n')
+        c->errormsg[strlen (c->errormsg) - 1] = 0;
+    va_end (args);
+}
+
+struct buffer *new_buf (int size)
+{
+    struct buffer *b = zalloc (sizeof (struct buffer));
+
+    if (!b || !size || size < 0)
+        return NULL;
+    b->rstart = zalloc (size);
+    if (!b->rstart)
+    {
+        free (b);
+        return NULL;
+    }
+    b->start = b->rstart;
+    b->rend = b->rstart + size - 1;
+    b->len = size;
+    b->maxlen = size;
+    return b;
+}
+
+inline void recycle_buf (struct buffer *b)
+{
+    b->start = b->rstart;
+    b->len = b->maxlen;
+}
+
+#define bufferDumpWIDTH 16
+void bufferDump (unsigned char *buf, int buflen)
+{
+    int i = 0, j = 0;
+    /* we need TWO characters to DISPLAY ONE byte */
+    char line[2 * bufferDumpWIDTH + 1], *c;
+
+    for (i = 0; i < buflen / bufferDumpWIDTH; i++)
+    {
+        c = line;
+        for (j = 0; j < bufferDumpWIDTH; j++)
+        {
+	  sprintf (c, "%02x ", (buf[i * bufferDumpWIDTH + j]) & 0xff);
+            c++;
+            c++;                /* again two characters to display ONE byte */
+        }
+        *c = '\0';
+        l2tp_log (LOG_WARNING,
+		  "%s: buflen=%d, buffer[%d]: *%s*\n", __FUNCTION__,
+		  buflen, i, line);
+    }
+
+    c = line;
+    for (j = 0; j < buflen % bufferDumpWIDTH; j++)
+    {
+        sprintf (c, "%02x ",
+                 buf[(buflen / bufferDumpWIDTH) * bufferDumpWIDTH +
+                     j] & 0xff);
+        c++;
+        c++;
+    }
+    if (c != line)
+    {
+        *c = '\0';
+        l2tp_log (LOG_WARNING,
+		  "%s:             buffer[%d]: *%s*\n", __FUNCTION__, i,
+		  line);
+    }
+}
+
+void do_packet_dump (struct buffer *buf)
+{
+    int x;
+    unsigned char *c = buf->start;
+    printf ("packet dump: \nHEX: { ");
+    for (x = 0; x < buf->len; x++)
+    {
+        printf ("%.2X ", *c);
+        c++;
+    };
+    printf ("}\nASCII: { ");
+    c = buf->start;
+    for (x = 0; x < buf->len; x++)
+    {
+        if (*c > 31 && *c < 127)
+        {
+            putchar (*c);
+        }
+        else
+        {
+            putchar (' ');
+        }
+        c++;
+    }
+    printf ("}\n");
+}
+
+inline void swaps (void *buf_v, int len)
+{
+#ifdef __alpha
+    /* Reverse byte order alpha is little endian so lest save a step.
+       to make things work out easier */
+    int x;
+    unsigned char t1;
+    unsigned char *tmp = (_u16 *) buf_v;
+    for (x = 0; x < len; x += 2)
+    {
+        t1 = tmp[x];
+        tmp[x] = tmp[x + 1];
+        tmp[x + 1] = t1;
+    }
+#else
+
+    /* Reverse byte order (if proper to do so) 
+       to make things work out easier */
+    int x;
+	struct hw { _u16 s; } __attribute__ ((packed)) *p = (struct hw *) buf_v;
+	for (x = 0; x < len / 2; x++, p++)
+		p->s = ntohs(p->s); 
+#endif
+}
+
+
+
+inline void toss (struct buffer *buf)
+{
+    /*
+     * Toss a frame and free up the buffer that contained it
+     */
+
+    free (buf->rstart);
+    free (buf);
+}
+
+inline void safe_copy (char *a, char *b, int size)
+{
+    /* Copies B into A (assuming A holds MAXSTRLEN bytes)
+       safely */
+    strncpy (a, b, MIN (size, MAXSTRLEN - 1));
+    a[MIN (size, MAXSTRLEN - 1)] = '\000';
+}
+
+int get_egd_entropy(char *buf, int count)
+{
+    return -1;
+}
+
+int get_sys_entropy(unsigned char *buf, int count)
+{
+    /*
+     * This way of filling buf with rand() generated data is really
+     * fairly inefficient from a function call point of view...rand()
+     * returns four bytes of data (on most systems, sizeof(int))
+     * and we end up only using 1 byte of it (sizeof(char))...ah
+     * well...it was a *whole* lot easier to code this way...suggestions
+     * for improvements are, of course, welcome
+     */
+    int counter;
+    for (counter = 0; counter < count; counter++)
+    {
+        buf[counter] = (char)rand();
+    }
+#ifdef DEBUG_ENTROPY
+    bufferDump (buf, count);
+#endif
+    return count;
+}
+
+int get_dev_entropy(unsigned char *buf, int count)
+{
+    int devrandom;
+    ssize_t entropy_amount;
+
+    devrandom = open ("/dev/urandom", O_RDONLY | O_NONBLOCK);
+    if (devrandom == -1)
+    {
+#ifdef DEBUG_ENTROPY
+        l2tp_log(LOG_WARNING, "%s: couldn't open /dev/urandom,"
+                      "falling back to rand()\n",
+                      __FUNCTION__);
+#endif
+        return get_sys_entropy(buf, count);
+    }
+    entropy_amount = read(devrandom, buf, count);
+    close(devrandom);
+    return entropy_amount;
+}
+
+int get_entropy (unsigned char *buf, int count)
+{
+    if (rand_source == RAND_SYS)
+    {
+        return get_sys_entropy(buf, count);
+    }
+    else if (rand_source == RAND_DEV)
+    {
+        return get_dev_entropy(buf, count);
+    }
+    else if (rand_source == RAND_EGD)
+    {
+        l2tp_log(LOG_WARNING,
+		 "%s: EGD Randomness source not yet implemented\n",
+                __FUNCTION__);
+        return -1;
+    }
+    else
+    {
+	    l2tp_log(LOG_WARNING,
+		     "%s: Invalid Randomness source specified (%d)\n",
+		     __FUNCTION__, rand_source);
+	    return -1;
+    }
+}
--- ppp-2.4.4.orig/pppd/plugins/pppol2tp/misc.h	1970-01-01 03:00:00.000000000 +0300
+++ ppp-2.4.4/pppd/plugins/pppol2tp/misc.h	2011-01-24 13:53:48.000000000 +0300
@@ -0,0 +1,68 @@
+/*
+ * Layer Two Tunnelling Protocol Daemon
+ * Copyright (C) 1998 Adtran, Inc.
+ * Copyright (C) 2002 Jeff McAdams
+ *
+ * Mark Spencer
+ *
+ * This software is distributed under the terms
+ * of the GPL, which you should have received
+ * along with this source.
+ *
+ * Misc stuff...
+ */
+
+#ifndef _MISC_H
+#define _MISC_H
+
+#include <syslog.h>
+
+struct tunnel;
+struct buffer
+{
+    int type;
+    void *rstart;
+    void *rend;
+    void *start;
+    int len;
+    int maxlen;
+#if 0
+    unsigned int addr;
+    int port;
+#else
+    struct sockaddr_in peer;
+#endif
+    struct tunnel *tunnel;      /* Who owns this packet, if it's a control */
+    int retries;                /* Again, if a control packet, how many retries? */
+};
+
+#define IPADDY(a) inet_ntoa(*((struct in_addr *)&(a)))
+
+//#define DEBUG c ? c->debug || t->debug : t->debug
+#define DEBUG 0
+
+#ifdef USE_SWAPS_INSTEAD
+#define SWAPS(a) ((((a) & 0xFF) << 8 ) | (((a) >> 8) & 0xFF))
+#ifdef htons
+#undef htons
+#endif
+#ifdef ntohs
+#undef htons
+#endif
+#define htons(a) SWAPS(a)
+#define ntohs(a) SWAPS(a)
+#endif
+
+#define halt() printf("Halted.\n") ; for(;;)
+
+extern char hostname[];
+extern void l2tp_log (int level, const char *fmt, ...);
+extern struct buffer *new_buf (int);
+extern void udppush_handler (int);
+extern int addfcs (struct buffer *buf);
+extern inline void swaps (void *, int);
+extern void do_packet_dump (struct buffer *);
+extern int getPtyMaster(char *, int);
+extern void recycle_buf (struct buffer *);
+extern void safe_copy (char *, char *, int);
+#endif
--- ppp-2.4.4.orig/pppd/plugins/pppol2tp/network.c	1970-01-01 03:00:00.000000000 +0300
+++ ppp-2.4.4/pppd/plugins/pppol2tp/network.c	2011-01-24 18:55:35.000000000 +0300
@@ -0,0 +1,603 @@
+/*
+ * Layer Two Tunnelling Protocol Daemon
+ * Copyright (C) 1998 Adtran, Inc.
+ * Copyright (C) 2002 Jeff McAdams
+ *
+ * Mark Spencer
+ *
+ * This software is distributed under the terms
+ * of the GPL, which you should have received
+ * along with this source.
+ *
+ * Network routines for UDP handling
+ */
+#include <stdio.h>
+#include <errno.h>
+#include <string.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <netdb.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <sys/ioctl.h>
+#include "l2tp.h"
+#include "ipsecmast.h"
+#include <signal.h>
+
+char hostname[256];
+struct sockaddr_in server, from;        /* Server and transmitter structs */
+int server_socket = -1;              /* Server socket */
+
+int init_network (void)
+{
+    long arg;
+    unsigned int length = sizeof (server);
+    gethostname (hostname, sizeof (hostname));
+    server.sin_family = AF_INET;
+    server.sin_addr.s_addr = gconfig.listenaddr; 
+    server.sin_port = htons (gconfig.port);
+    if ((server_socket = socket (PF_INET, SOCK_DGRAM, 0)) < 0)
+    {
+        l2tp_log (LOG_CRIT, "%s: Unable to allocate socket. Terminating.\n",
+             __FUNCTION__);
+        return -EINVAL;
+    };
+
+    
+    if (bind (server_socket, (struct sockaddr *) &server, sizeof (server)))
+    {
+        close (server_socket);
+        server_socket = -1;
+        l2tp_log (LOG_CRIT, "%s: Unable to bind socket: %s. Terminating.\n",
+             __FUNCTION__, strerror(errno), errno);
+        return -EINVAL;
+    };
+    
+    if (getsockname (server_socket, (struct sockaddr *) &server, &length))
+    {
+        l2tp_log (LOG_CRIT, "%s: Unable to read socket name.Terminating.\n",
+             __FUNCTION__);
+	close(server_socket);
+	server_socket = -1;
+        return -EINVAL;
+    }
+    /*
+     * For L2TP/IPsec with KLIPSng, set the socket to receive IPsec REFINFO
+     * values.
+     */
+    arg=1;
+    if(setsockopt(server_socket, SOL_IP, IP_IPSEC_REFINFO,
+		  &arg, sizeof(arg)) != 0) {
+	    l2tp_log(LOG_CRIT, "setsockopt recvref: %s\n", strerror(errno));
+
+	    gconfig.ipsecsaref=0;
+    }
+    
+    arg = fcntl (server_socket, F_GETFL);
+    arg |= O_NONBLOCK;
+    fcntl (server_socket, F_SETFL, arg);
+    gconfig.port = ntohs (server.sin_port);
+    return 0;
+}
+
+void close_network() {
+    if( server_socket != -1 ) {    
+	close(server_socket);
+	server_socket = -1;
+    }
+}
+
+inline void extract (void *buf, int *tunnel, int *call)
+{
+    /*
+     * Extract the tunnel and call #'s, and fix the order of the 
+     * version
+     */
+
+    struct payload_hdr *p = (struct payload_hdr *) buf;
+    if (PLBIT (p->ver))
+    {
+        *tunnel = p->tid;
+        *call = p->cid;
+    }
+    else
+    {
+        *tunnel = p->length;
+        *call = p->tid;
+    }
+}
+
+inline void fix_hdr (void *buf)
+{
+    /*
+     * Fix the byte order of the header
+     */
+
+    struct payload_hdr *p = (struct payload_hdr *) buf;
+    _u16 ver = ntohs (p->ver);
+    if (CTBIT (p->ver))
+    {
+        /*
+         * Control headers are always
+         * exactly 12 bytes big.
+         */
+        swaps (buf, 12);
+    }
+    else
+    {
+        int len = 6;
+        if (PSBIT (ver))
+            len += 4;
+        if (PLBIT (ver))
+            len += 2;
+        if (PFBIT (ver))
+            len += 4;
+        swaps (buf, len);
+    }
+}
+
+void dethrottle (void *call)
+{
+/*	struct call *c = (struct call *)call; */
+/*	if (c->throttle) {
+#ifdef DEBUG_FLOW
+		log(LOG_DEBUG, "%s: dethrottling call %d, and setting R-bit\n",__FUNCTION__,c->ourcid); 
+#endif 		c->rbit = RBIT;
+		c->throttle = 0;
+	} else {
+		log(LOG_DEBUG, "%s:  call %d already dethrottled?\n",__FUNCTION__,c->ourcid); 	
+	} */
+}
+
+void control_xmit (void *b)
+{
+    struct buffer *buf = (struct buffer *) b;
+    struct tunnel *t;
+    struct timeval tv;
+    int ns;
+
+    if (!buf)
+    {
+        l2tp_log (LOG_WARNING, "%s: called on NULL buffer!\n", __FUNCTION__);
+        return;
+    }
+
+    t = buf->tunnel;
+#ifdef DEBUG_CONTROL_XMIT
+    if(t) {
+	    l2tp_log (LOG_NOTICE,
+		      "trying to send control packet to %d / %d\n",
+		      t->ourtid, buf->retries);
+    }
+#endif
+
+    buf->retries++;
+    ns = ntohs (((struct control_hdr *) (buf->start))->Ns);
+    if (t)
+    {
+        if (ns < t->cLr)
+        {
+#ifdef DEBUG_CONTROL_XMIT
+            l2tp_log (LOG_NOTICE, "%s: Tossing packet %d\n", __FUNCTION__, ns);
+#endif
+            /* Okay, it's been received.  Let's toss it now */
+            toss (buf);
+            return;
+        }
+    }
+    if (buf->retries > DEFAULT_MAX_RETRIES)
+    {
+        /*
+           * Too many retries.  Either kill the tunnel, or
+           * if there is no tunnel, just stop retransmitting.
+         */
+        if (t)
+        {
+            if (t->self->needclose)
+            {
+                l2tp_log (LOG_DEBUG,
+                     "Unable to deliver closing message for tunnel %d. Destroying anyway.\n",
+                     t->ourtid);
+                t->self->needclose = 0;
+                t->self->closing = -1;
+            }
+            else
+            {
+                l2tp_log (LOG_NOTICE,
+                     "Maximum retries exceeded for tunnel %d.  Closing.\n",
+                     t->ourtid);
+                strcpy (t->self->errormsg, "Timeout");
+                t->self->needclose = -1;
+            }
+        }
+	free(buf->rstart);
+	free(buf);
+	    
+	stop_pppd(3);
+    } 
+    else
+    {
+        /*
+           * FIXME:  How about adaptive timeouts?
+         */
+        tv.tv_sec = 1;
+        tv.tv_usec = 0;
+        schedule (tv, control_xmit, buf);
+#ifdef DEBUG_CONTROL_XMIT
+        l2tp_log (LOG_DEBUG, "%s: Scheduling and transmitting packet %d\n",
+             __FUNCTION__, ns);
+#endif
+        udp_xmit (buf, t);
+    }
+}
+
+void udp_xmit (struct buffer *buf, struct tunnel *t)
+{
+    struct cmsghdr *cmsg;
+    char cbuf[CMSG_SPACE(sizeof (unsigned int))];
+    unsigned int *refp;
+    struct msghdr msgh;
+    int err;
+    struct iovec iov;
+    
+    if( !t ) return;
+    
+    /*
+     * OKAY, now send a packet with the right SAref values.
+     */
+    memset(&msgh, 0, sizeof(struct msghdr));
+    
+    msgh.msg_control = cbuf;
+    msgh.msg_controllen = 0;
+
+    if(gconfig.ipsecsaref && t->refhim != IPSEC_SAREF_NULL) {
+	msgh.msg_controllen = sizeof(cbuf);
+
+	cmsg = CMSG_FIRSTHDR(&msgh);
+	cmsg->cmsg_level = SOL_IP;
+	cmsg->cmsg_type  = IP_IPSEC_REFINFO;
+	cmsg->cmsg_len   = CMSG_LEN(sizeof(unsigned int));
+
+	if(gconfig.debug_network) {
+		l2tp_log(LOG_DEBUG,"sending with saref=%d\n", t->refhim);
+	}
+	refp = (unsigned int *)CMSG_DATA(cmsg);
+	*refp = t->refhim;
+
+	msgh.msg_controllen = cmsg->cmsg_len;
+    }
+    
+    iov.iov_base = buf->start;
+    iov.iov_len  = buf->len;
+
+    /* return packet from whence it came */
+    msgh.msg_name    = &buf->peer;
+    msgh.msg_namelen = sizeof(buf->peer);
+    
+    msgh.msg_iov  = &iov;
+    msgh.msg_iovlen = 1;
+    msgh.msg_flags = 0;
+    
+    /* Receive one packet. */
+    if ((err = sendmsg(server_socket, &msgh, 0)) < 0) {
+	l2tp_log(LOG_ERR, "udp_xmit failed with err=%d:%s\n",
+		 err,strerror(errno));
+    }
+}
+
+int build_fdset (fd_set *readfds)
+{
+	struct tunnel *tun;
+	struct call *call;
+	int max = 0;
+
+	tun = tunnels.head;
+	FD_ZERO (readfds);
+
+	while (tun)
+	{
+		call = tun->call_head;
+		while (call)
+		{
+			if (call->needclose ^ call->closing)
+			{
+				call_close (call);
+				call = tun->call_head;
+				if (!call)
+					break;
+				continue;
+			}
+			if (call->fd > -1)
+			{
+				if (!call->needclose && !call->closing)
+				{
+					if (call->fd > max)
+						max = call->fd;
+					FD_SET (call->fd, readfds);
+				}
+			}
+			call = call->next;
+		}
+		/* Now that call fds have been collected, and checked for
+		 * closing, check if the tunnel needs to be closed too
+		 */
+		if (tun->self->needclose ^ tun->self->closing)
+		{
+			if (gconfig.debug_tunnel)
+				l2tp_log (LOG_DEBUG, "%s: closing down tunnel %d\n",
+						__FUNCTION__, tun->ourtid);
+			call_close (tun->self);
+			/* Reset the while loop
+			 * and check for NULL */
+			tun = tunnels.head;
+			if (!tun)
+				break;
+			continue;
+		}
+		tun = tun->next;
+	}
+	FD_SET (server_socket, readfds);
+	if (server_socket > max)
+		max = server_socket;
+	return max;
+}
+
+void *network_thread (void *pref)
+{
+    /*
+     * We loop forever waiting on either data from the ppp drivers or from
+     * our network socket.  Control handling is no longer done here.
+     */
+    struct sockaddr_in from, to;
+    unsigned int fromlen, tolen;
+    int tunnel, call;           /* Tunnel and call */
+    int recvsize;               /* Length of data received */
+    struct buffer *buf;         /* Payload buffer */
+    struct call *c, *sc;        /* Call to send this off to */
+    struct tunnel *st;          /* Tunnel */
+    fd_set readfds;             /* Descriptors to watch for reading */
+    int max;                    /* Highest fd */
+    struct timeval tv, *ptv;    /* Timeout for select */
+    struct msghdr msgh;
+    struct iovec iov;
+    char cbuf[256];
+    unsigned int refme, refhim;
+    sigset_t sig_ignore;
+
+	 sigemptyset(&sig_ignore);
+	 sigaddset(&sig_ignore, SIGINT);
+	 sigaddset(&sig_ignore, SIGTERM);
+	 sigaddset(&sig_ignore, SIGHUP);
+	 
+	 pthread_sigmask(SIG_BLOCK, &sig_ignore, NULL);
+    
+    /* This one buffer can be recycled for everything except control packets */
+    buf = new_buf (MAX_RECV_SIZE);
+
+    tunnel = 0;
+    call = 0;
+
+    while( !iexit )
+    {
+        int ret;
+        max = build_fdset (&readfds);
+        ptv = process_schedule(&tv);
+        ret = select (max + 1, &readfds, NULL, NULL, ptv);
+        if (ret <= 0) {
+            continue;
+        }
+	
+	if (FD_ISSET (server_socket, &readfds)) {
+		if( !ioctl(server_socket, FIONREAD, &recvsize) && !recvsize ) break;
+            /*
+             * Okay, now we're ready for reading and processing new data.
+             */
+            recycle_buf (buf);
+
+            /* Reserve space for expanding payload packet headers */
+            buf->start += PAYLOAD_BUF;
+            buf->len -= PAYLOAD_BUF;
+
+	    memset(&from, 0, sizeof(from));
+	    memset(&to,   0, sizeof(to));
+	    
+	    fromlen = sizeof(from);
+	    tolen   = sizeof(to);
+	    
+	    memset(&msgh, 0, sizeof(struct msghdr));
+	    iov.iov_base = buf->start;
+	    iov.iov_len  = buf->len;
+	    msgh.msg_control = cbuf;
+	    msgh.msg_controllen = sizeof(cbuf);
+	    msgh.msg_name = &from;
+	    msgh.msg_namelen = fromlen;
+	    msgh.msg_iov  = &iov;
+	    msgh.msg_iovlen = 1;
+	    msgh.msg_flags = 0;
+	    
+	    /* Receive one packet. */
+	    recvsize = recvmsg(server_socket, &msgh, 0);
+	    
+            if (recvsize < MIN_PAYLOAD_HDR_LEN)
+            {
+                if (recvsize < 0)
+                {
+                    if (errno != EAGAIN)
+                        l2tp_log (LOG_WARNING,
+                             "%s: recvfrom returned error %d (%s)\n",
+                             __FUNCTION__, errno, strerror (errno));
+                }
+                else
+                {
+                    l2tp_log (LOG_WARNING, "%s: received too small a packet\n",
+                         __FUNCTION__);
+                }
+		continue;
+            }
+
+
+	    refme=refhim=0;
+
+	    /* extract IPsec info out */
+	    if(gconfig.ipsecsaref) {
+		    struct cmsghdr *cmsg;
+		    /* Process auxiliary received data in msgh */
+		    for (cmsg = CMSG_FIRSTHDR(&msgh);
+			 cmsg != NULL;
+			 cmsg = CMSG_NXTHDR(&msgh,cmsg)) {
+			    if (cmsg->cmsg_level == IPPROTO_IP
+				&& cmsg->cmsg_type == IP_IPSEC_REFINFO) {
+				    unsigned int *refp;
+				    
+				    refp = (unsigned int *)CMSG_DATA(cmsg);
+				    refme =refp[0];
+				    refhim=refp[1];
+			    }
+		    }
+	    }
+
+	    /*
+	     * some logic could be added here to verify that we only
+	     * get L2TP packets inside of IPsec, or to provide different
+	     * classes of service to packets not inside of IPsec.
+	     */
+	    buf->len = recvsize;
+	    fix_hdr (buf->start);
+	    extract (buf->start, &tunnel, &call);
+
+	    if (gconfig.debug_network)
+	    {
+		l2tp_log(LOG_DEBUG, "%s: recv packet from %s, size = %d, "
+			 "tunnel = %d, call = %d ref=%u refhim=%u\n",
+			 __FUNCTION__, inet_ntoa (from.sin_addr),
+			 recvsize, tunnel, call, refme, refhim);
+	    }
+
+	    if (gconfig.packet_dump)
+	    {
+		do_packet_dump (buf);
+	    }
+	    if (!
+		(c = get_call (tunnel, call, from.sin_addr.s_addr,
+			       from.sin_port, refme, refhim)))
+	    {
+		if ((c =
+		     get_tunnel (tunnel, from.sin_addr.s_addr,
+				 from.sin_port)))
+		{
+		    /*
+		     * It is theoretically possible that we could be sent
+		     * a control message (say a StopCCN) on a call that we
+		     * have already closed or some such nonsense.  To
+		     * prevent this from closing the tunnel, if we get a
+		     * call on a valid tunnel, but not with a valid CID,
+		     * we'll just send a ZLB to ack receiving the packet.
+		     */
+		    if (gconfig.debug_tunnel)
+			l2tp_log (LOG_DEBUG,
+				  "%s: no such call %d on tunnel %d.  Sending special ZLB\n",
+				  __FUNCTION__);
+		    handle_special (buf, c, call);
+
+		    /* get a new buffer */
+		    buf = new_buf (MAX_RECV_SIZE);
+		}
+		else
+		    l2tp_log (LOG_DEBUG,
+			      "%s: unable to find call or tunnel to handle packet.  call = %d, tunnel = %d Dumping.\n",
+			      __FUNCTION__, call, tunnel);
+		
+	    }
+	    else
+	    {
+		buf->peer = from;
+		/* Handle the packet */
+		c->container->chal_us.vector = NULL;
+		if (handle_packet (buf, c->container, c))
+		{
+		    if (gconfig.debug_tunnel)
+			l2tp_log (LOG_DEBUG, "%s: bad packet\n", __FUNCTION__);
+		};
+		if (c->cnu)
+		{
+		    /* Send Zero Byte Packet */
+		    control_zlb (buf, c->container, c);
+		    c->cnu = 0;
+		}
+	    };
+	}
+
+	/*
+	 * finished obvious sources, look for data from PPP connections.
+	 */
+	st = tunnels.head;
+        while (st)
+        {
+            sc = st->call_head;
+            while (sc)
+            {
+					if ((sc->fd >= 0) && FD_ISSET (sc->fd, &readfds)) {
+                    /* Got some payload to send */
+                    int result;
+                    recycle_payload (buf, sc->container->peer);
+/*
+#ifdef DEBUG_FLOW_MORE
+                    l2tp_log (LOG_DEBUG, "%s: rws = %d, pSs = %d, pLr = %d\n",
+                         __FUNCTION__, sc->rws, sc->pSs, sc->pLr);
+#endif
+		    if ((sc->rws>0) && (sc->pSs > sc->pLr + sc->rws) && !sc->rbit) {
+#ifdef DEBUG_FLOW
+						log(LOG_DEBUG, "%s: throttling payload (call = %d, tunnel = %d, Lr = %d, Ss = %d, rws = %d)!\n",__FUNCTION__,
+								 sc->cid, sc->container->tid, sc->pLr, sc->pSs, sc->rws); 
+#endif
+						sc->throttle = -1;
+						We unthrottle in handle_packet if we get a payload packet, 
+						valid or ZLB, but we also schedule a dethrottle in which
+						case the R-bit will be set
+						FIXME: Rate Adaptive timeout? 						
+						tv.tv_sec = 2;
+						tv.tv_usec = 0;
+						sc->dethrottle = schedule(tv, dethrottle, sc); 					
+					} else */
+/*					while ((result=call_read_packet(buf,sc->fd,sc->frame & SYNC_FRAMING))>0) { */
+                    while (!iexit && (result =
+                            call_read_packet (buf, sc->fd, SYNC_FRAMING)) > 0)
+                    {
+                        add_payload_hdr (sc->container, sc, buf);
+                        if (gconfig.packet_dump)
+                        {
+                            do_packet_dump (buf);
+                        }
+
+                        sc->prx = sc->data_rec_seq_num;
+                        if (sc->zlb_xmit)
+                        {
+                            deschedule (sc->zlb_xmit);
+                            sc->zlb_xmit = NULL;
+                        }
+			
+                        sc->tx_bytes += buf->len;
+                        sc->tx_pkts++;
+			
+                        udp_xmit (buf, st);
+                        recycle_payload (buf, sc->container->peer);
+                    }
+                    if (result != 0)
+                    {
+                        l2tp_log (LOG_WARNING,
+                             "%s: tossing read packet, error = %s (%d).  Closing call.\n",
+                             __FUNCTION__, strerror (-result), -result);
+                        strcpy (sc->errormsg, strerror (-result));
+                        sc->needclose = -1;
+                    }
+                }
+                sc = sc->next;
+            }
+            st = st->next;
+        }
+    }
+    
+    return NULL;
+}
--- ppp-2.4.4.orig/pppd/plugins/pppol2tp/osport.h	1970-01-01 03:00:00.000000000 +0300
+++ ppp-2.4.4/pppd/plugins/pppol2tp/osport.h	2011-01-24 13:53:48.000000000 +0300
@@ -0,0 +1,38 @@
+/*
+ * Layer Two Tunnelling Protocol Daemon
+ * Copyright (C) 1998 Adtran, Inc.
+ * Copyright (C) 2002 Jeff McAdams
+ *
+ * Mark Spencer
+ *
+ * This software is distributed under the terms
+ * of the GPL, which you should have received
+ * along with this source.
+ *
+ * OS Portability header file. try to map some
+ * "standard" routines into OS-specific routines.
+ *
+ */
+
+#ifndef _OSPORT_H_
+#define _OSPORT_H_
+
+#if defined(SOLARIS)
+
+# define index(x, y)        strchr(x, y)
+# define bcopy(S1, S2, LEN) ((void)memmove(S2, S1, LEN))
+# define bzero(S1, LEN)     ((void)memset(S1,  0, LEN))
+# define bcmp(S1,S2,LEN)    ((memcmp(S2, S1, LEN)==0)?0:1)
+
+/* pre 2.6 solaris didn't include random(), etc prototypes 
+ * <stdlib.h> (as of 2.6) has the correct prototypes.
+ */
+
+# if SOLARIS < 260
+#  define random(X)          ((int)rand(X))
+#  define srandom(X)         ((void)srand(X))
+# endif /* SOLARIS < 260 */
+
+#endif /* defined(SOLARIS) */
+
+#endif /* _OSPORT_H_ */
--- ppp-2.4.4.orig/pppd/plugins/pppol2tp/pppol2tp.c	2011-01-24 18:56:46.000000000 +0300
+++ ppp-2.4.4/pppd/plugins/pppol2tp/pppol2tp.c	1970-01-01 03:00:00.000000000 +0300
@@ -1,507 +0,0 @@
-/* pppol2tp.c - pppd plugin to implement PPPoL2TP protocol
- *   for Linux using kernel pppol2tp support.
- *
- * Requires kernel pppol2tp driver which is distributed with
- * OpenL2TP at http://www.sourceforge.net/projects/openl2tp/
- *
- * By Martijn van Oosterhout <kleptog@svana.org>
- * Modified for OpenL2TP by jchapman@katalix.com
- *
- * Heavily based upon pppoatm.c: original notice follows
- *
- * Copyright 2000 Mitchell Blank Jr.
- * Based in part on work from Jens Axboe and Paul Mackerras.
- * Updated to ppp-2.4.1 by Bernhard Kaindl
- *
- *  This program is free software; you can redistribute it and/or
- *  modify it under the terms of the GNU General Public License
- *  as published by the Free Software Foundation; either version
- *  2 of the License, or (at your option) any later version.
- */
-#include <unistd.h>
-#include <string.h>
-#include <stdlib.h>
-#include <errno.h>
-#include "pppd.h"
-#include "pathnames.h"
-#include "fsm.h"
-#include "lcp.h"
-#include "ccp.h"
-#include "ipcp.h"
-#include <sys/stat.h>
-#include <net/if.h>
-#include <sys/ioctl.h>
-#include <sys/socket.h>
-#include <netinet/in.h>
-#include <signal.h>
-#include <linux/version.h>
-#include <linux/sockios.h>
-#ifndef aligned_u64
-/* should be defined in sys/types.h */
-#define aligned_u64 unsigned long long __attribute__((aligned(8)))
-#endif
-#include <linux/types.h>
-#include <linux/if_ether.h>
-#include <linux/ppp_defs.h>
-#include <linux/if_ppp.h>
-#include <linux/if_pppox.h>
-#include <linux/if_pppol2tp.h>
-
-/* should be added to system's socket.h... */
-#ifndef SOL_PPPOL2TP
-#define SOL_PPPOL2TP	273
-#endif
-
-const char pppd_version[] = VERSION;
-
-static int setdevname_pppol2tp(char **argv);
-
-static int pppol2tp_fd = -1;
-static char *pppol2tp_fd_str;
-static bool pppol2tp_lns_mode = 0;
-static bool pppol2tp_recv_seq = 0;
-static bool pppol2tp_send_seq = 0;
-static int pppol2tp_debug_mask = 0;
-static int pppol2tp_reorder_timeout = 0;
-static char pppol2tp_ifname[32] = { 0, };
-int pppol2tp_tunnel_id = 0;
-int pppol2tp_session_id = 0;
-
-static int device_got_set = 0;
-struct channel pppol2tp_channel;
-
-static void (*old_snoop_recv_hook)(unsigned char *p, int len) = NULL;
-static void (*old_snoop_send_hook)(unsigned char *p, int len) = NULL;
-static void (*old_ip_up_hook)(void) = NULL;
-static void (*old_ip_down_hook)(void) = NULL;
-
-/* Hook provided to allow other plugins to handle ACCM changes */
-void (*pppol2tp_send_accm_hook)(int tunnel_id, int session_id, uint32_t send_accm, uint32_t recv_accm) = NULL;
-
-/* Hook provided to allow other plugins to handle IP up/down */
-void (*pppol2tp_ip_updown_hook)(int tunnel_id, int session_id, int up) = NULL;
-
-static option_t pppol2tp_options[] = {
-	{ "pppol2tp", o_special, &setdevname_pppol2tp,
-	  "FD for PPPoL2TP socket", OPT_DEVNAM | OPT_A2STRVAL,
-          &pppol2tp_fd_str },
-	{ "pppol2tp_lns_mode", o_bool, &pppol2tp_lns_mode,
-	  "PPPoL2TP LNS behavior. Default off.", 
-	  OPT_PRIO | OPRIO_CFGFILE },
-	{ "pppol2tp_send_seq", o_bool, &pppol2tp_send_seq,
-	  "PPPoL2TP enable sequence numbers in transmitted data packets. Default off.", 
-	  OPT_PRIO | OPRIO_CFGFILE },
-	{ "pppol2tp_recv_seq", o_bool, &pppol2tp_recv_seq,
-	  "PPPoL2TP enforce sequence numbers in received data packets. Default off.", 
-	  OPT_PRIO | OPRIO_CFGFILE },
-	{ "pppol2tp_reorderto", o_int, &pppol2tp_reorder_timeout,
-	  "PPPoL2TP data packet reorder timeout. Default 0 (no reordering).", 
-	  OPT_PRIO },
-	{ "pppol2tp_debug_mask", o_int, &pppol2tp_debug_mask,
-	  "PPPoL2TP debug mask. Default: no debug.", 
-	  OPT_PRIO },
-	{ "pppol2tp_ifname", o_string, &pppol2tp_ifname,
-	  "Set interface name of PPP interface",
-	  OPT_PRIO | OPT_PRIV | OPT_STATIC, NULL, 16 },
-	{ "pppol2tp_tunnel_id", o_int, &pppol2tp_tunnel_id,
-	  "PPPoL2TP tunnel_id.", 
-	  OPT_PRIO },
-	{ "pppol2tp_session_id", o_int, &pppol2tp_session_id,
-	  "PPPoL2TP session_id.", 
-	  OPT_PRIO },
-	{ NULL }
-};
-
-static int setdevname_pppol2tp(char **argv)
-{
-	union {
-		char buffer[128];
-		struct sockaddr pppol2tp;
-	} s;
-	struct sockaddr_pppol2tp sax;
-	int len = sizeof(s);
-	char **a;
-	int tmp;
-	int tmp_len = sizeof(tmp);
-
-	if (device_got_set)
-		return 0;
-		
-	if (!int_option(*argv, &pppol2tp_fd))
-		return 0;
-	                
-	if(getsockname(pppol2tp_fd, (struct sockaddr *)&s, &len) < 0) {
-		fatal("Given FD for PPPoL2TP socket invalid (%s)", strerror(errno));
-	}
-	if(s.pppol2tp.sa_family != AF_PPPOX) {
-		fatal("Socket of not a PPPoX socket");
-	}
-	memset(&sax, 0, sizeof(sax));
-	memcpy(&sax, &s.pppol2tp, sizeof(sax));
-	sprintf(ppp_devnam, "l2tp (%s)", inet_ntoa(sax.pppol2tp.addr.sin_addr));
-	/* Do a test getsockopt() to ensure that the kernel has the necessary 
-	 * feature available. 
-	 */
-	if (getsockopt(pppol2tp_fd, SOL_PPPOL2TP, PPPOL2TP_SO_DEBUG, &tmp, &tmp_len) < 0) {
-		fatal("PPPoL2TP kernel driver not installed");
-	}
-
-	/* Setup option defaults. Compression options are disabled! */
-	
-#ifndef _DISABLE_SERIAL_
-	modem = 0;
-#endif
-
-	lcp_allowoptions[0].neg_accompression = 1;
-	lcp_wantoptions[0].neg_accompression = 0;
-
-	lcp_allowoptions[0].neg_pcompression = 1;
-	lcp_wantoptions[0].neg_pcompression = 0;
-
-#ifdef CCP_SUPPORT
-	ccp_allowoptions[0].deflate = 0;
-	ccp_wantoptions[0].deflate = 0;
-#endif
-
-	ipcp_allowoptions[0].neg_vj = 0;
-	ipcp_wantoptions[0].neg_vj = 0;
-
-#ifdef CCP_SUPPORT
-	ccp_allowoptions[0].bsd_compress = 0;
-	ccp_wantoptions[0].bsd_compress = 0;
-#endif
-
-	the_channel = &pppol2tp_channel;
-	device_got_set = 1;
-
-	return 1;
-}
-
-static int connect_pppol2tp(void)
-{
-	if(pppol2tp_fd == -1) {
-		fatal("No PPPoL2TP FD specified");
-	}
-
-	return pppol2tp_fd;
-}
-
-static void disconnect_pppol2tp(void)
-{
-	if (pppol2tp_fd >= 0) {
-		close(pppol2tp_fd);
-		pppol2tp_fd = -1;
-	}
-}
-
-static void send_config_pppol2tp(int mtu,
-			      u_int32_t asyncmap,
-			      int pcomp,
-			      int accomp)
-{
-	struct ifreq ifr;
-	int on = 1;
-	int fd;
-	char reorderto[16];
-	char tid[8];
-	char sid[8];
-
-	if (pppol2tp_ifname[0]) {
-		struct ifreq ifr;
-		int fd;
-
-		fd = socket(AF_INET, SOCK_DGRAM, 0);
-		if (fd >= 0) {
-			memset (&ifr, '\0', sizeof (ifr));
-			strlcpy(ifr.ifr_name, ifname, sizeof(ifr.ifr_name));
-			strlcpy(ifr.ifr_newname, pppol2tp_ifname, sizeof(ifr.ifr_name));
-			ioctl(fd, SIOCSIFNAME, (caddr_t) &ifr);
-			strlcpy(ifname, pppol2tp_ifname, 32);
-			if (pppol2tp_debug_mask & PPPOL2TP_MSG_CONTROL) {
-				dbglog("ppp%d: interface name %s", ifunit, ifname);
-			}
-		}
-		close(fd);
-	}
-
-	if ((lcp_allowoptions[0].mru > 0) && (mtu > lcp_allowoptions[0].mru)) {
-		warn("Overriding mtu %d to %d", mtu, lcp_allowoptions[0].mru);
-		mtu = lcp_allowoptions[0].mru;
-	}
-	netif_set_mtu(ifunit, mtu);
-
-	reorderto[0] = '\0';
-	if (pppol2tp_reorder_timeout > 0)
-		sprintf(&reorderto[0], "%d ", pppol2tp_reorder_timeout);
-	tid[0] = '\0';
-	if (pppol2tp_tunnel_id > 0)
-		sprintf(&tid[0], "%hu ", pppol2tp_tunnel_id);
-	sid[0] = '\0';
-	if (pppol2tp_session_id > 0)
-		sprintf(&sid[0], "%hu ", pppol2tp_session_id);
-		
-	dbglog("PPPoL2TP options: %s%s%s%s%s%s%s%s%sdebugmask %d", 
-	       pppol2tp_recv_seq ? "recvseq " : "",
-	       pppol2tp_send_seq ? "sendseq " : "",
-	       pppol2tp_lns_mode ? "lnsmode " : "",
-	       pppol2tp_reorder_timeout ? "reorderto " : "", reorderto,
-	       pppol2tp_tunnel_id ? "tid " : "", tid,
-	       pppol2tp_session_id ? "sid " : "", sid,
-	       pppol2tp_debug_mask);
-
-	if (pppol2tp_recv_seq)
-		if (setsockopt(pppol2tp_fd, SOL_PPPOL2TP, PPPOL2TP_SO_RECVSEQ, &on, sizeof(on)) < 0)
-			fatal("setsockopt(PPPOL2TP_RECVSEQ): %m");
-	if (pppol2tp_send_seq)
-		if (setsockopt(pppol2tp_fd, SOL_PPPOL2TP, PPPOL2TP_SO_SENDSEQ, &on, sizeof(on)) < 0)
-			fatal("setsockopt(PPPOL2TP_SENDSEQ): %m");
-	if (pppol2tp_lns_mode)
-		if (setsockopt(pppol2tp_fd, SOL_PPPOL2TP, PPPOL2TP_SO_LNSMODE, &on, sizeof(on)) < 0)
-			fatal("setsockopt(PPPOL2TP_LNSMODE): %m");
-	if (pppol2tp_reorder_timeout)
-		if (setsockopt(pppol2tp_fd, SOL_PPPOL2TP, PPPOL2TP_SO_REORDERTO, &pppol2tp_reorder_timeout, sizeof(pppol2tp_reorder_timeout)) < 0)
-			fatal("setsockopt(PPPOL2TP_REORDERTO): %m");
-	if (pppol2tp_debug_mask)
-		if (setsockopt(pppol2tp_fd, SOL_PPPOL2TP, PPPOL2TP_SO_DEBUG, &pppol2tp_debug_mask, sizeof(pppol2tp_debug_mask)) < 0)
-			fatal("setsockopt(PPPOL2TP_DEBUG): %m");
-}
-
-static void recv_config_pppol2tp(int mru,
-			      u_int32_t asyncmap,
-			      int pcomp,
-			      int accomp)
-{
-	if ((lcp_allowoptions[0].mru > 0) && (mru > lcp_allowoptions[0].mru)) {
-		warn("Overriding mru %d to mtu value %d", mru, lcp_allowoptions[0].mru);
-		mru = lcp_allowoptions[0].mru;
-	}
-	if ((ifunit >= 0) && ioctl(pppol2tp_fd, PPPIOCSMRU, (caddr_t) &mru) < 0)
-		error("Couldn't set PPP MRU: %m");
-}
-
-/*****************************************************************************
- * Snoop LCP message exchanges to capture negotiated ACCM values.
- * When asyncmap values have been seen from both sides, give the values to
- * L2TP.
- * This code is derived from Roaring Penguin L2TP.
- *****************************************************************************/
-
-static void pppol2tp_lcp_snoop(unsigned char *buf, int len, int incoming)
-{
-	static bool got_send_accm = 0;
-	static bool got_recv_accm = 0;
-	static uint32_t recv_accm = 0xffffffff;
-	static uint32_t send_accm = 0xffffffff;
-	static bool snooping = 1;
-
-	uint16_t protocol;
-	uint16_t lcp_pkt_len;
-	int opt, opt_len;
-	int reject;
-	unsigned char const *opt_data;
-	uint32_t accm;
-
-	/* Skip HDLC header */
-	buf += 2;
-	len -= 2;
-
-	/* Unreasonably short frame?? */
-	if (len <= 0) return;	
-
-	/* Get protocol */
-	if (buf[0] & 0x01) {
-		/* Compressed protcol field */
-		protocol = buf[0];
-	} else {
-		protocol = ((unsigned int) buf[0]) * 256 + buf[1];
-	}
-
-	/* If it's a network protocol, stop snooping */
-	if (protocol <= 0x3fff) {
-		if (pppol2tp_debug_mask & PPPOL2TP_MSG_DEBUG) {
-			dbglog("Turning off snooping: Network protocol %04x found.", protocol);
-		}
-		snooping = 0;
-		return;
-	}
-
-	/* If it's not LCP, do not snoop */
-	if (protocol != 0xc021) {
-		return;
-	}
-
-	/* Skip protocol; go to packet data */
-	buf += 2;
-	len -= 2;
-
-	/* Unreasonably short frame?? */
-	if (len <= 0) return;
-
-	/* Look for Configure-Ack or Configure-Reject code */
-	if (buf[0] != CONFACK && buf[0] != CONFREJ) return;
-
-	reject = (buf[0] == CONFREJ);
-
-	lcp_pkt_len = ((unsigned int) buf[2]) * 256 + buf[3];
-
-	/* Something fishy with length field? */
-	if (lcp_pkt_len > len) return;
-
-	/* Skip to options */
-	len = lcp_pkt_len - 4;
-	buf += 4;
-
-	while (len > 0) {
-		/* Pull off an option */
-		opt = buf[0];
-		opt_len = buf[1];
-		opt_data = &buf[2];
-		if (opt_len > len || opt_len < 2) break;
-		len -= opt_len;
-		buf += opt_len;
-		if (pppol2tp_debug_mask & PPPOL2TP_MSG_DEBUG) {
-			dbglog("Found option type %02x; len %d", opt, opt_len);
-		}
-
-		/* We are specifically interested in ACCM */
-		if (opt == CI_ASYNCMAP && opt_len == 0x06) {
-			if (reject) {
-				/* ACCM negotiation REJECTED; use default */
-				accm = 0xffffffff;
-				if (pppol2tp_debug_mask & PPPOL2TP_MSG_DATA) {
-					dbglog("Rejected ACCM negotiation; defaulting (%s)", incoming ? "incoming" : "outgoing");
-				}
-				recv_accm = accm;
-				send_accm = accm;
-				got_recv_accm = 1;
-				got_send_accm = 1;
-			} else {
-				memcpy(&accm, opt_data, sizeof(accm));
-				if (pppol2tp_debug_mask & PPPOL2TP_MSG_DATA) {
-					dbglog("Found ACCM of %08x (%s)", accm, incoming ? "incoming" : "outgoing");
-				}
-				if (incoming) {
-					recv_accm = accm;
-					got_recv_accm = 1;
-				} else {
-					send_accm = accm;
-					got_send_accm = 1;
-				}
-			}
-
-			if (got_recv_accm && got_send_accm) {
-				if (pppol2tp_debug_mask & PPPOL2TP_MSG_CONTROL) {
-					dbglog("Telling L2TP: Send ACCM = %08x; Receive ACCM = %08x", send_accm, recv_accm);
-				}
-				if (pppol2tp_send_accm_hook != NULL) {
-					(*pppol2tp_send_accm_hook)(pppol2tp_tunnel_id, pppol2tp_session_id, send_accm, recv_accm);
-				}
-				got_recv_accm = 0;
-				got_send_accm = 0;
-			}
-		}
-	}
-}
-
-static void pppol2tp_lcp_snoop_recv(unsigned char *p, int len)
-{
-	if (old_snoop_recv_hook != NULL)
-		(*old_snoop_recv_hook)(p, len);
-	pppol2tp_lcp_snoop(p, len, 1);
-}
-
-static void pppol2tp_lcp_snoop_send(unsigned char *p, int len)
-{
-	if (old_snoop_send_hook != NULL)
-		(*old_snoop_send_hook)(p, len);
-	pppol2tp_lcp_snoop(p, len, 0);
-}
-
-/*****************************************************************************
- * Interface up/down events
- *****************************************************************************/
-
-static void pppol2tp_ip_up_hook(void)
-{
-	if (old_ip_up_hook != NULL)
-		(*old_ip_up_hook)();
-
-	if (pppol2tp_ip_updown_hook != NULL) {
-		(*pppol2tp_ip_updown_hook)(pppol2tp_tunnel_id, pppol2tp_session_id, 1);
-	}
-}
-
-static void pppol2tp_ip_down_hook(void)
-{
-	if (old_ip_down_hook != NULL)
-		(*old_ip_down_hook)();
-
-	if (pppol2tp_ip_updown_hook != NULL) {
-		(*pppol2tp_ip_updown_hook)(pppol2tp_tunnel_id, pppol2tp_session_id, 0);
-	}
-}
-
-/*****************************************************************************
- * Application init
- *****************************************************************************/
-
-static void pppol2tp_check_options(void)
-{
-	/* Enable LCP snooping for ACCM options only for LNS */
-	if (pppol2tp_lns_mode) {
-		if ((pppol2tp_tunnel_id == 0) || (pppol2tp_session_id == 0)) {
-			fatal("tunnel_id/session_id values not specified");
-		}
-		if (pppol2tp_debug_mask & PPPOL2TP_MSG_CONTROL) {
-			dbglog("Enabling LCP snooping");
-		}
-		old_snoop_recv_hook = snoop_recv_hook;
-		old_snoop_send_hook = snoop_send_hook;
-
-		snoop_recv_hook = pppol2tp_lcp_snoop_recv;
-		snoop_send_hook = pppol2tp_lcp_snoop_send;
-	}
-
-	/* Hook up ip up/down hooks to send indicator to openl2tpd that the link is up */
-	old_ip_up_hook = ip_up_hook;
-	ip_up_hook = pppol2tp_ip_up_hook;
-	old_ip_down_hook = ip_down_hook;
-	ip_down_hook = pppol2tp_ip_down_hook;
-}
-
-/* Called just before pppd exits.
- */
-static void pppol2tp_cleanup(void)
-{
-	if (pppol2tp_debug_mask & PPPOL2TP_MSG_DEBUG) {
-		dbglog("pppol2tp: exiting.");
-	}
-	disconnect_pppol2tp();
-}
-
-void plugin_init(void)
-{
-#if defined(__linux__)
-	extern int new_style_driver;	/* From sys-linux.c */
-	if (!ppp_available() && !new_style_driver)
-		fatal("Kernel doesn't support ppp_generic - "
-		    "needed for PPPoL2TP");
-#else
-	fatal("No PPPoL2TP support on this OS");
-#endif
-	add_options(pppol2tp_options);
-}
-
-struct channel pppol2tp_channel = {
-    options: pppol2tp_options,
-    process_extra_options: NULL,
-    check_options: &pppol2tp_check_options,
-    connect: &connect_pppol2tp,
-    disconnect: &disconnect_pppol2tp,
-    establish_ppp: &generic_establish_ppp,
-    disestablish_ppp: &generic_disestablish_ppp,
-    send_config: &send_config_pppol2tp,
-    recv_config: &recv_config_pppol2tp,
-    close: NULL,
-    cleanup: NULL
-};
--- ppp-2.4.4.orig/pppd/plugins/pppol2tp/scheduler.c	1970-01-01 03:00:00.000000000 +0300
+++ ppp-2.4.4/pppd/plugins/pppol2tp/scheduler.c	2011-01-24 13:53:48.000000000 +0300
@@ -0,0 +1,165 @@
+/*
+ * Layer Two Tunnelling Protocol Daemon
+ * Copyright (C) 1998 Adtran, Inc.
+ * Copyright (C) 2002 Jeff McAdams
+ *
+ * Mark Spencer
+ *
+ * This software is distributed under the terms
+ * of the GPL, which you should have received
+ * along with this source.
+ *
+ * Scheduler code for time based functionality
+ *
+ */
+
+#include <stdlib.h>
+#include <string.h>
+#include "l2tp.h"
+#include "scheduler.h"
+
+struct schedule_entry *events;
+
+void init_scheduler (void)
+{
+    events = NULL;
+}
+
+struct timeval *process_schedule (struct timeval *ptv)
+{
+    /* Check queue for events which should be
+       executed right now.  Execute them, then
+       see how long we should set the next timer
+     */
+    struct schedule_entry *p = events;
+    struct timeval now;
+    struct timeval then;
+    while (events)
+    {
+        gettimeofday (&now, NULL);
+        p = events;
+        if (TVLESSEQ (p->tv, now))
+        {
+            events = events->next;
+            /* This needs to be executed, as it has expired.
+               It is expected that p->func will free p->data
+               if it is necessary */
+            (*p->func) (p->data);
+            free (p);
+        }
+        else
+            break;
+    }
+    /* When we get here, either there are no more events
+       in the queue, or the remaining events need to happen
+       in the future, so we should schedule another alarm */
+    if (events)
+    {
+        then.tv_sec = events->tv.tv_sec - now.tv_sec;
+        then.tv_usec = events->tv.tv_usec - now.tv_usec;
+        if (then.tv_usec < 0)
+        {
+            then.tv_sec -= 1;
+            then.tv_usec += 1000000;
+        }
+        if ((then.tv_sec <= 0) && (then.tv_usec <= 0))
+        {
+            l2tp_log (LOG_WARNING, "%s: Whoa...  Scheduling for <=0 time???\n",
+                 __FUNCTION__);
+            then.tv_sec = 1;
+            then.tv_usec = 0;
+        }
+        *ptv = then;
+        return ptv;
+    }
+    else
+    {
+        return NULL;
+    }
+}
+
+struct schedule_entry *schedule (struct timeval tv, void (*func) (void *),
+                                 void *data)
+{
+    /* Schedule func to be run at relative time tv with data
+       as arguments.  If it has already expired, run it 
+       immediately.  The queue should be in order of
+       increasing time */
+    struct schedule_entry *p = events, *q = NULL;
+    struct timeval diff;
+    diff = tv;
+    gettimeofday (&tv, NULL);
+    tv.tv_sec += diff.tv_sec;
+    tv.tv_usec += diff.tv_usec;
+    if (tv.tv_usec > 1000000)
+    {
+        tv.tv_sec++;
+        tv.tv_usec -= 1000000;
+    }
+    while (p)
+    {
+        if (TVLESS (tv, p->tv))
+            break;
+        q = p;
+        p = p->next;
+    };
+    if (q)
+    {
+        q->next =
+            (struct schedule_entry *) zalloc (sizeof (struct schedule_entry));
+        q = q->next;
+    }
+    else
+    {
+        q = (struct schedule_entry *) zalloc (sizeof (struct schedule_entry));
+        events = q;
+    }
+    q->tv = tv;
+    q->func = func;
+    q->data = data;
+    q->next = p;
+    return q;
+
+}
+
+inline struct schedule_entry *aschedule (struct timeval tv,
+                                         void (*func) (void *), void *data)
+{
+    /* Schedule func to be run at absolute time tv in the future with data
+       as arguments */
+    struct timeval now;
+    gettimeofday (&now, NULL);
+    tv.tv_usec -= now.tv_usec;
+    if (tv.tv_usec < 0)
+    {
+        tv.tv_usec += 1000000;
+        tv.tv_sec--;
+    }
+    tv.tv_sec -= now.tv_sec;
+    return schedule (tv, func, data);
+}
+
+void deschedule (struct schedule_entry *s)
+{
+    struct schedule_entry *p = events, *q = NULL;
+    if (!s)
+        return;
+    while (p)
+    {
+        if (p == s)
+        {
+            if (q)
+            {
+                q->next = p->next;
+            }
+            else
+            {
+                events = events->next;
+            }
+            free (p);
+            break;
+        }
+        q = p;
+        p = p->next;
+    }
+}
--- ppp-2.4.4.orig/pppd/plugins/pppol2tp/scheduler.h	1970-01-01 03:00:00.000000000 +0300
+++ ppp-2.4.4/pppd/plugins/pppol2tp/scheduler.h	2011-01-24 13:53:48.000000000 +0300
@@ -0,0 +1,67 @@
+/*
+ * Layer Two Tunnelling Protocol Daemon
+ * Copyright (C) 1998 Adtran, Inc.
+ * Copyright (C) 2002 Jeff McAdams
+ *
+ * Mark Spencer
+ *
+ * This software is distributed under the terms
+ * of the GPL, which you should have received
+ * along with this source.
+ *
+ * Scheduler structures and functions
+ *
+ */
+
+#ifndef _SCHEDULER_H
+#define _SCHEDULER_H
+#include <sys/time.h>
+
+/*
+ * The idea is to provide a general scheduler which can schedule
+ * events to be run periodically
+ */
+
+struct schedule_entry
+{
+    struct timeval tv;          /* Scheduled time to execute */
+    void (*func) (void *);      /* Function to execute */
+    void *data;                 /* Data to be passed to func */
+    struct schedule_entry *next;        /* Next entry in queue */
+};
+
+extern struct schedule_entry *events;
+
+/* Schedule func to be executed with argument data sometime
+   tv in the future. */
+
+struct schedule_entry *schedule (struct timeval tv, void (*func) (void *),
+                                 void *data);
+
+/* Like schedule() but tv represents an absolute time in the future */
+
+struct schedule_entry *aschedule (struct timeval tv, void (*func) (void *),
+                                  void *data);
+
+/* Remove a scheduled event from the queue */
+
+void deschedule (struct schedule_entry *);
+
+/* Initialization function */
+void init_scheduler (void);
+
+/* Scheduled event processor */
+struct timeval *process_schedule(struct timeval *);
+
+/* Compare two timeval functions and see if a <= b */
+
+#define TVLESS(a,b) ((a).tv_sec == (b).tv_sec ? \
+				((a).tv_usec < (b).tv_usec) : \
+				((a).tv_sec < (b).tv_sec))
+#define TVLESSEQ(a,b) ((a).tv_sec == (b).tv_sec ? \
+				((a).tv_usec <= (b).tv_usec) : \
+				((a).tv_sec <= (b).tv_sec))
+#define TVGT(a,b) ((a).tv_sec == (b).tv_sec ? \
+				((a).tv_usec > (b).tv_usec) : \
+				((a).tv_sec > (b).tv_sec))
+#endif
--- ppp-2.4.4.orig/pppd/plugins/pppol2tp/xl2tpd.c	1970-01-01 03:00:00.000000000 +0300
+++ ppp-2.4.4/pppd/plugins/pppol2tp/xl2tpd.c	2011-01-24 16:47:33.000000000 +0300
@@ -0,0 +1,551 @@
+/*
+ * Layer Two Tunnelling Protocol Daemon
+ * Copyright (C) 1998 Adtran, Inc.
+ * Copyright (C) 2002 Jeff McAdams
+ *
+ *
+ * Mark Spencer
+ *
+ * This software is distributed under the terms
+ * of the GPL, which you should have received
+ * along with this source.
+ *
+ * Main Daemon source.
+ *
+ */
+
+#define _ISOC99_SOURCE
+#define _XOPEN_SOURCE
+#define _BSD_SOURCE
+#define _XOPEN_SOURCE_EXTENDED
+
+#include <stdlib.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/wait.h>
+#include <stdio.h>
+#include <errno.h>
+#include <unistd.h>
+#include <time.h>
+#if (__GLIBC__ < 2)
+# if defined(FREEBSD)
+#  include <sys/signal.h>
+# elif defined(LINUX)
+#  include <bsd/signal.h>
+# elif defined(SOLARIS)
+#  include <signal.h>
+# endif
+#else
+# include <signal.h>
+#endif
+#include <netdb.h>
+#include <string.h>
+#include <strings.h>
+#include <fcntl.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include "l2tp.h"
+#include <pthread.h>
+
+struct tunnel_list tunnels;
+int max_tunnels = DEF_MAX_TUNNELS;
+int rand_source;
+int ppd = 1;                    /* Packet processing delay */
+
+int iexit = 0;
+int isock_fd = -1;
+int icontrol_pid = -1;
+static int icontrol_thread = 0;
+static pthread_t l2tp_thread;
+static pthread_mutex_t l2tp_mutex = PTHREAD_MUTEX_INITIALIZER;
+static pthread_cond_t  l2tp_cond  = PTHREAD_COND_INITIALIZER;
+
+extern int _stat_get();
+extern void _stat_write_status( int a_nStat );
+extern void _stat_write_result( int a_nStat );
+extern void _stat_write_chain( int a_nStat );
+
+void init_tunnel_list (struct tunnel_list *t)
+{
+    t->head = NULL;
+    t->count = 0;
+    t->calls = 0;
+}
+
+void stop_pppd (int istat) {
+     if( istat != -1 ) {
+    	 _stat_write_status(istat);
+ 		 _stat_write_result(istat);
+ 		 _stat_write_chain(istat);
+ 		 l2tp_log (LOG_WARNING, "%s: exit(%d).\n", __FUNCTION__, istat);
+     }
+	
+     if( !iexit ) {
+  		 iexit = 1;
+		 if( icontrol_pid != -1 ) kill(icontrol_pid, SIGHUP);
+    }
+    
+    l2tp_unblock();
+}
+
+void start_pppd (struct call *c)
+{
+    int flags;
+    struct sockaddr_pppol2tp sax;
+    
+    isock_fd = socket(AF_PPPOX, SOCK_DGRAM, PX_PROTO_OL2TP);
+    if (isock_fd < 0) {
+	l2tp_log (LOG_WARNING, "%s: Unable to allocate PPPoL2TP socket.\n",
+			__FUNCTION__);
+		
+	l2tp_unblock();
+	return;
+    }
+    flags = fcntl(isock_fd, F_GETFL);
+    if (flags == -1 || fcntl(isock_fd, F_SETFL, flags | O_NONBLOCK) == -1) {
+    	l2tp_log (LOG_WARNING, "%s: Unable to set PPPoL2TP socket nonblock.\n",
+    			__FUNCTION__);
+	close(isock_fd);
+	isock_fd = -1;
+	l2tp_unblock();
+    	return;
+    }
+    sax.sa_family = AF_PPPOX;
+    sax.sa_protocol = PX_PROTO_OL2TP;
+    sax.pppol2tp.pid = 0;
+    sax.pppol2tp.fd = server_socket;
+    sax.pppol2tp.addr.sin_addr.s_addr = c->container->peer.sin_addr.s_addr;
+    sax.pppol2tp.addr.sin_port = c->container->peer.sin_port;
+    sax.pppol2tp.addr.sin_family = AF_INET;
+    sax.pppol2tp.s_tunnel  = c->container->ourtid;
+    sax.pppol2tp.s_session = c->ourcid;
+    sax.pppol2tp.d_tunnel  = c->container->tid;
+    sax.pppol2tp.d_session = c->cid;
+    if (connect(isock_fd, (struct sockaddr *)&sax, sizeof(sax)) < 0) {
+    	l2tp_log (LOG_WARNING, "%s: Unable to connect PPPoL2TP socket.\n",
+    			__FUNCTION__);
+
+	close(isock_fd);
+	isock_fd = -1;
+	l2tp_unblock();
+	return;
+    }
+    /* l2tp_log (LOG_INFO, "Connect to server %s\n", inet_ntoa(sax.pppol2tp.addr.sin_addr)); */
+    
+    l2tp_unblock();
+}
+
+void destroy_tunnel (struct tunnel *t)
+{
+    /*
+     * Immediately destroy a tunnel (and all its calls)
+     * and free its resources.  This may be called
+     * by the tunnel itself,so it needs to be
+     * "suicide safe"
+     */
+     
+    struct call *c, *me;
+    struct tunnel *p;
+    struct timeval tv;
+    if (!t)
+        return;
+
+    /*
+     * Save ourselves until the very
+     * end, since we might be calling this ourselves.
+     * We must divorce ourself from the tunnel
+     * structure, however, to avoid recursion
+     * because of the logic of the destroy_call
+     */
+    me = t->self;
+
+    /*
+     * Destroy all the member calls
+     */
+    c = t->call_head;
+    while (c)
+    {
+        destroy_call (c);
+        c = c->next;
+    };
+    /*
+     * Remove ourselves from the list of tunnels
+     */
+
+    if (tunnels.head == t)
+    {
+        tunnels.head = t->next;
+        tunnels.count--;
+    }
+    else
+    {
+        p = tunnels.head;
+        if (p)
+        {
+            while (p->next && (p->next != t))
+                p = p->next;
+            if (p->next)
+            {
+                p->next = t->next;
+                tunnels.count--;
+            }
+            else
+            {
+                l2tp_log (LOG_WARNING,
+                     "%s: unable to locate tunnel in tunnel list\n",
+                     __FUNCTION__);
+            }
+        }
+        else
+        {
+            l2tp_log (LOG_WARNING, "%s: tunnel list is empty!\n", __FUNCTION__);
+        }
+    }
+    if (t->lac) {
+        t->lac->t = NULL;
+    }
+    /* XXX L2TP/IPSec: remove relevant SAs here?  NTB 20011010
+     * XXX But what if another tunnel is using same SA?
+     */
+    if (t->chal_us.challenge)
+        free (t->chal_us.challenge);
+    if (t->chal_them.challenge)
+        free (t->chal_them.challenge);
+    /* we need no free(t->chal_us.vector) here because we zalloc() and free()
+       the memory pointed to by t->chal_us.vector at some other place */
+    if (t->chal_them.vector)
+        free (t->chal_them.vector);
+    free (t);
+    free (me);
+}
+
+struct tunnel *l2tp_call (char *host, int port, struct lac *lac)
+{
+    /*
+     * Establish a tunnel from us to host
+     * on port port
+     */
+    struct call *tmp = NULL;
+    struct hostent *hp;
+    unsigned int addr;
+    port = htons (port);
+    hp = gethostbyname (host);
+    if (!hp)
+    {
+        l2tp_log (LOG_WARNING, "Host name lookup failed for %s.\n",
+             host);
+
+        // zw : if server doesn't lookup -- exit
+        stop_pppd(3);
+        return NULL;
+    }
+    bcopy (hp->h_addr, &addr, hp->h_length);
+    /* Force creation of a new tunnel
+       and set it's tid to 0 to cause
+       negotiation to occur */
+    /*
+     * to do IPsec properly here, we need to set a socket policy,
+     * and/or communicate with pluto.
+     */
+    tmp = get_call (0, 0, addr, port, IPSEC_SAREF_NULL, IPSEC_SAREF_NULL);
+    if (!tmp)
+    {
+        l2tp_log (LOG_WARNING, "%s: Unable to create tunnel to %s.\n", __FUNCTION__,
+             host);
+        return NULL;
+    }
+    tmp->container->tid = 0;
+    tmp->container->lac = lac;
+    tmp->lac = lac;
+    if (lac)
+        lac->t = tmp->container;
+    /*
+     * Since our state is 0, we will establish a tunnel now
+     */
+    l2tp_log (LOG_NOTICE, "Connecting to host %s, port %d\n", host,
+         ntohs (port));
+    control_finish (tmp->container, tmp);
+    return tmp->container;
+}
+
+void magic_lac_tunnel (void *data)
+{
+    struct lac *lac;
+    lac = (struct lac *) data;
+    if (!lac)
+    {
+        l2tp_log (LOG_WARNING, "%s: magic_lac_tunnel: called on NULL lac!\n",
+             __FUNCTION__);
+        return;
+    }
+    if (lac->lns)
+    {
+        /* FIXME: I should try different LNS's if I get failures */
+        l2tp_call (lac->lns->hostname, lac->lns->port, lac);
+        return;
+    }
+    else
+    {
+        l2tp_log (LOG_WARNING, "%s: Unable to find hostname to dial for '%s'\n",
+             __FUNCTION__, lac->entname);
+        return;
+    }
+}
+
+struct call *lac_call (int tid, struct lac *lac)
+{
+    struct tunnel *t = tunnels.head;
+    struct call *tmp;
+    
+    while (t)
+    {
+        if (t->ourtid == tid)
+        {
+            tmp = new_call (t);
+            if (!tmp)
+            {
+                l2tp_log (LOG_WARNING, "%s: unable to create new call\n",
+                     __FUNCTION__);
+                return NULL;
+            }
+            tmp->next = t->call_head;
+            t->call_head = tmp;
+            t->count++;
+            tmp->cid = 0;
+            tmp->lac = lac;
+            if (lac)
+                lac->c = tmp;
+            l2tp_log (LOG_NOTICE, "Calling on tunnel %d\n", tid);
+            control_finish (t, tmp);
+            return tmp;
+        }
+        t = t->next;
+    };
+    l2tp_log (LOG_DEBUG, "%s: No such tunnel %d to generate call.\n", __FUNCTION__,
+         tid);
+    return NULL;
+}
+
+void magic_lac_dial (void *data)
+{
+    struct lac *lac;
+    lac = (struct lac *) data;
+    if (!lac->active)
+    {
+        l2tp_log (LOG_DEBUG, "%s: LAC %s not active", __FUNCTION__, lac->entname);
+        return;
+    }
+    lac->rsched = NULL;
+    if (!lac)
+    {
+        l2tp_log (LOG_WARNING, "%s : called on NULL lac!\n", __FUNCTION__);
+        return;
+    }
+    if (!lac->t)
+    {
+#ifdef DEGUG_MAGIC
+        l2tp_log (LOG_DEBUG, "%s : tunnel not up!  Connecting!\n", __FUNCTION__);
+#endif
+        magic_lac_tunnel (lac);
+        return;
+    }
+    lac_call (lac->t->ourtid, lac);
+}
+
+void lac_hangup (int cid)
+{
+    struct tunnel *t = tunnels.head;
+    struct call *tmp;
+    while (t)
+    {
+        tmp = t->call_head;
+        while (tmp)
+        {
+            if (tmp->ourcid == cid)
+            {
+                l2tp_log (LOG_INFO,
+                     "%s :Hanging up call %d, Local: %d, Remote: %d\n",
+                     __FUNCTION__, tmp->serno, tmp->ourcid, tmp->cid);
+                strcpy (tmp->errormsg, "Goodbye!");
+		stop_pppd(0);
+                return;
+            }
+            tmp = tmp->next;
+        }
+        t = t->next;
+    };
+    l2tp_log (LOG_DEBUG, "%s : No such call %d to hang up.\n", __FUNCTION__, cid);
+    return;
+}
+
+void lac_disconnect (int tid)
+{
+    struct tunnel *t = tunnels.head;
+    while (t)
+    {
+        if (t->ourtid == tid)
+        {
+            l2tp_log (LOG_INFO,
+                 "Disconnecting from %s, Local: %d, Remote: %d\n",
+                 IPADDY (t->peer.sin_addr), t->ourtid, t->tid);
+            t->self->needclose = -1;
+            strcpy (t->self->errormsg, "Goodbye!");
+            call_close (t->self);
+            return;
+        }
+        t = t->next;
+    };
+    l2tp_log (LOG_DEBUG, "No such tunnel %d to hang up.\n", tid);
+    return;
+}
+
+
+struct tunnel *new_tunnel ()
+{
+    struct tunnel *tmp = zalloc (sizeof (struct tunnel));
+    unsigned char entropy_buf[2] = "\0";
+    if (!tmp)
+        return NULL;
+    tmp->control_seq_num = 0;
+    tmp->control_rec_seq_num = 0;
+    tmp->cLr = 0;
+    tmp->call_head = NULL;
+    tmp->next = NULL;
+    tmp->debug = -1;
+    tmp->tid = -1;
+    tmp->hello = NULL;
+#ifndef TESTING
+/*      while(get_call((tmp->ourtid = rand() & 0xFFFF),0,0,0)); */
+/*        tmp->ourtid = rand () & 0xFFFF; */
+        /* get_entropy((char *)&tmp->ourtid, 2); */
+        get_entropy(entropy_buf, 2);
+        {
+            unsigned short *temp;
+            temp = (unsigned short *)entropy_buf;
+            tmp->ourtid = *temp & 0xFFFF;
+#ifdef DEBUG_ENTROPY
+            l2tp_log(LOG_DEBUG, "ourtid = %u, entropy_buf = %hx\n", tmp->ourtid, *temp);
+#endif
+        }
+
+#else
+    tmp->ourtid = 0x6227;
+#endif
+    tmp->nego = 0;
+    tmp->count = 0;
+    tmp->state = 0;             /* Nothing */
+    tmp->peer.sin_family = AF_INET;
+    tmp->peer.sin_port = 0;
+    bzero (&(tmp->peer.sin_addr), sizeof (tmp->peer.sin_addr));
+#ifdef SANITY
+    tmp->sanity = -1;
+#endif
+    tmp->qtid = -1;
+    tmp->ourfc = ASYNC_FRAMING | SYNC_FRAMING;
+    tmp->ourbc = 0;
+    tmp->ourtb = (((_u64) rand ()) << 32) | ((_u64) rand ());
+    tmp->fc = -1;               /* These really need to be specified by the peer */
+    tmp->bc = -1;               /* And we want to know if they forgot */
+    tmp->hostname[0] = 0;
+    tmp->vendor[0] = 0;
+    tmp->secret[0] = 0;
+    if (!(tmp->self = new_call (tmp)))
+    {
+        free (tmp);
+        return NULL;
+    };
+    tmp->ourrws = DEFAULT_RWS_SIZE;
+    tmp->self->ourfbit = FBIT;
+    tmp->lac = NULL;
+    tmp->chal_us.state = 0;
+    tmp->chal_us.secret[0] = 0;
+    memset (tmp->chal_us.reply, 0, MD_SIG_SIZE);
+    tmp->chal_us.challenge = NULL;
+    tmp->chal_us.chal_len = 0;
+    tmp->chal_them.state = 0;
+    tmp->chal_them.secret[0] = 0;
+    memset (tmp->chal_them.reply, 0, MD_SIG_SIZE);
+    tmp->chal_them.challenge = NULL;
+    tmp->chal_them.chal_len = 0;
+    tmp->chal_them.vector = (unsigned char *) zalloc (VECTOR_SIZE);
+    tmp->chal_us.vector = NULL;
+    tmp->hbit = 0;
+    return tmp;
+}
+
+void l2tp_wait_socket() {
+    pthread_mutex_lock(&l2tp_mutex);
+    if( icontrol_thread ) pthread_cond_wait(&l2tp_cond, &l2tp_mutex);
+    pthread_mutex_unlock(&l2tp_mutex);
+}
+
+void l2tp_unblock() {
+    pthread_mutex_lock(&l2tp_mutex);
+    pthread_cond_signal(&l2tp_cond);
+    pthread_mutex_unlock(&l2tp_mutex);
+}
+
+int l2tp_init(char *lns) {
+    struct lac *lac;
+    struct in_addr listenaddr;
+    
+    srand( time(NULL) );
+    rand_source = 0;
+
+    init_config(lns);
+    init_tunnel_list(&tunnels);
+
+    if (init_network ()) 
+		return -1;
+
+    init_scheduler ();
+    
+    l2tp_log (LOG_INFO, "l2tp version " SERVER_VERSION " started on %s PID:%d\n",
+         hostname, getpid ());
+/*
+    l2tp_log (LOG_INFO,
+         "Written by Mark Spencer, Copyright (C) 1998, Adtran, Inc.\n");
+    l2tp_log (LOG_INFO, "Forked by Scott Balmos and David Stipp, (C) 2001\n");
+    l2tp_log (LOG_INFO, "Inherited by Jeff McAdams, (C) 2002\n");
+    l2tp_log (LOG_INFO, "Forked again by Xelerance (www.xelerance.com) (C) 2006\n");
+*/
+    listenaddr.s_addr = gconfig.listenaddr;
+
+    lac = laclist;
+    if (lac)
+    {
+#ifdef DEBUG_MAGIC
+            l2tp_log (LOG_DEBUG, "%s: Autodialing '%s'\n", __FUNCTION__,
+                 lac->entname[0] ? lac->entname : "(unnamed)");
+#endif
+            lac->active = -1;
+            magic_lac_dial (lac);
+    }
+    
+    icontrol_pid = getpid();
+
+    if( pthread_create(&l2tp_thread, NULL, network_thread, NULL) ) {
+		 l2tp_log (LOG_WARNING, "%s: Unable to create l2tp control thread.\n",
+    		__FUNCTION__);
+		 return -2;
+    }
+    icontrol_thread = 1;
+    
+    return 0;
+}
+
+void l2tp_exit() {
+	 stop_pppd(-1);
+    
+    if( icontrol_thread ) {
+		icontrol_thread = 0;
+		pthread_detach(l2tp_thread);
+    }
+    
+    if( isock_fd != -1 ) {
+        close(isock_fd);
+        isock_fd = -1;
+    }
+    
+    close_network();
+}
